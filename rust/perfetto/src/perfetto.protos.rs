// This file is @generated by prost-build.
/// Statistics for the internals of the tracing service.
///
/// Next id: 19.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceStats {
    /// Stats for the TraceBuffer(s) of the current trace session.
    #[prost(message, repeated, tag = "1")]
    pub buffer_stats: ::prost::alloc::vec::Vec<trace_stats::BufferStats>,
    /// The thresholds of each the `writer_stats` histogram buckets. This is
    /// emitted only once as all WriterStats share the same bucket layout.
    /// This field has the same cardinality of the
    /// `writer_stats.chunk_payload_histogram_{counts,sum}` - 1.
    /// (The -1 is because the last overflow bucket is not reported in the _def).
    /// An array of values \[10, 100, 1000\] in the _def array means that there are
    /// four buckets (3 + the implicit overflow bucket):
    /// \[0\]: x <= 10; \[1\]: 100 < x <= 1000; \[2\]: 1000 < x <= 1000; \[3\]: x > 1000.
    #[prost(int64, repeated, packed = "false", tag = "17")]
    pub chunk_payload_histogram_def: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "18")]
    pub writer_stats: ::prost::alloc::vec::Vec<trace_stats::WriterStats>,
    /// Num. producers connected (whether they are involved in the current tracing
    /// session or not).
    #[prost(uint32, optional, tag = "2")]
    pub producers_connected: ::core::option::Option<u32>,
    /// Num. producers ever seen for all trace sessions since startup (it's a good
    /// proxy for inferring num. producers crashed / killed).
    #[prost(uint64, optional, tag = "3")]
    pub producers_seen: ::core::option::Option<u64>,
    /// Num. data sources registered for all trace sessions.
    #[prost(uint32, optional, tag = "4")]
    pub data_sources_registered: ::core::option::Option<u32>,
    /// Num. data sources ever seen for all trace sessions since startup.
    #[prost(uint64, optional, tag = "5")]
    pub data_sources_seen: ::core::option::Option<u64>,
    /// Num. concurrently active tracing sessions.
    #[prost(uint32, optional, tag = "6")]
    pub tracing_sessions: ::core::option::Option<u32>,
    /// Num. buffers for all tracing session (not just the current one). This will
    /// be >= buffer_stats.size(), because the latter is only about the current
    /// session.
    #[prost(uint32, optional, tag = "7")]
    pub total_buffers: ::core::option::Option<u32>,
    /// Num. chunks that were discarded by the service before attempting to commit
    /// them to a buffer, e.g. because the producer specified an invalid buffer ID.
    #[prost(uint64, optional, tag = "8")]
    pub chunks_discarded: ::core::option::Option<u64>,
    /// Num. patches that were discarded by the service before attempting to apply
    /// them to a buffer, e.g. because the producer specified an invalid buffer ID.
    #[prost(uint64, optional, tag = "9")]
    pub patches_discarded: ::core::option::Option<u64>,
    /// Packets that failed validation of the TrustedPacket. If this is > 0, there
    /// is a bug in the producer.
    #[prost(uint64, optional, tag = "10")]
    pub invalid_packets: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "11")]
    pub filter_stats: ::core::option::Option<trace_stats::FilterStats>,
    /// Count of Flush() requests (either from the Consumer, or self-induced
    /// periodic flushes). The final Flush() is also included in the count.
    #[prost(uint64, optional, tag = "12")]
    pub flushes_requested: ::core::option::Option<u64>,
    /// The count of the Flush() requests that were completed successfully.
    /// In a well behaving trace this should always be == `flush_requests`.
    #[prost(uint64, optional, tag = "13")]
    pub flushes_succeeded: ::core::option::Option<u64>,
    /// The count of the Flush() requests that failed (in most timed out).
    /// In a well behaving trace this should always be == 0.
    #[prost(uint64, optional, tag = "14")]
    pub flushes_failed: ::core::option::Option<u64>,
    #[prost(enumeration = "trace_stats::FinalFlushOutcome", optional, tag = "15")]
    pub final_flush_outcome: ::core::option::Option<i32>,
}
/// Nested message and enum types in `TraceStats`.
pub mod trace_stats {
    /// From TraceBuffer::Stats.
    ///
    /// Next id: 21.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BufferStats {
        /// Size of the circular buffer in bytes.
        #[prost(uint64, optional, tag = "12")]
        pub buffer_size: ::core::option::Option<u64>,
        /// Num. bytes written into the circular buffer, including chunk headers.
        #[prost(uint64, optional, tag = "1")]
        pub bytes_written: ::core::option::Option<u64>,
        /// Num. bytes overwritten before they have been read (i.e. loss of data).
        #[prost(uint64, optional, tag = "13")]
        pub bytes_overwritten: ::core::option::Option<u64>,
        /// Total size of chunks that were fully read from the circular buffer by the
        /// consumer. This may not be equal to |bytes_written| either in the middle
        /// of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
        /// size of the chunks read from the buffer, including chunk headers, which
        /// will be different from the total size of packets returned to the
        /// consumer.
        ///
        /// The current utilization of the trace buffer (mid-tracing) can be obtained
        /// by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
        /// adding the difference of |padding_bytes_written| and
        /// |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
        /// Note that this represents the total size of buffered data in the buffer,
        /// yet this data may be spread non-contiguously through the buffer and may
        /// be overridden before the utilization reaches 100%.
        #[prost(uint64, optional, tag = "14")]
        pub bytes_read: ::core::option::Option<u64>,
        /// Num. bytes that were allocated as padding between chunks in the circular
        /// buffer.
        #[prost(uint64, optional, tag = "15")]
        pub padding_bytes_written: ::core::option::Option<u64>,
        /// Num. of padding bytes that were removed from the circular buffer when
        /// they were overwritten.
        ///
        /// The difference between |padding_bytes_written| and
        /// |padding_bytes_cleared| denotes the total size of padding currently
        /// present in the buffer.
        #[prost(uint64, optional, tag = "16")]
        pub padding_bytes_cleared: ::core::option::Option<u64>,
        /// Num. chunks (!= packets) written into the buffer.
        #[prost(uint64, optional, tag = "2")]
        pub chunks_written: ::core::option::Option<u64>,
        /// Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
        /// the same chunk with additional packets appended to the end.
        #[prost(uint64, optional, tag = "10")]
        pub chunks_rewritten: ::core::option::Option<u64>,
        /// Num. chunks overwritten before they have been read (i.e. loss of data).
        #[prost(uint64, optional, tag = "3")]
        pub chunks_overwritten: ::core::option::Option<u64>,
        /// Num. chunks discarded (i.e. loss of data). Can be > 0 only when a buffer
        /// is configured with FillPolicy == DISCARD.
        #[prost(uint64, optional, tag = "18")]
        pub chunks_discarded: ::core::option::Option<u64>,
        /// Num. chunks (!= packets) that were fully read from the circular buffer by
        /// the consumer. This may not be equal to |chunks_written| either in the
        /// middle of tracing, or if |chunks_overwritten| is non-zero.
        #[prost(uint64, optional, tag = "17")]
        pub chunks_read: ::core::option::Option<u64>,
        /// Num. chunks that were committed out of order.
        #[prost(uint64, optional, tag = "11")]
        pub chunks_committed_out_of_order: ::core::option::Option<u64>,
        /// Num. times the ring buffer wrapped around.
        #[prost(uint64, optional, tag = "4")]
        pub write_wrap_count: ::core::option::Option<u64>,
        /// Num. out-of-band (OOB) patches that succeeded.
        #[prost(uint64, optional, tag = "5")]
        pub patches_succeeded: ::core::option::Option<u64>,
        /// Num. OOB patches that failed (e.g., the chunk to patch was gone).
        #[prost(uint64, optional, tag = "6")]
        pub patches_failed: ::core::option::Option<u64>,
        /// Num. readaheads (for large multi-chunk packet reads) that ended up in a
        /// successful packet read.
        #[prost(uint64, optional, tag = "7")]
        pub readaheads_succeeded: ::core::option::Option<u64>,
        /// Num. readaheads aborted because of missing chunks in the sequence stream.
        /// Note that a small number > 0 is totally expected: occasionally, when
        /// issuing a read, the very last packet in a sequence might be incomplete
        /// (because the producer is still writing it while we read). The read will
        /// stop at that point, for that sequence, increasing this counter.
        #[prost(uint64, optional, tag = "8")]
        pub readaheads_failed: ::core::option::Option<u64>,
        /// Num. of violations of the SharedMemoryABI found while writing or reading
        /// the buffer. This is an indication of either a bug in the producer(s) or
        /// malicious producer(s).
        #[prost(uint64, optional, tag = "9")]
        pub abi_violations: ::core::option::Option<u64>,
        /// Num. of times the service detected packet loss on a trace writer
        /// sequence. This is usually caused by exhaustion of available chunks in the
        /// writer process's SMB. Note that this relies on the client's TraceWriter
        /// indicating this loss to the service -- packets lost for other reasons are
        /// not reflected in this stat.
        #[prost(uint64, optional, tag = "19")]
        pub trace_writer_packet_loss: ::core::option::Option<u64>,
    }
    /// Per TraceWriter stat. Each {producer, trace writer} tuple is publicly
    /// visible as a unique sequence ID in the trace.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WriterStats {
        /// This matches the TracePacket.trusted_packet_sequence_id and is used to
        /// correlate the stats with the actual packet types.
        #[prost(uint64, optional, tag = "1")]
        pub sequence_id: ::core::option::Option<u64>,
        /// The buffer index (0..N, as defined in the TraceConfig).
        #[prost(uint32, optional, tag = "4")]
        pub buffer: ::core::option::Option<u32>,
        /// These two arrays have the same cardinality and match the cardinality of
        /// chunk_payload_histogram_def + 1 (for the overflow bucket, see below).
        /// `sum` contains the SUM(entries) and `counts` contains the COUNT(entries)
        /// for each bucket.
        #[prost(uint64, repeated, tag = "2")]
        pub chunk_payload_histogram_counts: ::prost::alloc::vec::Vec<u64>,
        #[prost(int64, repeated, tag = "3")]
        pub chunk_payload_histogram_sum: ::prost::alloc::vec::Vec<i64>,
    }
    /// This is set only when the TraceConfig specifies a TraceFilter.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilterStats {
        #[prost(uint64, optional, tag = "1")]
        pub input_packets: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "2")]
        pub input_bytes: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "3")]
        pub output_bytes: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "4")]
        pub errors: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "5")]
        pub time_taken_ns: ::core::option::Option<u64>,
        /// The number of bytes discarded by the filter (i.e. output - input).
        /// The array has one entry for each buffer defined in the config (unless no
        /// packets for that buffer were seen and hence filtered).
        /// Note: the SUM(bytes_discarded_per_buffer) will be <= but not == the total
        /// (output_bytes - input_bytes) because the filter might also discard
        /// server-generated synthetic packets, that have no buffer index.
        #[prost(uint64, repeated, packed = "false", tag = "20")]
        pub bytes_discarded_per_buffer: ::prost::alloc::vec::Vec<u64>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FinalFlushOutcome {
        FinalFlushUnspecified = 0,
        FinalFlushSucceeded = 1,
        FinalFlushFailed = 2,
    }
    impl FinalFlushOutcome {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FinalFlushUnspecified => "FINAL_FLUSH_UNSPECIFIED",
                Self::FinalFlushSucceeded => "FINAL_FLUSH_SUCCEEDED",
                Self::FinalFlushFailed => "FINAL_FLUSH_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FINAL_FLUSH_UNSPECIFIED" => Some(Self::FinalFlushUnspecified),
                "FINAL_FLUSH_SUCCEEDED" => Some(Self::FinalFlushSucceeded),
                "FINAL_FLUSH_FAILED" => Some(Self::FinalFlushFailed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuiltinClock {
    Unknown = 0,
    Realtime = 1,
    RealtimeCoarse = 2,
    Monotonic = 3,
    MonotonicCoarse = 4,
    MonotonicRaw = 5,
    Boottime = 6,
    Tsc = 9,
    MaxId = 63,
}
impl BuiltinClock {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "BUILTIN_CLOCK_UNKNOWN",
            Self::Realtime => "BUILTIN_CLOCK_REALTIME",
            Self::RealtimeCoarse => "BUILTIN_CLOCK_REALTIME_COARSE",
            Self::Monotonic => "BUILTIN_CLOCK_MONOTONIC",
            Self::MonotonicCoarse => "BUILTIN_CLOCK_MONOTONIC_COARSE",
            Self::MonotonicRaw => "BUILTIN_CLOCK_MONOTONIC_RAW",
            Self::Boottime => "BUILTIN_CLOCK_BOOTTIME",
            Self::Tsc => "BUILTIN_CLOCK_TSC",
            Self::MaxId => "BUILTIN_CLOCK_MAX_ID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUILTIN_CLOCK_UNKNOWN" => Some(Self::Unknown),
            "BUILTIN_CLOCK_REALTIME" => Some(Self::Realtime),
            "BUILTIN_CLOCK_REALTIME_COARSE" => Some(Self::RealtimeCoarse),
            "BUILTIN_CLOCK_MONOTONIC" => Some(Self::Monotonic),
            "BUILTIN_CLOCK_MONOTONIC_COARSE" => Some(Self::MonotonicCoarse),
            "BUILTIN_CLOCK_MONOTONIC_RAW" => Some(Self::MonotonicRaw),
            "BUILTIN_CLOCK_BOOTTIME" => Some(Self::Boottime),
            "BUILTIN_CLOCK_TSC" => Some(Self::Tsc),
            "BUILTIN_CLOCK_MAX_ID" => Some(Self::MaxId),
            _ => None,
        }
    }
}
/// Data source that lists game modes and game interventions of games
/// on an Android device.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidGameInterventionListConfig {
    /// If not empty, emit info about only the following list of package names
    /// (exact match, no regex). Otherwise, emit info about all packages.
    #[prost(string, repeated, tag = "1")]
    pub package_name_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Custom configuration for the "android.input.inputevent" data source.
///
/// NOTE: Input traces can only be taken on debuggable (userdebug/eng) builds!
///
/// Next ID: 5
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidInputEventConfig {
    /// The tracing mode to use. If unspecified, it will default to
    /// TRACE_MODE_USE_RULES.
    #[prost(enumeration = "android_input_event_config::TraceMode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
    /// The list of rules to use to determine the trace level of events.
    /// Each event will be traced using the TraceLevel of the first rule that it
    /// triggers from this list. The rules are evaluated in the order in which they
    /// are specified. If an event does not match any of the rules,
    /// TRACE_LEVEL_NONE will be used by default.
    #[prost(message, repeated, tag = "2")]
    pub rules: ::prost::alloc::vec::Vec<android_input_event_config::TraceRule>,
    /// Trace input events processed by the system as they are being dispatched
    /// to application windows. All trace rules will apply.
    ///    - If this flag is used without enabling trace_dispatcher_window_dispatch,
    ///    it will
    ///      trace InputDispatcher's inbound events (which does not include events
    ///      synthesized within InputDispatcher) that match the rules.
    ///    - If used with trace_dispatcher_window_dispatch, all inbound and outbound
    ///    events
    ///      matching the rules, including all events synthesized within
    ///      InputDispatcher, will be traced.
    #[prost(bool, optional, tag = "3")]
    pub trace_dispatcher_input_events: ::core::option::Option<bool>,
    /// Trace details about which windows the system is sending each input event
    /// to. All trace rules will apply.
    #[prost(bool, optional, tag = "4")]
    pub trace_dispatcher_window_dispatch: ::core::option::Option<bool>,
}
/// Nested message and enum types in `AndroidInputEventConfig`.
pub mod android_input_event_config {
    /// A rule that specifies the TraceLevel for an event based on matching
    /// conditions. All matchers in the rule are optional. To trigger this rule, an
    /// event must match all of its specified matchers (i.e. the matchers function
    /// like a series of conditions connected by a logical 'AND' operator). A rule
    /// with no specified matchers will match all events. Next ID: 6
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TraceRule {
        /// The trace level to be used for events that trigger this rule.
        /// If unspecified, TRACE_LEVEL_NONE will be used by default.
        #[prost(enumeration = "TraceLevel", optional, tag = "1")]
        pub trace_level: ::core::option::Option<i32>,
        /// Package matchers
        ///
        /// Respectively matches if all or any of the target apps for this event are
        /// contained in the specified list of package names.
        ///
        /// Intended usage:
        ///    - Use match_all_packages to selectively allow tracing for the listed
        ///    packages.
        ///    - Use match_any_packages to selectively deny tracing for certain
        ///    packages.
        ///
        /// WARNING: Great care must be taken when designing rules for field tracing!
        ///           This is because each event is almost always sent to more than
        ///           one app.
        ///               For example, when allowing tracing for a package that has a
        ///               spy window
        ///           over the display (e.g. SystemUI) using match_any_packages,
        ///           essentially all input will be recorded on that display. This is
        ///           because the events will be sent to the spy as well as the
        ///           foreground app, and regardless of what the foreground app is,
        ///           the event will end up being traced.
        ///               Alternatively, when attempting to block tracing for specific
        ///               packages using
        ///           match_all_packages, no events will likely be blocked. This is
        ///           because the event will also be sent to other apps (such as, but
        ///           not limited to, ones with spy windows), so the matcher will not
        ///           match unless all other targets are also listed under the
        ///           match_all_packages list.
        #[prost(string, repeated, tag = "2")]
        pub match_all_packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub match_any_packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Matches if the event is secure, which means that at least one of the
        /// targets of this event is using the window flag FLAG_SECURE.
        #[prost(bool, optional, tag = "4")]
        pub match_secure: ::core::option::Option<bool>,
        /// Matches if there was an active IME connection while this event was being
        /// processed.
        #[prost(bool, optional, tag = "5")]
        pub match_ime_connection_active: ::core::option::Option<bool>,
    }
    /// Trace modes are tracing presets that are included in the system.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TraceMode {
        /// Preset mode for maximal tracing.
        /// WARNING: This will bypass all privacy measures on debuggable builds, and
        /// will record all
        ///           input events processed by the system, regardless of the context
        ///           in which they were processed. It should only be used for tracing
        ///           on a local device or for tests. It should NEVER be used for
        ///           field tracing.
        TraceAll = 0,
        /// Use the tracing rules defined in this config to specify what events to
        /// trace.
        UseRules = 1,
    }
    impl TraceMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TraceAll => "TRACE_MODE_TRACE_ALL",
                Self::UseRules => "TRACE_MODE_USE_RULES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRACE_MODE_TRACE_ALL" => Some(Self::TraceAll),
                "TRACE_MODE_USE_RULES" => Some(Self::UseRules),
                _ => None,
            }
        }
    }
    /// The level of tracing that should be applied to an event.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TraceLevel {
        /// Do not trace the input event.
        None = 0,
        /// Trace the event as a redacted event, where certain sensitive fields are
        /// omitted from the trace, including the coordinates of pointer events and
        /// the key/scan codes of key events.
        Redacted = 1,
        /// Trace the complete event.
        Complete = 2,
    }
    impl TraceLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "TRACE_LEVEL_NONE",
                Self::Redacted => "TRACE_LEVEL_REDACTED",
                Self::Complete => "TRACE_LEVEL_COMPLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRACE_LEVEL_NONE" => Some(Self::None),
                "TRACE_LEVEL_REDACTED" => Some(Self::Redacted),
                "TRACE_LEVEL_COMPLETE" => Some(Self::Complete),
                _ => None,
            }
        }
    }
}
/// Values from NDK's android/log.h.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AndroidLogId {
    /// MAIN.
    LidDefault = 0,
    LidRadio = 1,
    LidEvents = 2,
    LidSystem = 3,
    LidCrash = 4,
    LidStats = 5,
    LidSecurity = 6,
    LidKernel = 7,
}
impl AndroidLogId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LidDefault => "LID_DEFAULT",
            Self::LidRadio => "LID_RADIO",
            Self::LidEvents => "LID_EVENTS",
            Self::LidSystem => "LID_SYSTEM",
            Self::LidCrash => "LID_CRASH",
            Self::LidStats => "LID_STATS",
            Self::LidSecurity => "LID_SECURITY",
            Self::LidKernel => "LID_KERNEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LID_DEFAULT" => Some(Self::LidDefault),
            "LID_RADIO" => Some(Self::LidRadio),
            "LID_EVENTS" => Some(Self::LidEvents),
            "LID_SYSTEM" => Some(Self::LidSystem),
            "LID_CRASH" => Some(Self::LidCrash),
            "LID_STATS" => Some(Self::LidStats),
            "LID_SECURITY" => Some(Self::LidSecurity),
            "LID_KERNEL" => Some(Self::LidKernel),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AndroidLogPriority {
    PrioUnspecified = 0,
    /// _DEFAULT, but should never be seen in logs.
    PrioUnused = 1,
    PrioVerbose = 2,
    PrioDebug = 3,
    PrioInfo = 4,
    PrioWarn = 5,
    PrioError = 6,
    PrioFatal = 7,
}
impl AndroidLogPriority {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PrioUnspecified => "PRIO_UNSPECIFIED",
            Self::PrioUnused => "PRIO_UNUSED",
            Self::PrioVerbose => "PRIO_VERBOSE",
            Self::PrioDebug => "PRIO_DEBUG",
            Self::PrioInfo => "PRIO_INFO",
            Self::PrioWarn => "PRIO_WARN",
            Self::PrioError => "PRIO_ERROR",
            Self::PrioFatal => "PRIO_FATAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRIO_UNSPECIFIED" => Some(Self::PrioUnspecified),
            "PRIO_UNUSED" => Some(Self::PrioUnused),
            "PRIO_VERBOSE" => Some(Self::PrioVerbose),
            "PRIO_DEBUG" => Some(Self::PrioDebug),
            "PRIO_INFO" => Some(Self::PrioInfo),
            "PRIO_WARN" => Some(Self::PrioWarn),
            "PRIO_ERROR" => Some(Self::PrioError),
            "PRIO_FATAL" => Some(Self::PrioFatal),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidLogConfig {
    #[prost(enumeration = "AndroidLogId", repeated, packed = "false", tag = "1")]
    pub log_ids: ::prost::alloc::vec::Vec<i32>,
    /// If set ignores all log messages whose prio is < the given value.
    #[prost(enumeration = "AndroidLogPriority", optional, tag = "3")]
    pub min_prio: ::core::option::Option<i32>,
    /// If non-empty ignores all log messages whose tag doesn't match one of the
    /// specified values.
    #[prost(string, repeated, tag = "4")]
    pub filter_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Data source that polls for display state. This should only be used for
/// backward-compatibility; AndroidSystemPropertyConfig should be preferred.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidPolledStateConfig {
    /// Frequency of polling. If absent the state will be recorded once, at the
    /// start of the trace.
    /// This is required to be > 100ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "1")]
    pub poll_ms: ::core::option::Option<u32>,
}
/// Data source that polls for system properties.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidSystemPropertyConfig {
    /// Frequency of polling. If absent the state will be recorded once, at the
    /// start of the trace.
    /// This is required to be > 100ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "1")]
    pub poll_ms: ::core::option::Option<u32>,
    /// Properties to poll. All property names must start with "debug.tracing.".
    #[prost(string, repeated, tag = "2")]
    pub property_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Data source that controls the system properties used to guard initialization
/// of track_event producers (i.e. Skia) in apps using HWUI, and certain
/// processes like SurfaceFlinger.
///
/// This data source only tells Skia to initialized the Perfetto SDK and start
/// routing data to the Track Event system instead of ATrace. For those events
/// to actually show up in a trace, the track_event data source must be used as
/// well. The Perfetto SDK cannot be de-initialized, so some long-lived apps and
/// processes may need to be restarted for Skia to revert to using ATrace if
/// Track Events are no longer desired.
///
/// In addition to switching Skia to use Perfetto's track_event data source,
/// this "guard" also controls Skia's "broad tracing", which removes Skia's
/// internal tracing constraints and allows the track_event config to specify
/// which categories should be traced. Filtering to the "skia.always" category
/// *tag* in a track_event config can be used to re-enable the standard
/// constraints typically used with ATrace.
///
/// Data source name: android.sdk_sysprop_guard
/// Introduced in Android 14 (U) QPR1.
/// Next id: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidSdkSyspropGuardConfig {
    /// If true, configures SurfaceFlinger to initialize Skia's Perfetto
    /// integration with the track_event data source in RenderEngine.
    /// If false or omitted, the simpler ATrace fallback is used.
    ///
    /// NOTE: once enabled, Skia will only revert to ATrace if SurfaceFlinger is
    /// restarted.
    ///
    /// Specifically this sets the following system properties:
    ///    - debug.tracing.ctl.renderengine.skia_tracing_enabled
    ///    - debug.tracing.ctl.renderengine.skia_use_perfetto_track_events
    ///
    /// Does not affect actual track_event data *collection*, which must be
    /// configured seperately.
    #[prost(bool, optional, tag = "1")]
    pub surfaceflinger_skia_track_events: ::core::option::Option<bool>,
    /// If true, configures HWUI apps to initialize Skia's Perfetto integration
    /// with the track_event data source. hwui_package_name_filter
    /// can be used to control which apps are affected.
    /// If false or omitted, the simpler ATrace fallback is used.
    ///
    /// NOTE: once enabled, Skia will only revert to ATrace if the app is
    /// restarted.
    ///
    /// ATTENTION: affects ALL HWUI APPS if hwui_package_name_filter is not set!
    /// If filtering is NOT set, this controls these GLOBAL system properties:
    ///    - debug.tracing.ctl.hwui.skia_tracing_enabled
    ///    - debug.tracing.ctl.hwui.skia_use_perfetto_track_events
    /// If filtering IS set, this controls these APP-SPECIFIC system properties,
    /// for each package listed in the filter:
    ///    - debug.tracing.ctl.hwui.skia_tracing_enabled.<package.name>
    ///    - debug.tracing.ctl.hwui.skia_use_perfetto_track_events.<package.name>
    ///
    /// Does not affect actual track_event data *collection*, which must be
    /// configured seperately.
    #[prost(bool, optional, tag = "2")]
    pub hwui_skia_track_events: ::core::option::Option<bool>,
    /// If non-empty, hwui_skia_track_events applies to only the packages listed.
    /// Otherwise, hwui_skia_track_events applies globally to all HWUI apps.
    #[prost(string, repeated, tag = "3")]
    pub hwui_package_name_filter: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Network tracing data source that records details on all packets sent or
/// received by the network.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkPacketTraceConfig {
    /// Polling frequency in milliseconds. Network tracing writes to a fixed size
    /// ring buffer. The polling interval should be such that the ring buffer is
    /// unlikely to fill in that interval (or that filling is an acceptable risk).
    /// The minimum polling rate is 100ms (values below this are ignored).
    /// Introduced in Android 14 (U).
    #[prost(uint32, optional, tag = "1")]
    pub poll_ms: ::core::option::Option<u32>,
    /// The aggregation_threshold is the number of packets at which an event will
    /// switch from per-packet details to aggregate details. For example, a value
    /// of 50 means that if a particular event (grouped by the unique combinations
    /// of metadata fields: {interface, direction, uid, etc}) has fewer than 50
    /// packets, the exact timestamp and length are recorded for each packet. If
    /// there were 50 or more packets in an event, it would only record the total
    /// duration, packets, and length. A value of zero or unspecified will always
    /// / record per-packet details. A value of 1 always records aggregate details.
    #[prost(uint32, optional, tag = "2")]
    pub aggregation_threshold: ::core::option::Option<u32>,
    /// Specifies the maximum number of packet contexts to intern at a time. This
    /// prevents the interning table from growing too large and controls whether
    /// interning is enabled or disabled (a value of zero disables interning and
    /// is the default). When a data sources interning table reaches this amount,
    /// packet contexts will be inlined into NetworkPacketEvents.
    #[prost(uint32, optional, tag = "3")]
    pub intern_limit: ::core::option::Option<u32>,
    /// The following fields specify whether certain fields should be dropped from
    /// the output. Dropping fields improves normalization results, reduces the
    /// size of the interning table, and slightly reduces event size.
    #[prost(bool, optional, tag = "4")]
    pub drop_local_port: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub drop_remote_port: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub drop_tcp_flags: ::core::option::Option<bool>,
}
/// Data source that lists details (such as version code) about packages on an
/// Android device.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackagesListConfig {
    /// If not empty, emit info about only the following list of package names
    /// (exact match, no regex). Otherwise, emit info about all packages.
    #[prost(string, repeated, tag = "1")]
    pub package_name_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Data source that records events from the modem.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PixelModemConfig {
    #[prost(enumeration = "pixel_modem_config::EventGroup", optional, tag = "1")]
    pub event_group: ::core::option::Option<i32>,
    /// If set, record only events with these hashes.
    #[prost(int64, repeated, packed = "false", tag = "2")]
    pub pigweed_hash_allow_list: ::prost::alloc::vec::Vec<i64>,
    /// If set and allow_list is not set, deny events with these hashes.
    #[prost(int64, repeated, packed = "false", tag = "3")]
    pub pigweed_hash_deny_list: ::prost::alloc::vec::Vec<i64>,
}
/// Nested message and enum types in `PixelModemConfig`.
pub mod pixel_modem_config {
    /// Event group to record, as defined by the modem.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventGroup {
        Unknown = 0,
        /// Events suitable for low bandwidth tracing only.
        LowBandwidth = 1,
        /// Events suitable for high and low bandwidth tracing.
        HighAndLowBandwidth = 2,
    }
    impl EventGroup {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EVENT_GROUP_UNKNOWN",
                Self::LowBandwidth => "EVENT_GROUP_LOW_BANDWIDTH",
                Self::HighAndLowBandwidth => "EVENT_GROUP_HIGH_AND_LOW_BANDWIDTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_GROUP_UNKNOWN" => Some(Self::Unknown),
                "EVENT_GROUP_LOW_BANDWIDTH" => Some(Self::LowBandwidth),
                "EVENT_GROUP_HIGH_AND_LOW_BANDWIDTH" => Some(Self::HighAndLowBandwidth),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtoLogLevel {
    ProtologLevelUndefined = 0,
    ProtologLevelDebug = 1,
    ProtologLevelVerbose = 2,
    ProtologLevelInfo = 3,
    ProtologLevelWarn = 4,
    ProtologLevelError = 5,
    ProtologLevelWtf = 6,
}
impl ProtoLogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ProtologLevelUndefined => "PROTOLOG_LEVEL_UNDEFINED",
            Self::ProtologLevelDebug => "PROTOLOG_LEVEL_DEBUG",
            Self::ProtologLevelVerbose => "PROTOLOG_LEVEL_VERBOSE",
            Self::ProtologLevelInfo => "PROTOLOG_LEVEL_INFO",
            Self::ProtologLevelWarn => "PROTOLOG_LEVEL_WARN",
            Self::ProtologLevelError => "PROTOLOG_LEVEL_ERROR",
            Self::ProtologLevelWtf => "PROTOLOG_LEVEL_WTF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOLOG_LEVEL_UNDEFINED" => Some(Self::ProtologLevelUndefined),
            "PROTOLOG_LEVEL_DEBUG" => Some(Self::ProtologLevelDebug),
            "PROTOLOG_LEVEL_VERBOSE" => Some(Self::ProtologLevelVerbose),
            "PROTOLOG_LEVEL_INFO" => Some(Self::ProtologLevelInfo),
            "PROTOLOG_LEVEL_WARN" => Some(Self::ProtologLevelWarn),
            "PROTOLOG_LEVEL_ERROR" => Some(Self::ProtologLevelError),
            "PROTOLOG_LEVEL_WTF" => Some(Self::ProtologLevelWtf),
            _ => None,
        }
    }
}
/// Custom configuration for the "android.protolog" data source.
/// ProtoLog is a logging mechanism that is intented to be more efficient than
/// logcat. This configures what logs to capture in the tracing instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoLogConfig {
    /// Specified the configurations for each of the logging groups. If none is
    /// specified for a group the defaults will be used.
    #[prost(message, repeated, tag = "1")]
    pub group_overrides: ::prost::alloc::vec::Vec<ProtoLogGroup>,
    /// Specified what tracing mode to use for the tracing instance.
    #[prost(enumeration = "proto_log_config::TracingMode", optional, tag = "2")]
    pub tracing_mode: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ProtoLogConfig`.
pub mod proto_log_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TracingMode {
        /// When using the DEFAULT tracing mode, only log groups and levels specified
        /// in the group_overrides are traced.
        Default = 0,
        /// When using the ENABLE_ALL tracing mode, all log groups and levels are
        /// traced, unless specified in the group_overrides.
        EnableAll = 1,
    }
    impl TracingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::EnableAll => "ENABLE_ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "ENABLE_ALL" => Some(Self::EnableAll),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoLogGroup {
    /// The ProtoLog group name this configuration entry applies to.
    #[prost(string, optional, tag = "1")]
    pub group_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Specify the level from which to start capturing protologs.
    /// e.g. if ProtoLogLevel.WARN is specified only warning, errors and fatal log
    /// message will be traced.
    #[prost(enumeration = "ProtoLogLevel", optional, tag = "2")]
    pub log_from: ::core::option::Option<i32>,
    /// When set to true we will collect the stacktrace for each protolog message
    /// in this group that we are tracing.
    #[prost(bool, optional, tag = "3")]
    pub collect_stacktrace: ::core::option::Option<bool>,
}
/// Custom configuration for the "android.surfaceflinger.layers" data source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceFlingerLayersConfig {
    #[prost(enumeration = "surface_flinger_layers_config::Mode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
    #[prost(
        enumeration = "surface_flinger_layers_config::TraceFlag",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub trace_flags: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `SurfaceFlingerLayersConfig`.
pub mod surface_flinger_layers_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// Trace layers snapshots. A snapshot is taken every time a layers change
        /// occurs.
        Active = 1,
        /// Generate layers snapshots from the transactions kept in the
        /// SurfaceFlinger's internal ring buffer.
        /// The layers snapshots generation occurs when this data source is flushed.
        Generated = 2,
        /// Trace a single layers snapshot.
        Dump = 3,
        /// Default mode (applied by SurfaceFlinger if no mode is specified).
        /// Same as MODE_GENERATED, but triggers the layers snapshots generation only when a bugreport
        /// is taken.
        GeneratedBugreportOnly = 4,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Active => "MODE_ACTIVE",
                Self::Generated => "MODE_GENERATED",
                Self::Dump => "MODE_DUMP",
                Self::GeneratedBugreportOnly => "MODE_GENERATED_BUGREPORT_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MODE_ACTIVE" => Some(Self::Active),
                "MODE_GENERATED" => Some(Self::Generated),
                "MODE_DUMP" => Some(Self::Dump),
                "MODE_GENERATED_BUGREPORT_ONLY" => Some(Self::GeneratedBugreportOnly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TraceFlag {
        Unspecified = 0,
        Input = 2,
        Composition = 4,
        Extra = 8,
        Hwc = 16,
        Buffers = 32,
        VirtualDisplays = 64,
        /// INPUT | COMPOSITION | EXTRA
        All = 14,
    }
    impl TraceFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRACE_FLAG_UNSPECIFIED",
                Self::Input => "TRACE_FLAG_INPUT",
                Self::Composition => "TRACE_FLAG_COMPOSITION",
                Self::Extra => "TRACE_FLAG_EXTRA",
                Self::Hwc => "TRACE_FLAG_HWC",
                Self::Buffers => "TRACE_FLAG_BUFFERS",
                Self::VirtualDisplays => "TRACE_FLAG_VIRTUAL_DISPLAYS",
                Self::All => "TRACE_FLAG_ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRACE_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                "TRACE_FLAG_INPUT" => Some(Self::Input),
                "TRACE_FLAG_COMPOSITION" => Some(Self::Composition),
                "TRACE_FLAG_EXTRA" => Some(Self::Extra),
                "TRACE_FLAG_HWC" => Some(Self::Hwc),
                "TRACE_FLAG_BUFFERS" => Some(Self::Buffers),
                "TRACE_FLAG_VIRTUAL_DISPLAYS" => Some(Self::VirtualDisplays),
                "TRACE_FLAG_ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
/// Custom configuration for the "android.surfaceflinger.transactions" data
/// source.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SurfaceFlingerTransactionsConfig {
    #[prost(
        enumeration = "surface_flinger_transactions_config::Mode",
        optional,
        tag = "1"
    )]
    pub mode: ::core::option::Option<i32>,
}
/// Nested message and enum types in `SurfaceFlingerTransactionsConfig`.
pub mod surface_flinger_transactions_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// Default mode (applied by SurfaceFlinger if no mode is specified).
        /// SurfaceFlinger writes its internal ring buffer of transactions every time
        /// the data source is flushed. The ring buffer contains the SurfaceFlinger's
        /// initial state and the latest transactions.
        Continuous = 1,
        /// SurfaceFlinger writes the initial state and then each incoming
        /// transaction until the data source is stopped.
        Active = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Continuous => "MODE_CONTINUOUS",
                Self::Active => "MODE_ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MODE_CONTINUOUS" => Some(Self::Continuous),
                "MODE_ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeConfig {
    #[prost(string, optional, tag = "1")]
    pub trace_config: ::core::option::Option<::prost::alloc::string::String>,
    /// When enabled, the data source should only fill in fields in the output that
    /// are not potentially privacy sensitive.
    #[prost(bool, optional, tag = "2")]
    pub privacy_filtering_enabled: ::core::option::Option<bool>,
    /// Instead of emitting binary protobuf, convert the trace data to the legacy
    /// JSON format. Note that the trace data will still be returned as a series of
    /// TracePackets, but the embedded data will be JSON instead of serialized
    /// protobuf.
    #[prost(bool, optional, tag = "3")]
    pub convert_to_legacy_json: ::core::option::Option<bool>,
    #[prost(enumeration = "chrome_config::ClientPriority", optional, tag = "4")]
    pub client_priority: ::core::option::Option<i32>,
    /// Applicable only when using legacy JSON format.
    /// If |json_agent_label_filter| is not empty, only data pertaining to
    /// the specified tracing agent label (e.g. "traceEvents") will be returned.
    #[prost(string, optional, tag = "5")]
    pub json_agent_label_filter: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChromeConfig`.
pub mod chrome_config {
    /// Priority of the tracing session client. A higher priority session may
    /// preempt a lower priority one in configurations where concurrent sessions
    /// aren't supported.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClientPriority {
        Unknown = 0,
        Background = 1,
        UserInitiated = 2,
    }
    impl ClientPriority {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Background => "BACKGROUND",
                Self::UserInitiated => "USER_INITIATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "BACKGROUND" => Some(Self::Background),
                "USER_INITIATED" => Some(Self::UserInitiated),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct V8Config {
    /// Whether to log the actual content of scripts (e.g. content of the JS file
    /// that was compiled to generate code).
    /// ATTENTION: This could considerably increase the size of the resuling trace
    ///             file.
    #[prost(bool, optional, tag = "1")]
    pub log_script_sources: ::core::option::Option<bool>,
    /// Whether to log the generated code for jitted functions (machine code or
    /// bytecode).
    /// ATTENTION: This could considerably increase the size of the resuling trace
    ///             file.
    #[prost(bool, optional, tag = "2")]
    pub log_instructions: ::core::option::Option<bool>,
}
/// Proto definition based on the struct _EVENT_TRACE_PROPERTIES definition
/// See: <https://learn.microsoft.com/en-us/windows/win32/api/evntrace/>
/// ns-evntrace-event_trace_properties
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtwConfig {
    /// The kernel_flags determines the flags that will be used by the etw tracing
    /// session. These kernel flags have been built to expose the useful events
    /// captured from the kernel mode only.
    #[prost(
        enumeration = "etw_config::KernelFlag",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub kernel_flags: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `EtwConfig`.
pub mod etw_config {
    /// The KernelFlag represent list of kernel flags that we are intrested in.
    /// To get a more extensive list run 'xperf -providers k'.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KernelFlag {
        Cswitch = 0,
        Dispatcher = 1,
    }
    impl KernelFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Cswitch => "CSWITCH",
                Self::Dispatcher => "DISPATCHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CSWITCH" => Some(Self::Cswitch),
                "DISPATCHER" => Some(Self::Dispatcher),
                _ => None,
            }
        }
    }
}
/// Next id: 28
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtraceConfig {
    /// Ftrace events to record, example: "sched/sched_switch".
    #[prost(string, repeated, tag = "1")]
    pub ftrace_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Android-specific event categories:
    #[prost(string, repeated, tag = "2")]
    pub atrace_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub atrace_apps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Size of each per-cpu kernel ftrace ring buffer.
    /// Not guaranteed if there are multiple concurrent tracing sessions, as the
    /// buffers cannot be resized without pausing recording in the kernel.
    #[prost(uint32, optional, tag = "10")]
    pub buffer_size_kb: ::core::option::Option<u32>,
    /// If set, specifies how often the tracing daemon reads from the kernel ring
    /// buffer. Not guaranteed if there are multiple concurrent tracing sessions.
    /// Leave unset unless you're fine-tuning a local config.
    #[prost(uint32, optional, tag = "11")]
    pub drain_period_ms: ::core::option::Option<u32>,
    /// If set, the tracing daemon will read kernel ring buffers as soon as
    /// they're filled past this percentage of occupancy. In other words, a value
    /// of 50 means that a read pass is triggered as soon as any per-cpu buffer is
    /// half-full. Not guaranteed if there are multiple concurrent tracing
    /// sessions.
    /// Currently does nothing on Linux kernels below v6.1.
    /// Introduced in: perfetto v43.
    #[prost(uint32, optional, tag = "26")]
    pub drain_buffer_percent: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "12")]
    pub compact_sched: ::core::option::Option<ftrace_config::CompactSchedConfig>,
    #[prost(message, optional, tag = "22")]
    pub print_filter: ::core::option::Option<ftrace_config::PrintFilter>,
    /// Enables symbol name resolution against /proc/kallsyms.
    /// It requires that either traced_probes is running as root or that
    /// kptr_restrict has been manually lowered.
    /// It does not disclose KASLR, symbol addresses are mangled.
    #[prost(bool, optional, tag = "13")]
    pub symbolize_ksyms: ::core::option::Option<bool>,
    #[prost(enumeration = "ftrace_config::KsymsMemPolicy", optional, tag = "17")]
    pub ksyms_mem_policy: ::core::option::Option<i32>,
    /// By default the kernel symbolizer is lazily initialized on a deferred task
    /// to reduce ftrace's time-to-start-recording. Unfortunately that makes
    /// ksyms integration tests hard. This flag forces the kernel symbolizer to be
    /// initialized synchronously on the data source start and hence avoiding
    /// timing races in tests.
    /// DEPRECATED in v28 / Android U. This is now the default behavior, setting it
    /// to true is a no-op.
    #[deprecated]
    #[prost(bool, optional, tag = "14")]
    pub initialize_ksyms_synchronously_for_testing: ::core::option::Option<bool>,
    /// When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
    /// this option causes traced_probes to enable the "kmem/rss_stat_throttled"
    /// event instead if present, and fall back to "kmem/rss_stat" if not present.
    /// The historical context for this is the following:
    /// - Up to Android S (12), the rss_stat was internally throttled in its
    ///    kernel implementation.
    /// - A change introduced in the kernels after S has introduced a new
    ///    "rss_stat_throttled" making the original "rss_stat" event unthrottled
    ///    (hence very spammy).
    /// - Not all Android T/13 devices will receive a new kernel though, hence we
    ///    need to deal with both cases.
    /// For more context: go/rss-stat-throttled.
    #[prost(bool, optional, tag = "15")]
    pub throttle_rss_stat: ::core::option::Option<bool>,
    /// If true, avoid enabling events that aren't statically known by
    /// traced_probes. Otherwise, the default is to emit such events as
    /// GenericFtraceEvent protos.
    /// Prefer to keep this flag at its default. This was added for Android
    /// tracing, where atrace categories and/or atrace HAL requested events can
    /// expand to events that aren't of interest to the tracing user.
    /// Introduced in: Android T.
    #[prost(bool, optional, tag = "16")]
    pub disable_generic_events: ::core::option::Option<bool>,
    /// The subset of syscalls to record. To record all syscalls, leave this unset
    /// and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
    /// * before perfetto v43, requires the config to also enable
    ///    raw_syscalls/sys_{enter,exit}.
    /// * perfetto v43+ does the right thing if you set only this field.
    /// Example: \["sys_read", "sys_open"\].
    /// Introduced in: Android U.
    #[prost(string, repeated, tag = "18")]
    pub syscall_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, enable the "function_graph" kernel tracer that emits events
    /// whenever a kernel function is entered and exited
    /// (funcgraph_entry/funcgraph_exit).
    /// Notes on use:
    /// * Requires |symbolize_ksyms| for function name resolution.
    /// * Use |function_filters| or |function_graph_roots| to constrain the traced
    ///    set of functions, otherwise the event bandwidth will be too high for
    ///    practical use.
    /// * The data source might be rejected if there is already a concurrent
    ///    ftrace data source that does not use function graph itself, as we do not
    ///    support switching kernel tracers mid-trace.
    /// * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
    ///    enabled if "cat /sys/kernel/tracing/available_tracers" includes
    ///    "function_graph".
    /// Android:
    /// * Available only on debuggable builds.
    /// * Introduced in: Android U.
    #[prost(bool, optional, tag = "19")]
    pub enable_function_graph: ::core::option::Option<bool>,
    /// Constrains the set of functions traced when |enable_function_graph| is
    /// true. Supports globs, e.g. "sched*". You can specify multiple filters,
    /// in which case all matching functions will be traced. See kernel
    /// documentation on ftrace "set_ftrace_filter" file for more details.
    /// Android:
    /// * Available only on debuggable builds.
    /// * Introduced in: Android U.
    #[prost(string, repeated, tag = "20")]
    pub function_filters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If |enable_function_graph| is true, trace this set of functions *and* all
    /// of its callees. Supports globs. Can be set together with
    /// |function_filters|, in which case only callees matching the filter will be
    /// traced. If setting both, you most likely want all roots to also be
    /// included in |function_filters|.
    /// Android:
    /// * Available only on debuggable builds.
    /// * Introduced in: Android U.
    #[prost(string, repeated, tag = "21")]
    pub function_graph_roots: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, does not clear ftrace buffers before the start of the program.
    /// This makes sense only if this is the first ftrace data source instance
    /// created after the daemon has been started. Can be useful for gathering boot
    /// traces, if ftrace has been separately configured (e.g. via kernel
    /// commandline).
    #[prost(bool, optional, tag = "23")]
    pub preserve_ftrace_buffer: ::core::option::Option<bool>,
    /// If true, overrides the default timestamp clock and uses a raw hardware
    /// based monotonic clock for getting timestamps.
    /// * Introduced in: Android U.
    #[prost(bool, optional, tag = "24")]
    pub use_monotonic_raw_clock: ::core::option::Option<bool>,
    /// If |instance_name| is not empty, then attempt to use that tracefs instance
    /// for event recording. Normally, this means
    /// `/sys/kernel/tracing/instances/$instance_name`.
    ///
    /// The name "hyp" is reserved.
    ///
    /// The instance must already exist, the tracing daemon *will not* create it
    /// for you as it typically doesn't have such permissions.
    /// Only a subset of features is guaranteed to work with non-default instances,
    /// at the time of writing:
    ///   * ftrace_events
    ///   * buffer_size_kb
    #[prost(string, optional, tag = "25")]
    pub instance_name: ::core::option::Option<::prost::alloc::string::String>,
    /// If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
    /// implementation to choose a bigger buffer size.
    ///
    /// Most configs for perfetto v43+ should simply leave both fields unset.
    ///
    /// If you need a config compatible with a range of perfetto builds and you
    /// used to set a non-default buffer_size_kb, consider setting both fields.
    /// Example:
    ///    buffer_size_kb: 4096
    ///    buffer_size_lower_bound: true
    /// On older builds, the per-cpu buffers will be exactly 4 MB.
    /// On v43+, buffers will be at least 4 MB.
    /// In both cases, neither is guaranteed if there are other concurrent
    /// perfetto ftrace sessions, as the buffers cannot be resized without pausing
    /// the recording in the kernel.
    /// Introduced in: perfetto v43.
    #[prost(bool, optional, tag = "27")]
    pub buffer_size_lower_bound: ::core::option::Option<bool>,
}
/// Nested message and enum types in `FtraceConfig`.
pub mod ftrace_config {
    /// Configuration for compact encoding of scheduler events. When enabled (and
    /// recording the relevant ftrace events), specific high-volume events are
    /// encoded in a denser format than normal.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CompactSchedConfig {
        /// If true, and sched_switch or sched_waking ftrace events are enabled,
        /// record those events in the compact format.
        ///
        /// If the field is unset, the default is:
        /// * perfetto v42.0+: enabled
        /// * before: disabled
        #[prost(bool, optional, tag = "1")]
        pub enabled: ::core::option::Option<bool>,
    }
    /// Optional filter for "ftrace/print" events.
    ///
    /// The filter consists of multiple rules. As soon as a rule matches (the rules
    /// are processed in order), its `allow` field will be used as the outcome: if
    /// `allow` is true, the event will be included in the trace, otherwise it will
    /// be discarded. If an event does not match any rule, it will be allowed by
    /// default (a rule with an empty prefix and allow=false, disallows everything
    /// by default).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrintFilter {
        #[prost(message, repeated, tag = "1")]
        pub rules: ::prost::alloc::vec::Vec<print_filter::Rule>,
    }
    /// Nested message and enum types in `PrintFilter`.
    pub mod print_filter {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Rule {
            #[prost(bool, optional, tag = "2")]
            pub allow: ::core::option::Option<bool>,
            #[prost(oneof = "rule::Match", tags = "1, 3")]
            pub r#match: ::core::option::Option<rule::Match>,
        }
        /// Nested message and enum types in `Rule`.
        pub mod rule {
            /// Matches an atrace message of the form:
            /// <type>|pid|<prefix>...
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AtraceMessage {
                #[prost(string, optional, tag = "1")]
                pub r#type: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(string, optional, tag = "2")]
                pub prefix: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Match {
                /// This rule matches if `prefix` matches exactly with the beginning of
                /// the "ftrace/print" "buf" field.
                #[prost(string, tag = "1")]
                Prefix(::prost::alloc::string::String),
                /// This rule matches if the "buf" field contains an atrace-style print
                /// message as specified in `atrace_msg`.
                #[prost(message, tag = "3")]
                AtraceMsg(AtraceMessage),
            }
        }
    }
    /// When symbolize_ksyms=true, determines whether the traced_probes daemon
    /// should keep the symbol map in memory (and reuse it for future tracing
    /// sessions) or clear it (saving memory) and re-create it on each tracing
    /// session (wasting cpu and wall time).
    /// The tradeoff is roughly:
    ///   KSYMS_RETAIN: pay a fixed ~1.2 MB cost after the first trace.
    ///   KSYMS_CLEANUP_ON_STOP: pay a ~300-500ms cost when starting each trace.
    /// Default behavior: KSYMS_CLEANUP_ON_STOP.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KsymsMemPolicy {
        KsymsUnspecified = 0,
        KsymsCleanupOnStop = 1,
        KsymsRetain = 2,
    }
    impl KsymsMemPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::KsymsUnspecified => "KSYMS_UNSPECIFIED",
                Self::KsymsCleanupOnStop => "KSYMS_CLEANUP_ON_STOP",
                Self::KsymsRetain => "KSYMS_RETAIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KSYMS_UNSPECIFIED" => Some(Self::KsymsUnspecified),
                "KSYMS_CLEANUP_ON_STOP" => Some(Self::KsymsCleanupOnStop),
                "KSYMS_RETAIN" => Some(Self::KsymsRetain),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuCounterConfig {
    /// Desired sampling interval for counters.
    #[prost(uint64, optional, tag = "1")]
    pub counter_period_ns: ::core::option::Option<u64>,
    /// List of counters to be sampled. Counter IDs correspond to the ones
    /// described in GpuCounterSpec in the data source descriptor.
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub counter_ids: ::prost::alloc::vec::Vec<u32>,
    /// Sample counters by instrumenting command buffers.
    #[prost(bool, optional, tag = "3")]
    pub instrumented_sampling: ::core::option::Option<bool>,
    /// Fix gpu clock rate during trace session.
    #[prost(bool, optional, tag = "4")]
    pub fix_gpu_clock: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VulkanMemoryConfig {
    /// Tracking driver memory usage events
    #[prost(bool, optional, tag = "1")]
    pub track_driver_memory_usage: ::core::option::Option<bool>,
    /// Tracking device memory usage events
    #[prost(bool, optional, tag = "2")]
    pub track_device_memory_usage: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InodeFileConfig {
    /// How long to pause between batches.
    #[prost(uint32, optional, tag = "1")]
    pub scan_interval_ms: ::core::option::Option<u32>,
    /// How long to wait before the first scan in order to accumulate inodes.
    #[prost(uint32, optional, tag = "2")]
    pub scan_delay_ms: ::core::option::Option<u32>,
    /// How many inodes to scan in one batch.
    #[prost(uint32, optional, tag = "3")]
    pub scan_batch_size: ::core::option::Option<u32>,
    /// Do not scan for inodes not found in the static map.
    #[prost(bool, optional, tag = "4")]
    pub do_not_scan: ::core::option::Option<bool>,
    /// If non-empty, only scan inodes corresponding to block devices named in
    /// this list.
    #[prost(string, repeated, tag = "5")]
    pub scan_mount_points: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// When encountering an inode belonging to a block device corresponding
    /// to one of the mount points in this map, scan its scan_roots instead.
    #[prost(message, repeated, tag = "6")]
    pub mount_point_mapping: ::prost::alloc::vec::Vec<
        inode_file_config::MountPointMappingEntry,
    >,
}
/// Nested message and enum types in `InodeFileConfig`.
pub mod inode_file_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MountPointMappingEntry {
        #[prost(string, optional, tag = "1")]
        pub mountpoint: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub scan_roots: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsoleConfig {
    #[prost(enumeration = "console_config::Output", optional, tag = "1")]
    pub output: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub enable_colors: ::core::option::Option<bool>,
}
/// Nested message and enum types in `ConsoleConfig`.
pub mod console_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Output {
        Unspecified = 0,
        Stdout = 1,
        Stderr = 2,
    }
    impl Output {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OUTPUT_UNSPECIFIED",
                Self::Stdout => "OUTPUT_STDOUT",
                Self::Stderr => "OUTPUT_STDERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_UNSPECIFIED" => Some(Self::Unspecified),
                "OUTPUT_STDOUT" => Some(Self::Stdout),
                "OUTPUT_STDERR" => Some(Self::Stderr),
                _ => None,
            }
        }
    }
}
/// Configuration for trace packet interception. Used for diverting trace data to
/// non-Perfetto sources (e.g., logging to the console, ETW) when using the
/// Perfetto SDK.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptorConfig {
    /// Matches the name given to RegisterInterceptor().
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub console_config: ::core::option::Option<ConsoleConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidPowerConfig {
    #[prost(uint32, optional, tag = "1")]
    pub battery_poll_ms: ::core::option::Option<u32>,
    #[prost(
        enumeration = "android_power_config::BatteryCounters",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub battery_counters: ::prost::alloc::vec::Vec<i32>,
    /// Where available enables per-power-rail measurements.
    #[prost(bool, optional, tag = "3")]
    pub collect_power_rails: ::core::option::Option<bool>,
    /// Provides a breakdown of energy estimation for various subsystem (e.g. GPU).
    /// Available from Android S.
    #[prost(bool, optional, tag = "4")]
    pub collect_energy_estimation_breakdown: ::core::option::Option<bool>,
    /// Provides a breakdown of time in state for various subsystems.
    /// Available from Android U.
    #[prost(bool, optional, tag = "5")]
    pub collect_entity_state_residency: ::core::option::Option<bool>,
}
/// Nested message and enum types in `AndroidPowerConfig`.
pub mod android_power_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BatteryCounters {
        BatteryCounterUnspecified = 0,
        /// Coulomb counter.
        BatteryCounterCharge = 1,
        /// Charge (%).
        BatteryCounterCapacityPercent = 2,
        /// Instantaneous current.
        BatteryCounterCurrent = 3,
        /// Avg current.
        BatteryCounterCurrentAvg = 4,
        /// Instantaneous voltage.
        BatteryCounterVoltage = 5,
    }
    impl BatteryCounters {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BatteryCounterUnspecified => "BATTERY_COUNTER_UNSPECIFIED",
                Self::BatteryCounterCharge => "BATTERY_COUNTER_CHARGE",
                Self::BatteryCounterCapacityPercent => "BATTERY_COUNTER_CAPACITY_PERCENT",
                Self::BatteryCounterCurrent => "BATTERY_COUNTER_CURRENT",
                Self::BatteryCounterCurrentAvg => "BATTERY_COUNTER_CURRENT_AVG",
                Self::BatteryCounterVoltage => "BATTERY_COUNTER_VOLTAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BATTERY_COUNTER_UNSPECIFIED" => Some(Self::BatteryCounterUnspecified),
                "BATTERY_COUNTER_CHARGE" => Some(Self::BatteryCounterCharge),
                "BATTERY_COUNTER_CAPACITY_PERCENT" => {
                    Some(Self::BatteryCounterCapacityPercent)
                }
                "BATTERY_COUNTER_CURRENT" => Some(Self::BatteryCounterCurrent),
                "BATTERY_COUNTER_CURRENT_AVG" => Some(Self::BatteryCounterCurrentAvg),
                "BATTERY_COUNTER_VOLTAGE" => Some(Self::BatteryCounterVoltage),
                _ => None,
            }
        }
    }
}
/// This enum is obtained by post-processing
/// AOSP/frameworks/proto_logging/stats/atoms.proto through
/// AOSP/external/perfetto/tools/update-statsd-descriptor, which extracts one
/// enum value for each proto field defined in the upstream atoms.proto.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AtomId {
    AtomUnspecified = 0,
    AtomBleScanStateChanged = 2,
    AtomProcessStateChanged = 3,
    AtomBleScanResultReceived = 4,
    AtomSensorStateChanged = 5,
    AtomGpsScanStateChanged = 6,
    AtomSyncStateChanged = 7,
    AtomScheduledJobStateChanged = 8,
    AtomScreenBrightnessChanged = 9,
    AtomWakelockStateChanged = 10,
    AtomLongPartialWakelockStateChanged = 11,
    AtomMobileRadioPowerStateChanged = 12,
    AtomWifiRadioPowerStateChanged = 13,
    AtomActivityManagerSleepStateChanged = 14,
    AtomMemoryFactorStateChanged = 15,
    AtomExcessiveCpuUsageReported = 16,
    AtomCachedKillReported = 17,
    AtomProcessMemoryStatReported = 18,
    AtomLauncherEvent = 19,
    AtomBatterySaverModeStateChanged = 20,
    AtomDeviceIdleModeStateChanged = 21,
    AtomDeviceIdlingModeStateChanged = 22,
    AtomAudioStateChanged = 23,
    AtomMediaCodecStateChanged = 24,
    AtomCameraStateChanged = 25,
    AtomFlashlightStateChanged = 26,
    AtomUidProcessStateChanged = 27,
    AtomProcessLifeCycleStateChanged = 28,
    AtomScreenStateChanged = 29,
    AtomBatteryLevelChanged = 30,
    AtomChargingStateChanged = 31,
    AtomPluggedStateChanged = 32,
    AtomInteractiveStateChanged = 33,
    AtomTouchEventReported = 34,
    AtomWakeupAlarmOccurred = 35,
    AtomKernelWakeupReported = 36,
    AtomWifiLockStateChanged = 37,
    AtomWifiSignalStrengthChanged = 38,
    AtomWifiScanStateChanged = 39,
    AtomPhoneSignalStrengthChanged = 40,
    AtomSettingChanged = 41,
    AtomActivityForegroundStateChanged = 42,
    AtomIsolatedUidChanged = 43,
    AtomPacketWakeupOccurred = 44,
    AtomWallClockTimeShifted = 45,
    AtomAnomalyDetected = 46,
    AtomAppBreadcrumbReported = 47,
    AtomAppStartOccurred = 48,
    AtomAppStartCanceled = 49,
    AtomAppStartFullyDrawn = 50,
    AtomLmkKillOccurred = 51,
    AtomPictureInPictureStateChanged = 52,
    AtomWifiMulticastLockStateChanged = 53,
    AtomLmkStateChanged = 54,
    AtomAppStartMemoryStateCaptured = 55,
    AtomShutdownSequenceReported = 56,
    AtomBootSequenceReported = 57,
    AtomDaveyOccurred = 58,
    AtomOverlayStateChanged = 59,
    AtomForegroundServiceStateChanged = 60,
    AtomCallStateChanged = 61,
    AtomKeyguardStateChanged = 62,
    AtomKeyguardBouncerStateChanged = 63,
    AtomKeyguardBouncerPasswordEntered = 64,
    AtomAppDied = 65,
    AtomResourceConfigurationChanged = 66,
    AtomBluetoothEnabledStateChanged = 67,
    AtomBluetoothConnectionStateChanged = 68,
    AtomGpsSignalQualityChanged = 69,
    AtomUsbConnectorStateChanged = 70,
    AtomSpeakerImpedanceReported = 71,
    AtomHardwareFailed = 72,
    AtomPhysicalDropDetected = 73,
    AtomChargeCyclesReported = 74,
    AtomMobileConnectionStateChanged = 75,
    AtomMobileRadioTechnologyChanged = 76,
    AtomUsbDeviceAttached = 77,
    AtomAppCrashOccurred = 78,
    AtomAnrOccurred = 79,
    AtomWtfOccurred = 80,
    AtomLowMemReported = 81,
    AtomGenericAtom = 82,
    AtomVibratorStateChanged = 84,
    AtomDeferredJobStatsReported = 85,
    AtomThermalThrottling = 86,
    AtomBiometricAcquired = 87,
    AtomBiometricAuthenticated = 88,
    AtomBiometricErrorOccurred = 89,
    AtomUiEventReported = 90,
    AtomBatteryHealthSnapshot = 91,
    AtomSlowIo = 92,
    AtomBatteryCausedShutdown = 93,
    AtomPhoneServiceStateChanged = 94,
    AtomPhoneStateChanged = 95,
    AtomUserRestrictionChanged = 96,
    AtomSettingsUiChanged = 97,
    AtomConnectivityStateChanged = 98,
    AtomServiceStateChanged = 99,
    AtomServiceLaunchReported = 100,
    AtomFlagFlipUpdateOccurred = 101,
    AtomBinaryPushStateChanged = 102,
    AtomDevicePolicyEvent = 103,
    AtomDocsUiFileOpCanceled = 104,
    AtomDocsUiFileOpCopyMoveModeReported = 105,
    AtomDocsUiFileOpFailure = 106,
    AtomDocsUiProviderFileOp = 107,
    AtomDocsUiInvalidScopedAccessRequest = 108,
    AtomDocsUiLaunchReported = 109,
    AtomDocsUiRootVisited = 110,
    AtomDocsUiStartupMs = 111,
    AtomDocsUiUserActionReported = 112,
    AtomWifiEnabledStateChanged = 113,
    AtomWifiRunningStateChanged = 114,
    AtomAppCompacted = 115,
    AtomNetworkDnsEventReported = 116,
    AtomDocsUiPickerLaunchedFromReported = 117,
    AtomDocsUiPickResultReported = 118,
    AtomDocsUiSearchModeReported = 119,
    AtomDocsUiSearchTypeReported = 120,
    AtomDataStallEvent = 121,
    AtomRescuePartyResetReported = 122,
    AtomSignedConfigReported = 123,
    AtomGnssNiEventReported = 124,
    AtomBluetoothLinkLayerConnectionEvent = 125,
    AtomBluetoothAclConnectionStateChanged = 126,
    AtomBluetoothScoConnectionStateChanged = 127,
    AtomAppDowngraded = 128,
    AtomAppOptimizedAfterDowngraded = 129,
    AtomLowStorageStateChanged = 130,
    AtomGnssNfwNotificationReported = 131,
    AtomGnssConfigurationReported = 132,
    AtomUsbPortOverheatEventReported = 133,
    AtomNfcErrorOccurred = 134,
    AtomNfcStateChanged = 135,
    AtomNfcBeamOccurred = 136,
    AtomNfcCardemulationOccurred = 137,
    AtomNfcTagOccurred = 138,
    AtomNfcHceTransactionOccurred = 139,
    AtomSeStateChanged = 140,
    AtomSeOmapiReported = 141,
    AtomBroadcastDispatchLatencyReported = 142,
    AtomAttentionManagerServiceResultReported = 143,
    AtomAdbConnectionChanged = 144,
    AtomSpeechDspStatReported = 145,
    AtomUsbContaminantReported = 146,
    AtomWatchdogRollbackOccurred = 147,
    AtomBiometricSystemHealthIssueDetected = 148,
    AtomBubbleUiChanged = 149,
    AtomScheduledJobConstraintChanged = 150,
    AtomBluetoothActiveDeviceChanged = 151,
    AtomBluetoothA2dpPlaybackStateChanged = 152,
    AtomBluetoothA2dpCodecConfigChanged = 153,
    AtomBluetoothA2dpCodecCapabilityChanged = 154,
    AtomBluetoothA2dpAudioUnderrunReported = 155,
    AtomBluetoothA2dpAudioOverrunReported = 156,
    AtomBluetoothDeviceRssiReported = 157,
    AtomBluetoothDeviceFailedContactCounterReported = 158,
    AtomBluetoothDeviceTxPowerLevelReported = 159,
    AtomBluetoothHciTimeoutReported = 160,
    AtomBluetoothQualityReportReported = 161,
    AtomBluetoothDeviceInfoReported = 162,
    AtomBluetoothRemoteVersionInfoReported = 163,
    AtomBluetoothSdpAttributeReported = 164,
    AtomBluetoothBondStateChanged = 165,
    AtomBluetoothClassicPairingEventReported = 166,
    AtomBluetoothSmpPairingEventReported = 167,
    AtomScreenTimeoutExtensionReported = 168,
    AtomProcessStartTime = 169,
    AtomPermissionGrantRequestResultReported = 170,
    AtomBluetoothSocketConnectionStateChanged = 171,
    AtomDeviceIdentifierAccessDenied = 172,
    AtomBubbleDeveloperErrorReported = 173,
    AtomAssistGestureStageReported = 174,
    AtomAssistGestureFeedbackReported = 175,
    AtomAssistGestureProgressReported = 176,
    AtomTouchGestureClassified = 177,
    AtomHiddenApiUsed = 178,
    AtomStyleUiChanged = 179,
    AtomPrivacyIndicatorsInteracted = 180,
    AtomAppInstallOnExternalStorageReported = 181,
    AtomNetworkStackReported = 182,
    AtomAppMovedStorageReported = 183,
    AtomBiometricEnrolled = 184,
    AtomSystemServerWatchdogOccurred = 185,
    AtomTombStoneOccurred = 186,
    AtomBluetoothClassOfDeviceReported = 187,
    AtomIntelligenceEventReported = 188,
    AtomThermalThrottlingSeverityStateChanged = 189,
    AtomRoleRequestResultReported = 190,
    AtomMediametricsAudiopolicyReported = 191,
    AtomMediametricsAudiorecordReported = 192,
    AtomMediametricsAudiothreadReported = 193,
    AtomMediametricsAudiotrackReported = 194,
    AtomMediametricsCodecReported = 195,
    AtomMediametricsDrmWidevineReported = 196,
    AtomMediametricsExtractorReported = 197,
    AtomMediametricsMediadrmReported = 198,
    AtomMediametricsNuplayerReported = 199,
    AtomMediametricsRecorderReported = 200,
    AtomMediametricsDrmmanagerReported = 201,
    AtomCarPowerStateChanged = 203,
    AtomGarageModeInfo = 204,
    AtomTestAtomReported = 205,
    AtomContentCaptureCallerMismatchReported = 206,
    AtomContentCaptureServiceEvents = 207,
    AtomContentCaptureSessionEvents = 208,
    AtomContentCaptureFlushed = 209,
    AtomLocationManagerApiUsageReported = 210,
    AtomReviewPermissionsFragmentResultReported = 211,
    AtomRuntimePermissionsUpgradeResult = 212,
    AtomGrantPermissionsActivityButtonActions = 213,
    AtomLocationAccessCheckNotificationAction = 214,
    AtomAppPermissionFragmentActionReported = 215,
    AtomAppPermissionFragmentViewed = 216,
    AtomAppPermissionsFragmentViewed = 217,
    AtomPermissionAppsFragmentViewed = 218,
    AtomTextSelectionEvent = 219,
    AtomTextLinkifyEvent = 220,
    AtomConversationActionsEvent = 221,
    AtomLanguageDetectionEvent = 222,
    AtomExclusionRectStateChanged = 223,
    AtomBackGestureReportedReported = 224,
    AtomUpdateEngineUpdateAttemptReported = 225,
    AtomUpdateEngineSuccessfulUpdateReported = 226,
    AtomCameraActionEvent = 227,
    AtomAppCompatibilityChangeReported = 228,
    AtomPerfettoUploaded = 229,
    AtomVmsClientConnectionStateChanged = 230,
    AtomMediaProviderScanOccurred = 233,
    AtomMediaContentDeleted = 234,
    AtomMediaProviderPermissionRequested = 235,
    AtomMediaProviderSchemaChanged = 236,
    AtomMediaProviderIdleMaintenanceFinished = 237,
    AtomRebootEscrowRecoveryReported = 238,
    AtomBootTimeEventDurationReported = 239,
    AtomBootTimeEventElapsedTimeReported = 240,
    AtomBootTimeEventUtcTimeReported = 241,
    AtomBootTimeEventErrorCodeReported = 242,
    AtomUserspaceRebootReported = 243,
    AtomNotificationReported = 244,
    AtomNotificationPanelReported = 245,
    AtomNotificationChannelModified = 246,
    AtomIntegrityCheckResultReported = 247,
    AtomIntegrityRulesPushed = 248,
    AtomCbMessageReported = 249,
    AtomCbMessageError = 250,
    AtomWifiHealthStatReported = 251,
    AtomWifiFailureStatReported = 252,
    AtomWifiConnectionResultReported = 253,
    AtomAppFreezeChanged = 254,
    AtomSnapshotMergeReported = 255,
    AtomForegroundServiceAppOpSessionEnded = 256,
    AtomDisplayJankReported = 257,
    AtomAppStandbyBucketChanged = 258,
    AtomSharesheetStarted = 259,
    AtomRankingSelected = 260,
    AtomTvsettingsUiInteracted = 261,
    AtomLauncherSnapshot = 262,
    AtomPackageInstallerV2Reported = 263,
    AtomUserLifecycleJourneyReported = 264,
    AtomUserLifecycleEventOccurred = 265,
    AtomAccessibilityShortcutReported = 266,
    AtomAccessibilityServiceReported = 267,
    AtomDocsUiDragAndDropReported = 268,
    AtomAppUsageEventOccurred = 269,
    AtomAutoRevokeNotificationClicked = 270,
    AtomAutoRevokeFragmentAppViewed = 271,
    AtomAutoRevokedAppInteraction = 272,
    AtomAppPermissionGroupsFragmentAutoRevokeAction = 273,
    AtomEvsUsageStatsReported = 274,
    AtomAudioPowerUsageDataReported = 275,
    AtomTvTunerStateChanged = 276,
    AtomMediaoutputOpSwitchReported = 277,
    AtomCbMessageFiltered = 278,
    AtomTvTunerDvrStatus = 279,
    AtomTvCasSessionOpenStatus = 280,
    AtomAssistantInvocationReported = 281,
    AtomDisplayWakeReported = 282,
    AtomCarUserHalModifyUserRequestReported = 283,
    AtomCarUserHalModifyUserResponseReported = 284,
    AtomCarUserHalPostSwitchResponseReported = 285,
    AtomCarUserHalInitialUserInfoRequestReported = 286,
    AtomCarUserHalInitialUserInfoResponseReported = 287,
    AtomCarUserHalUserAssociationRequestReported = 288,
    AtomCarUserHalSetUserAssociationResponseReported = 289,
    AtomNetworkIpProvisioningReported = 290,
    AtomNetworkDhcpRenewReported = 291,
    AtomNetworkValidationReported = 292,
    AtomNetworkStackQuirkReported = 293,
    AtomMediametricsAudiorecorddeviceusageReported = 294,
    AtomMediametricsAudiothreaddeviceusageReported = 295,
    AtomMediametricsAudiotrackdeviceusageReported = 296,
    AtomMediametricsAudiodeviceconnectionReported = 297,
    AtomBlobCommitted = 298,
    AtomBlobLeased = 299,
    AtomBlobOpened = 300,
    AtomContactsProviderStatusReported = 301,
    AtomKeystoreKeyEventReported = 302,
    AtomNetworkTetheringReported = 303,
    AtomImeTouchReported = 304,
    AtomUiInteractionFrameInfoReported = 305,
    AtomUiActionLatencyReported = 306,
    AtomWifiDisconnectReported = 307,
    AtomWifiConnectionStateChanged = 308,
    AtomHdmiCecActiveSourceChanged = 309,
    AtomHdmiCecMessageReported = 310,
    AtomAirplaneMode = 311,
    AtomModemRestart = 312,
    AtomCarrierIdMismatchReported = 313,
    AtomCarrierIdTableUpdated = 314,
    AtomDataStallRecoveryReported = 315,
    AtomMediametricsMediaparserReported = 316,
    AtomTlsHandshakeReported = 317,
    AtomTextClassifierApiUsageReported = 318,
    AtomCarWatchdogKillStatsReported = 319,
    AtomMediametricsPlaybackReported = 320,
    AtomMediaNetworkInfoChanged = 321,
    AtomMediaPlaybackStateChanged = 322,
    AtomMediaPlaybackErrorReported = 323,
    AtomMediaPlaybackTrackChanged = 324,
    AtomWifiScanReported = 325,
    AtomWifiPnoScanReported = 326,
    AtomTifTuneChanged = 327,
    AtomAutoRotateReported = 328,
    AtomPerfettoTrigger = 329,
    AtomTranscodingData = 330,
    AtomImsServiceEntitlementUpdated = 331,
    AtomDeviceRotated = 333,
    AtomSimSpecificSettingsRestored = 334,
    AtomTextClassifierDownloadReported = 335,
    AtomPinStorageEvent = 336,
    AtomFaceDownReported = 337,
    AtomBluetoothHalCrashReasonReported = 338,
    AtomRebootEscrowPreparationReported = 339,
    AtomRebootEscrowLskfCaptureReported = 340,
    AtomRebootEscrowRebootReported = 341,
    AtomBinderLatencyReported = 342,
    AtomMediametricsAaudiostreamReported = 343,
    AtomMediaTranscodingSessionEnded = 344,
    AtomMagnificationUsageReported = 345,
    AtomMagnificationModeWithImeOnReported = 346,
    AtomAppSearchCallStatsReported = 347,
    AtomAppSearchPutDocumentStatsReported = 348,
    AtomDeviceControlChanged = 349,
    AtomDeviceStateChanged = 350,
    AtomInputdeviceRegistered = 351,
    AtomSmartspaceCardReported = 352,
    AtomAuthPromptAuthenticateInvoked = 353,
    AtomAuthManagerCanAuthenticateInvoked = 354,
    AtomAuthEnrollActionInvoked = 355,
    AtomAuthDeprecatedApiUsed = 356,
    AtomUnattendedRebootOccurred = 357,
    AtomLongRebootBlockingReported = 358,
    AtomLocationTimeZoneProviderStateChanged = 359,
    AtomFdtrackEventOccurred = 364,
    AtomTimeoutAutoExtendedReported = 365,
    AtomAlarmBatchDelivered = 367,
    AtomAlarmScheduled = 368,
    AtomCarWatchdogIoOveruseStatsReported = 369,
    AtomUserLevelHibernationStateChanged = 370,
    AtomAppSearchInitializeStatsReported = 371,
    AtomAppSearchQueryStatsReported = 372,
    AtomAppProcessDied = 373,
    AtomNetworkIpReachabilityMonitorReported = 374,
    AtomSlowInputEventReported = 375,
    AtomAnrOccurredProcessingStarted = 376,
    AtomAppSearchRemoveStatsReported = 377,
    AtomMediaCodecReported = 378,
    AtomPermissionUsageFragmentInteraction = 379,
    AtomPermissionDetailsInteraction = 380,
    AtomPrivacySensorToggleInteraction = 381,
    AtomPrivacyToggleDialogInteraction = 382,
    AtomAppSearchOptimizeStatsReported = 383,
    AtomNonA11yToolServiceWarningReport = 384,
    AtomAppSearchSetSchemaStatsReported = 385,
    AtomAppCompatStateChanged = 386,
    AtomSizeCompatRestartButtonEventReported = 387,
    AtomSplitscreenUiChanged = 388,
    AtomNetworkDnsHandshakeReported = 389,
    AtomBluetoothCodePathCounter = 390,
    AtomBluetoothLeBatchScanReportDelay = 392,
    AtomAccessibilityFloatingMenuUiChanged = 393,
    AtomNeuralnetworksCompilationCompleted = 394,
    AtomNeuralnetworksExecutionCompleted = 395,
    AtomNeuralnetworksCompilationFailed = 396,
    AtomNeuralnetworksExecutionFailed = 397,
    AtomContextHubBooted = 398,
    AtomContextHubRestarted = 399,
    AtomContextHubLoadedNanoappSnapshotReported = 400,
    AtomChreCodeDownloadTransacted = 401,
    AtomUwbSessionInited = 402,
    AtomUwbSessionClosed = 403,
    AtomUwbFirstRangingReceived = 404,
    AtomUwbRangingMeasurementReceived = 405,
    AtomTextClassifierDownloadWorkScheduled = 406,
    AtomTextClassifierDownloadWorkCompleted = 407,
    AtomClipboardCleared = 408,
    AtomVmCreationRequested = 409,
    AtomNearbyDeviceScanStateChanged = 410,
    AtomCameraCompatControlEventReported = 411,
    AtomApplicationLocalesChanged = 412,
    AtomMediametricsAudiotrackstatusReported = 413,
    AtomFoldStateDurationReported = 414,
    AtomLocationTimeZoneProviderControllerStateChanged = 415,
    AtomDisplayHbmStateChanged = 416,
    AtomDisplayHbmBrightnessChanged = 417,
    AtomPersistentUriPermissionsFlushed = 418,
    AtomEarlyBootCompOsArtifactsCheckReported = 419,
    AtomVbmetaDigestReported = 420,
    AtomApexInfoGathered = 421,
    AtomPvmInfoGathered = 422,
    AtomWearSettingsUiInteracted = 423,
    AtomTracingServiceReportEvent = 424,
    AtomMediametricsAudiorecordstatusReported = 425,
    AtomLauncherLatency = 426,
    AtomDropboxEntryDropped = 427,
    AtomWifiP2pConnectionReported = 428,
    AtomGameStateChanged = 429,
    AtomHotwordDetectorCreateRequested = 430,
    AtomHotwordDetectionServiceInitResultReported = 431,
    AtomHotwordDetectionServiceRestarted = 432,
    AtomHotwordDetectorKeyphraseTriggered = 433,
    AtomHotwordDetectorEvents = 434,
    AtomAdServicesApiCalled = 435,
    AtomAdServicesMesurementReportsUploaded = 436,
    AtomBootCompletedBroadcastCompletionLatencyReported = 437,
    AtomContactsIndexerUpdateStatsReported = 440,
    AtomAppBackgroundRestrictionsInfo = 441,
    AtomMmsSmsProviderGetThreadIdFailed = 442,
    AtomMmsSmsDatabaseHelperOnUpgradeFailed = 443,
    AtomPermissionReminderNotificationInteracted = 444,
    AtomRecentPermissionDecisionsInteracted = 445,
    AtomGnssPsdsDownloadReported = 446,
    AtomLeAudioConnectionSessionReported = 447,
    AtomLeAudioBroadcastSessionReported = 448,
    AtomDreamUiEventReported = 449,
    AtomTaskManagerEventReported = 450,
    AtomCdmAssociationAction = 451,
    AtomMagnificationTripleTapAndHoldActivatedSessionReported = 452,
    AtomMagnificationFollowTypingFocusActivatedSessionReported = 453,
    AtomAccessibilityTextReadingOptionsChanged = 454,
    AtomWifiSetupFailureCrashReported = 455,
    AtomUwbDeviceErrorReported = 456,
    AtomIsolatedCompilationScheduled = 457,
    AtomIsolatedCompilationEnded = 458,
    AtomOnsOpportunisticEsimProvisioningComplete = 459,
    AtomSystemServerPreWatchdogOccurred = 460,
    AtomTelephonyAnomalyDetected = 461,
    AtomLetterboxPositionChanged = 462,
    AtomRemoteKeyProvisioningAttempt = 463,
    AtomRemoteKeyProvisioningNetworkInfo = 464,
    AtomRemoteKeyProvisioningTiming = 465,
    AtomMediaoutputOpInteractionReport = 466,
    AtomSyncExemptionOccurred = 468,
    AtomAutofillPresentationEventReported = 469,
    AtomDockStateChanged = 470,
    AtomSafetySourceStateCollected = 471,
    AtomSafetyCenterSystemEventReported = 472,
    AtomSafetyCenterInteractionReported = 473,
    AtomSettingsProviderSettingChanged = 474,
    AtomBroadcastDeliveryEventReported = 475,
    AtomServiceRequestEventReported = 476,
    AtomProviderAcquisitionEventReported = 477,
    AtomBluetoothDeviceNameReported = 478,
    AtomCbConfigUpdated = 479,
    AtomCbModuleErrorReported = 480,
    AtomCbServiceFeatureChanged = 481,
    AtomCbReceiverFeatureChanged = 482,
    AtomJsscriptengineLatencyReported = 483,
    AtomPrivacySignalNotificationInteraction = 484,
    AtomPrivacySignalIssueCardInteraction = 485,
    AtomPrivacySignalsJobFailure = 486,
    AtomVibrationReported = 487,
    AtomUwbRangingStart = 489,
    AtomMobileDataDownloadFileGroupStatusReported = 490,
    AtomAppCompactedV2 = 491,
    AtomAdServicesSettingsUsageReported = 493,
    AtomDisplayBrightnessChanged = 494,
    AtomActivityActionBlocked = 495,
    AtomBackgroundFetchProcessReported = 496,
    AtomUpdateCustomAudienceProcessReported = 497,
    AtomRunAdBiddingProcessReported = 498,
    AtomRunAdScoringProcessReported = 499,
    AtomRunAdSelectionProcessReported = 500,
    AtomRunAdBiddingPerCaProcessReported = 501,
    AtomMobileDataDownloadDownloadResultReported = 502,
    AtomMobileDataDownloadFileGroupStorageStatsReported = 503,
    AtomNetworkDnsServerSupportReported = 504,
    AtomVmBooted = 505,
    AtomVmExited = 506,
    AtomAmbientBrightnessStatsReported = 507,
    AtomMediametricsSpatializercapabilitiesReported = 508,
    AtomMediametricsSpatializerdeviceenabledReported = 509,
    AtomMediametricsHeadtrackerdeviceenabledReported = 510,
    AtomMediametricsHeadtrackerdevicesupportedReported = 511,
    AtomAdServicesMeasurementRegistrations = 512,
    AtomHearingAidInfoReported = 513,
    AtomDeviceWideJobConstraintChanged = 514,
    AtomAmbientModeChanged = 515,
    AtomAnrLatencyReported = 516,
    AtomResourceApiInfo = 517,
    AtomSystemDefaultNetworkChanged = 518,
    AtomIwlanSetupDataCallResultReported = 519,
    AtomIwlanPdnDisconnectedReasonReported = 520,
    AtomAirplaneModeSessionReported = 521,
    AtomVmCpuStatusReported = 522,
    AtomVmMemStatusReported = 523,
    AtomPackageInstallationSessionReported = 524,
    AtomDefaultNetworkRematchInfo = 525,
    AtomNetworkSelectionPerformance = 526,
    AtomNetworkNsdReported = 527,
    AtomBluetoothDisconnectionReasonReported = 529,
    AtomBluetoothLocalVersionsReported = 530,
    AtomBluetoothRemoteSupportedFeaturesReported = 531,
    AtomBluetoothLocalSupportedFeaturesReported = 532,
    AtomBluetoothGattAppInfo = 533,
    AtomBrightnessConfigurationUpdated = 534,
    AtomAdServicesGetTopicsReported = 535,
    AtomAdServicesEpochComputationGetTopTopicsReported = 536,
    AtomAdServicesEpochComputationClassifierReported = 537,
    AtomWearMediaOutputSwitcherLaunched = 538,
    AtomWearMediaOutputSwitcherFinished = 539,
    AtomWearMediaOutputSwitcherConnectionReported = 540,
    AtomWearMediaOutputSwitcherDeviceScanTriggered = 541,
    AtomWearMediaOutputSwitcherFirstDeviceScanLatency = 542,
    AtomWearMediaOutputSwitcherConnectDeviceLatency = 543,
    AtomPackageManagerSnapshotReported = 544,
    AtomPackageManagerAppsFilterCacheBuildReported = 545,
    AtomPackageManagerAppsFilterCacheUpdateReported = 546,
    AtomLauncherImpressionEvent = 547,
    AtomWearMediaOutputSwitcherAllDevicesScanLatency = 549,
    AtomWsWatchFaceEdited = 551,
    AtomWsWatchFaceFavoriteActionReported = 552,
    AtomWsWatchFaceSetActionReported = 553,
    AtomPackageUninstallationReported = 554,
    AtomGameModeChanged = 555,
    AtomGameModeConfigurationChanged = 556,
    AtomBedtimeModeStateChanged = 557,
    AtomNetworkSliceSessionEnded = 558,
    AtomNetworkSliceDailyDataUsageReported = 559,
    AtomNfcTagTypeOccurred = 560,
    AtomNfcAidConflictOccurred = 561,
    AtomNfcReaderConflictOccurred = 562,
    AtomWsTileListChanged = 563,
    AtomGetTypeAccessedWithoutPermission = 564,
    AtomMobileBundledAppInfoGathered = 566,
    AtomWsWatchFaceComplicationSetChanged = 567,
    AtomMediaDrmCreated = 568,
    AtomMediaDrmErrored = 569,
    AtomMediaDrmSessionOpened = 570,
    AtomMediaDrmSessionClosed = 571,
    AtomUserSelectedResolution = 572,
    AtomUnsafeIntentEventReported = 573,
    AtomPerformanceHintSessionReported = 574,
    AtomMediametricsMidiDeviceCloseReported = 576,
    AtomBiometricTouchReported = 577,
    AtomHotwordAudioEgressEventReported = 578,
    AtomAppSearchSchemaMigrationStatsReported = 579,
    AtomLocationEnabledStateChanged = 580,
    AtomImeRequestFinished = 581,
    AtomUsbComplianceWarningsReported = 582,
    AtomAppSupportedLocalesChanged = 583,
    AtomGrammaticalInflectionChanged = 584,
    AtomMediaProviderVolumeRecoveryReported = 586,
    AtomBiometricPropertiesCollected = 587,
    AtomKernelWakeupAttributed = 588,
    AtomScreenStateChangedV2 = 589,
    AtomWsBackupActionReported = 590,
    AtomWsRestoreActionReported = 591,
    AtomDeviceLogAccessEventReported = 592,
    AtomMediaSessionUpdated = 594,
    AtomWearOobeStateChanged = 595,
    AtomWsNotificationUpdated = 596,
    AtomNetworkValidationFailureStatsDailyReported = 601,
    AtomWsComplicationTapped = 602,
    AtomWsWearTimeSession = 610,
    AtomWifiBytesTransfer = 10000,
    AtomWifiBytesTransferByFgBg = 10001,
    AtomMobileBytesTransfer = 10002,
    AtomMobileBytesTransferByFgBg = 10003,
    AtomBluetoothBytesTransfer = 10006,
    AtomKernelWakelock = 10004,
    AtomSubsystemSleepState = 10005,
    AtomCpuTimePerUid = 10009,
    AtomCpuTimePerUidFreq = 10010,
    AtomWifiActivityInfo = 10011,
    AtomModemActivityInfo = 10012,
    AtomBluetoothActivityInfo = 10007,
    AtomProcessMemoryState = 10013,
    AtomSystemElapsedRealtime = 10014,
    AtomSystemUptime = 10015,
    AtomCpuActiveTime = 10016,
    AtomCpuClusterTime = 10017,
    AtomDiskSpace = 10018,
    AtomRemainingBatteryCapacity = 10019,
    AtomFullBatteryCapacity = 10020,
    AtomTemperature = 10021,
    AtomBinderCalls = 10022,
    AtomBinderCallsExceptions = 10023,
    AtomLooperStats = 10024,
    AtomDiskStats = 10025,
    AtomDirectoryUsage = 10026,
    AtomAppSize = 10027,
    AtomCategorySize = 10028,
    AtomProcStats = 10029,
    AtomBatteryVoltage = 10030,
    AtomNumFingerprintsEnrolled = 10031,
    AtomDiskIo = 10032,
    AtomPowerProfile = 10033,
    AtomProcStatsPkgProc = 10034,
    AtomProcessCpuTime = 10035,
    AtomCpuTimePerThreadFreq = 10037,
    AtomOnDevicePowerMeasurement = 10038,
    AtomDeviceCalculatedPowerUse = 10039,
    AtomProcessMemoryHighWaterMark = 10042,
    AtomBatteryLevel = 10043,
    AtomBuildInformation = 10044,
    AtomBatteryCycleCount = 10045,
    AtomDebugElapsedClock = 10046,
    AtomDebugFailingElapsedClock = 10047,
    AtomNumFacesEnrolled = 10048,
    AtomRoleHolder = 10049,
    AtomDangerousPermissionState = 10050,
    AtomTrainInfo = 10051,
    AtomTimeZoneDataInfo = 10052,
    AtomExternalStorageInfo = 10053,
    AtomGpuStatsGlobalInfo = 10054,
    AtomGpuStatsAppInfo = 10055,
    AtomSystemIonHeapSize = 10056,
    AtomAppsOnExternalStorageInfo = 10057,
    AtomFaceSettings = 10058,
    AtomCoolingDevice = 10059,
    AtomAppOps = 10060,
    AtomProcessSystemIonHeapSize = 10061,
    AtomSurfaceflingerStatsGlobalInfo = 10062,
    AtomSurfaceflingerStatsLayerInfo = 10063,
    AtomProcessMemorySnapshot = 10064,
    AtomVmsClientStats = 10065,
    AtomNotificationRemoteViews = 10066,
    AtomDangerousPermissionStateSampled = 10067,
    AtomGraphicsStats = 10068,
    AtomRuntimeAppOpAccess = 10069,
    AtomIonHeapSize = 10070,
    AtomPackageNotificationPreferences = 10071,
    AtomPackageNotificationChannelPreferences = 10072,
    AtomPackageNotificationChannelGroupPreferences = 10073,
    AtomGnssStats = 10074,
    AtomAttributedAppOps = 10075,
    AtomVoiceCallSession = 10076,
    AtomVoiceCallRatUsage = 10077,
    AtomSimSlotState = 10078,
    AtomSupportedRadioAccessFamily = 10079,
    AtomSettingSnapshot = 10080,
    AtomBlobInfo = 10081,
    AtomDataUsageBytesTransfer = 10082,
    AtomBytesTransferByTagAndMetered = 10083,
    AtomDndModeRule = 10084,
    AtomGeneralExternalStorageAccessStats = 10085,
    AtomIncomingSms = 10086,
    AtomOutgoingSms = 10087,
    AtomCarrierIdTableVersion = 10088,
    AtomDataCallSession = 10089,
    AtomCellularServiceState = 10090,
    AtomCellularDataServiceSwitch = 10091,
    AtomSystemMemory = 10092,
    AtomImsRegistrationTermination = 10093,
    AtomImsRegistrationStats = 10094,
    AtomCpuTimePerClusterFreq = 10095,
    AtomCpuCyclesPerUidCluster = 10096,
    AtomDeviceRotatedData = 10097,
    AtomCpuCyclesPerThreadGroupCluster = 10098,
    AtomMediaDrmActivityInfo = 10099,
    AtomOemManagedBytesTransfer = 10100,
    AtomGnssPowerStats = 10101,
    AtomTimeZoneDetectorState = 10102,
    AtomKeystore2StorageStats = 10103,
    AtomRkpPoolStats = 10104,
    AtomProcessDmabufMemory = 10105,
    AtomPendingAlarmInfo = 10106,
    AtomUserLevelHibernatedApps = 10107,
    AtomLauncherLayoutSnapshot = 10108,
    AtomGlobalHibernatedApps = 10109,
    AtomInputEventLatencySketch = 10110,
    AtomBatteryUsageStatsBeforeReset = 10111,
    AtomBatteryUsageStatsSinceReset = 10112,
    AtomBatteryUsageStatsSinceResetUsingPowerProfileModel = 10113,
    AtomInstalledIncrementalPackage = 10114,
    AtomTelephonyNetworkRequests = 10115,
    AtomAppSearchStorageInfo = 10116,
    AtomVmstat = 10117,
    AtomKeystore2KeyCreationWithGeneralInfo = 10118,
    AtomKeystore2KeyCreationWithAuthInfo = 10119,
    AtomKeystore2KeyCreationWithPurposeAndModesInfo = 10120,
    AtomKeystore2AtomWithOverflow = 10121,
    AtomKeystore2KeyOperationWithPurposeAndModesInfo = 10122,
    AtomKeystore2KeyOperationWithGeneralInfo = 10123,
    AtomRkpErrorStats = 10124,
    AtomKeystore2CrashStats = 10125,
    AtomVendorApexInfo = 10126,
    AtomAccessibilityShortcutStats = 10127,
    AtomAccessibilityFloatingMenuStats = 10128,
    AtomDataUsageBytesTransferV2 = 10129,
    AtomMediaCapabilities = 10130,
    AtomCarWatchdogSystemIoUsageSummary = 10131,
    AtomCarWatchdogUidIoUsageSummary = 10132,
    AtomImsRegistrationFeatureTagStats = 10133,
    AtomRcsClientProvisioningStats = 10134,
    AtomRcsAcsProvisioningStats = 10135,
    AtomSipDelegateStats = 10136,
    AtomSipTransportFeatureTagStats = 10137,
    AtomSipMessageResponse = 10138,
    AtomSipTransportSession = 10139,
    AtomImsDedicatedBearerListenerEvent = 10140,
    AtomImsDedicatedBearerEvent = 10141,
    AtomImsRegistrationServiceDescStats = 10142,
    AtomUceEventStats = 10143,
    AtomPresenceNotifyEvent = 10144,
    AtomGbaEvent = 10145,
    AtomPerSimStatus = 10146,
    AtomGpuWorkPerUid = 10147,
    AtomPersistentUriPermissionsAmountPerPackage = 10148,
    AtomSignedPartitionInfo = 10149,
    AtomPinnedFileSizesPerPackage = 10150,
    AtomPendingIntentsPerPackage = 10151,
    AtomUserInfo = 10152,
    AtomTelephonyNetworkRequestsV2 = 10153,
    AtomDeviceTelephonyProperties = 10154,
    AtomRemoteKeyProvisioningErrorCounts = 10155,
    AtomSafetyState = 10156,
    AtomIncomingMms = 10157,
    AtomOutgoingMms = 10158,
    AtomMultiUserInfo = 10160,
    AtomNetworkBpfMapInfo = 10161,
    AtomOutgoingShortCodeSms = 10162,
    AtomConnectivityStateSample = 10163,
    AtomNetworkSelectionRematchReasonsInfo = 10164,
    AtomGameModeInfo = 10165,
    AtomGameModeConfiguration = 10166,
    AtomGameModeListener = 10167,
    AtomNetworkSliceRequestCount = 10168,
    AtomWsTileSnapshot = 10169,
    AtomWsActiveWatchFaceComplicationSetSnapshot = 10170,
    AtomProcessState = 10171,
    AtomProcessAssociation = 10172,
    AtomAdpfSystemComponentInfo = 10173,
    AtomNotificationMemoryUse = 10174,
    AtomHdrCapabilities = 10175,
    AtomWsFavouriteWatchFaceListSnapshot = 10176,
    AtomWifiAwareNdpReported = 638,
    AtomWifiAwareAttachReported = 639,
    AtomWifiSelfRecoveryTriggered = 661,
    AtomSoftApStarted = 680,
    AtomSoftApStopped = 681,
    AtomWifiLockReleased = 687,
    AtomWifiLockDeactivated = 688,
    AtomWifiConfigSaved = 689,
    AtomWifiAwareResourceUsingChanged = 690,
    AtomWifiAwareHalApiCalled = 691,
    AtomWifiLocalOnlyRequestReceived = 692,
    AtomWifiLocalOnlyRequestScanTriggered = 693,
    AtomWifiThreadTaskExecuted = 694,
    AtomWifiStateChanged = 700,
    AtomWifiAwareCapabilities = 10190,
    AtomWifiModuleInfo = 10193,
    AtomSettingsSpaReported = 622,
    AtomExpressEventReported = 528,
    AtomExpressHistogramSampleReported = 593,
    AtomExpressUidEventReported = 644,
    AtomExpressUidHistogramSampleReported = 658,
    AtomPermissionRationaleDialogViewed = 645,
    AtomPermissionRationaleDialogActionReported = 646,
    AtomAppDataSharingUpdatesNotificationInteraction = 647,
    AtomAppDataSharingUpdatesFragmentViewed = 648,
    AtomAppDataSharingUpdatesFragmentActionReported = 649,
    AtomWsIncomingCallActionReported = 626,
    AtomWsCallDisconnectionReported = 627,
    AtomWsCallDurationReported = 628,
    AtomWsCallUserExperienceLatencyReported = 629,
    AtomWsCallInteractionReported = 630,
    AtomFullScreenIntentLaunched = 631,
    AtomBalAllowed = 632,
    AtomInTaskActivityStarted = 685,
    AtomCachedAppsHighWatermark = 10189,
    AtomOdrefreshReported = 366,
    AtomOdsignReported = 548,
    AtomArtDatumReported = 332,
    AtomArtDeviceDatumReported = 550,
    AtomArtDatumDeltaReported = 565,
    AtomBackgroundDexoptJobEnded = 467,
    AtomWearAdaptiveSuspendStatsReported = 619,
    AtomWearPowerAnomalyServiceOperationalStatsReported = 620,
    AtomWearPowerAnomalyServiceEventStatsReported = 621,
    AtomEmergencyStateChanged = 633,
    AtomDndStateChanged = 657,
    AtomMteState = 10181,
    AtomAdServicesBackCompatGetTopicsReported = 598,
    AtomAdServicesBackCompatEpochComputationClassifierReported = 599,
    AtomAdServicesMeasurementDebugKeys = 640,
    AtomAdServicesErrorReported = 662,
    AtomAdServicesBackgroundJobsExecutionReported = 663,
    AtomAdServicesMeasurementDelayedSourceRegistration = 673,
    AtomAdServicesMeasurementAttribution = 674,
    AtomAdServicesMeasurementJobs = 675,
    AtomAdServicesMeasurementWipeout = 676,
    AtomAdServicesConsentMigrated = 702,
    AtomRkpdPoolStats = 664,
    AtomRkpdClientOperation = 665,
    AtomAutofillUiEventReported = 603,
    AtomAutofillFillRequestReported = 604,
    AtomAutofillFillResponseReported = 605,
    AtomAutofillSaveEventReported = 606,
    AtomAutofillSessionCommitted = 607,
    AtomAutofillFieldClassificationEventReported = 659,
    AtomTestExtensionAtomReported = 660,
    AtomTestRestrictedAtomReported = 672,
    AtomStatsSocketLossReported = 752,
    AtomPluginInitialized = 655,
    AtomTvLowPowerStandbyPolicy = 679,
    AtomLockscreenShortcutSelected = 611,
    AtomLockscreenShortcutTriggered = 612,
    AtomEmergencyNumbersInfo = 10180,
    AtomQualifiedRatListChanged = 634,
    AtomQnsImsCallDropStats = 635,
    AtomQnsFallbackRestrictionChanged = 636,
    AtomQnsRatPreferenceMismatchInfo = 10177,
    AtomQnsHandoverTimeMillis = 10178,
    AtomQnsHandoverPingpong = 10179,
    AtomSatelliteController = 10182,
    AtomSatelliteSession = 10183,
    AtomSatelliteIncomingDatagram = 10184,
    AtomSatelliteOutgoingDatagram = 10185,
    AtomSatelliteProvision = 10186,
    AtomSatelliteSosMessageRecommender = 10187,
    AtomIkeSessionTerminated = 678,
    AtomIkeLivenessCheckSessionValidated = 760,
    AtomBluetoothHashedDeviceNameReported = 613,
    AtomBluetoothL2capCocClientConnection = 614,
    AtomBluetoothL2capCocServerConnection = 615,
    AtomBluetoothLeSessionConnected = 656,
    AtomRestrictedBluetoothDeviceNameReported = 666,
    AtomBluetoothProfileConnectionAttempted = 696,
    AtomHealthConnectUiImpression = 623,
    AtomHealthConnectUiInteraction = 624,
    AtomHealthConnectAppOpenedReported = 625,
    AtomHealthConnectApiCalled = 616,
    AtomHealthConnectUsageStats = 617,
    AtomHealthConnectStorageStats = 618,
    AtomHealthConnectApiInvoked = 643,
    AtomExerciseRouteApiCalled = 654,
    AtomAtom9999 = 9999,
    AtomAtom99999 = 99999,
    AtomThreadnetworkTelemetryDataReported = 738,
    AtomThreadnetworkTopoEntryRepeated = 739,
    AtomThreadnetworkDeviceInfoReported = 740,
    AtomEmergencyNumberDialed = 637,
    AtomSandboxApiCalled = 488,
    AtomSandboxActivityEventOccurred = 735,
    AtomSandboxSdkStorage = 10159,
    AtomCronetEngineCreated = 703,
    AtomCronetTrafficReported = 704,
    AtomCronetEngineBuilderInitialized = 762,
    AtomCronetHttpFlagsInitialized = 763,
    AtomCronetInitialized = 764,
    AtomDailyKeepaliveInfoReported = 650,
    AtomIpClientRaInfoReported = 778,
    AtomApfSessionInfoReported = 777,
    AtomCredentialManagerApiCalled = 585,
    AtomCredentialManagerInitPhaseReported = 651,
    AtomCredentialManagerCandidatePhaseReported = 652,
    AtomCredentialManagerFinalPhaseReported = 653,
    AtomCredentialManagerTotalReported = 667,
    AtomCredentialManagerFinalnouidReported = 668,
    AtomCredentialManagerGetReported = 669,
    AtomCredentialManagerAuthClickReported = 670,
    AtomCredentialManagerApiv2Called = 671,
    AtomUwbActivityInfo = 10188,
    AtomMediaActionReported = 608,
    AtomMediaControlsLaunched = 609,
    AtomMediaCodecReclaimRequestCompleted = 600,
    AtomMediaCodecStarted = 641,
    AtomMediaCodecStopped = 642,
    AtomMediaCodecRendered = 684,
}
impl AtomId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AtomUnspecified => "ATOM_UNSPECIFIED",
            Self::AtomBleScanStateChanged => "ATOM_BLE_SCAN_STATE_CHANGED",
            Self::AtomProcessStateChanged => "ATOM_PROCESS_STATE_CHANGED",
            Self::AtomBleScanResultReceived => "ATOM_BLE_SCAN_RESULT_RECEIVED",
            Self::AtomSensorStateChanged => "ATOM_SENSOR_STATE_CHANGED",
            Self::AtomGpsScanStateChanged => "ATOM_GPS_SCAN_STATE_CHANGED",
            Self::AtomSyncStateChanged => "ATOM_SYNC_STATE_CHANGED",
            Self::AtomScheduledJobStateChanged => "ATOM_SCHEDULED_JOB_STATE_CHANGED",
            Self::AtomScreenBrightnessChanged => "ATOM_SCREEN_BRIGHTNESS_CHANGED",
            Self::AtomWakelockStateChanged => "ATOM_WAKELOCK_STATE_CHANGED",
            Self::AtomLongPartialWakelockStateChanged => {
                "ATOM_LONG_PARTIAL_WAKELOCK_STATE_CHANGED"
            }
            Self::AtomMobileRadioPowerStateChanged => {
                "ATOM_MOBILE_RADIO_POWER_STATE_CHANGED"
            }
            Self::AtomWifiRadioPowerStateChanged => "ATOM_WIFI_RADIO_POWER_STATE_CHANGED",
            Self::AtomActivityManagerSleepStateChanged => {
                "ATOM_ACTIVITY_MANAGER_SLEEP_STATE_CHANGED"
            }
            Self::AtomMemoryFactorStateChanged => "ATOM_MEMORY_FACTOR_STATE_CHANGED",
            Self::AtomExcessiveCpuUsageReported => "ATOM_EXCESSIVE_CPU_USAGE_REPORTED",
            Self::AtomCachedKillReported => "ATOM_CACHED_KILL_REPORTED",
            Self::AtomProcessMemoryStatReported => "ATOM_PROCESS_MEMORY_STAT_REPORTED",
            Self::AtomLauncherEvent => "ATOM_LAUNCHER_EVENT",
            Self::AtomBatterySaverModeStateChanged => {
                "ATOM_BATTERY_SAVER_MODE_STATE_CHANGED"
            }
            Self::AtomDeviceIdleModeStateChanged => "ATOM_DEVICE_IDLE_MODE_STATE_CHANGED",
            Self::AtomDeviceIdlingModeStateChanged => {
                "ATOM_DEVICE_IDLING_MODE_STATE_CHANGED"
            }
            Self::AtomAudioStateChanged => "ATOM_AUDIO_STATE_CHANGED",
            Self::AtomMediaCodecStateChanged => "ATOM_MEDIA_CODEC_STATE_CHANGED",
            Self::AtomCameraStateChanged => "ATOM_CAMERA_STATE_CHANGED",
            Self::AtomFlashlightStateChanged => "ATOM_FLASHLIGHT_STATE_CHANGED",
            Self::AtomUidProcessStateChanged => "ATOM_UID_PROCESS_STATE_CHANGED",
            Self::AtomProcessLifeCycleStateChanged => {
                "ATOM_PROCESS_LIFE_CYCLE_STATE_CHANGED"
            }
            Self::AtomScreenStateChanged => "ATOM_SCREEN_STATE_CHANGED",
            Self::AtomBatteryLevelChanged => "ATOM_BATTERY_LEVEL_CHANGED",
            Self::AtomChargingStateChanged => "ATOM_CHARGING_STATE_CHANGED",
            Self::AtomPluggedStateChanged => "ATOM_PLUGGED_STATE_CHANGED",
            Self::AtomInteractiveStateChanged => "ATOM_INTERACTIVE_STATE_CHANGED",
            Self::AtomTouchEventReported => "ATOM_TOUCH_EVENT_REPORTED",
            Self::AtomWakeupAlarmOccurred => "ATOM_WAKEUP_ALARM_OCCURRED",
            Self::AtomKernelWakeupReported => "ATOM_KERNEL_WAKEUP_REPORTED",
            Self::AtomWifiLockStateChanged => "ATOM_WIFI_LOCK_STATE_CHANGED",
            Self::AtomWifiSignalStrengthChanged => "ATOM_WIFI_SIGNAL_STRENGTH_CHANGED",
            Self::AtomWifiScanStateChanged => "ATOM_WIFI_SCAN_STATE_CHANGED",
            Self::AtomPhoneSignalStrengthChanged => "ATOM_PHONE_SIGNAL_STRENGTH_CHANGED",
            Self::AtomSettingChanged => "ATOM_SETTING_CHANGED",
            Self::AtomActivityForegroundStateChanged => {
                "ATOM_ACTIVITY_FOREGROUND_STATE_CHANGED"
            }
            Self::AtomIsolatedUidChanged => "ATOM_ISOLATED_UID_CHANGED",
            Self::AtomPacketWakeupOccurred => "ATOM_PACKET_WAKEUP_OCCURRED",
            Self::AtomWallClockTimeShifted => "ATOM_WALL_CLOCK_TIME_SHIFTED",
            Self::AtomAnomalyDetected => "ATOM_ANOMALY_DETECTED",
            Self::AtomAppBreadcrumbReported => "ATOM_APP_BREADCRUMB_REPORTED",
            Self::AtomAppStartOccurred => "ATOM_APP_START_OCCURRED",
            Self::AtomAppStartCanceled => "ATOM_APP_START_CANCELED",
            Self::AtomAppStartFullyDrawn => "ATOM_APP_START_FULLY_DRAWN",
            Self::AtomLmkKillOccurred => "ATOM_LMK_KILL_OCCURRED",
            Self::AtomPictureInPictureStateChanged => {
                "ATOM_PICTURE_IN_PICTURE_STATE_CHANGED"
            }
            Self::AtomWifiMulticastLockStateChanged => {
                "ATOM_WIFI_MULTICAST_LOCK_STATE_CHANGED"
            }
            Self::AtomLmkStateChanged => "ATOM_LMK_STATE_CHANGED",
            Self::AtomAppStartMemoryStateCaptured => {
                "ATOM_APP_START_MEMORY_STATE_CAPTURED"
            }
            Self::AtomShutdownSequenceReported => "ATOM_SHUTDOWN_SEQUENCE_REPORTED",
            Self::AtomBootSequenceReported => "ATOM_BOOT_SEQUENCE_REPORTED",
            Self::AtomDaveyOccurred => "ATOM_DAVEY_OCCURRED",
            Self::AtomOverlayStateChanged => "ATOM_OVERLAY_STATE_CHANGED",
            Self::AtomForegroundServiceStateChanged => {
                "ATOM_FOREGROUND_SERVICE_STATE_CHANGED"
            }
            Self::AtomCallStateChanged => "ATOM_CALL_STATE_CHANGED",
            Self::AtomKeyguardStateChanged => "ATOM_KEYGUARD_STATE_CHANGED",
            Self::AtomKeyguardBouncerStateChanged => {
                "ATOM_KEYGUARD_BOUNCER_STATE_CHANGED"
            }
            Self::AtomKeyguardBouncerPasswordEntered => {
                "ATOM_KEYGUARD_BOUNCER_PASSWORD_ENTERED"
            }
            Self::AtomAppDied => "ATOM_APP_DIED",
            Self::AtomResourceConfigurationChanged => {
                "ATOM_RESOURCE_CONFIGURATION_CHANGED"
            }
            Self::AtomBluetoothEnabledStateChanged => {
                "ATOM_BLUETOOTH_ENABLED_STATE_CHANGED"
            }
            Self::AtomBluetoothConnectionStateChanged => {
                "ATOM_BLUETOOTH_CONNECTION_STATE_CHANGED"
            }
            Self::AtomGpsSignalQualityChanged => "ATOM_GPS_SIGNAL_QUALITY_CHANGED",
            Self::AtomUsbConnectorStateChanged => "ATOM_USB_CONNECTOR_STATE_CHANGED",
            Self::AtomSpeakerImpedanceReported => "ATOM_SPEAKER_IMPEDANCE_REPORTED",
            Self::AtomHardwareFailed => "ATOM_HARDWARE_FAILED",
            Self::AtomPhysicalDropDetected => "ATOM_PHYSICAL_DROP_DETECTED",
            Self::AtomChargeCyclesReported => "ATOM_CHARGE_CYCLES_REPORTED",
            Self::AtomMobileConnectionStateChanged => {
                "ATOM_MOBILE_CONNECTION_STATE_CHANGED"
            }
            Self::AtomMobileRadioTechnologyChanged => {
                "ATOM_MOBILE_RADIO_TECHNOLOGY_CHANGED"
            }
            Self::AtomUsbDeviceAttached => "ATOM_USB_DEVICE_ATTACHED",
            Self::AtomAppCrashOccurred => "ATOM_APP_CRASH_OCCURRED",
            Self::AtomAnrOccurred => "ATOM_ANR_OCCURRED",
            Self::AtomWtfOccurred => "ATOM_WTF_OCCURRED",
            Self::AtomLowMemReported => "ATOM_LOW_MEM_REPORTED",
            Self::AtomGenericAtom => "ATOM_GENERIC_ATOM",
            Self::AtomVibratorStateChanged => "ATOM_VIBRATOR_STATE_CHANGED",
            Self::AtomDeferredJobStatsReported => "ATOM_DEFERRED_JOB_STATS_REPORTED",
            Self::AtomThermalThrottling => "ATOM_THERMAL_THROTTLING",
            Self::AtomBiometricAcquired => "ATOM_BIOMETRIC_ACQUIRED",
            Self::AtomBiometricAuthenticated => "ATOM_BIOMETRIC_AUTHENTICATED",
            Self::AtomBiometricErrorOccurred => "ATOM_BIOMETRIC_ERROR_OCCURRED",
            Self::AtomUiEventReported => "ATOM_UI_EVENT_REPORTED",
            Self::AtomBatteryHealthSnapshot => "ATOM_BATTERY_HEALTH_SNAPSHOT",
            Self::AtomSlowIo => "ATOM_SLOW_IO",
            Self::AtomBatteryCausedShutdown => "ATOM_BATTERY_CAUSED_SHUTDOWN",
            Self::AtomPhoneServiceStateChanged => "ATOM_PHONE_SERVICE_STATE_CHANGED",
            Self::AtomPhoneStateChanged => "ATOM_PHONE_STATE_CHANGED",
            Self::AtomUserRestrictionChanged => "ATOM_USER_RESTRICTION_CHANGED",
            Self::AtomSettingsUiChanged => "ATOM_SETTINGS_UI_CHANGED",
            Self::AtomConnectivityStateChanged => "ATOM_CONNECTIVITY_STATE_CHANGED",
            Self::AtomServiceStateChanged => "ATOM_SERVICE_STATE_CHANGED",
            Self::AtomServiceLaunchReported => "ATOM_SERVICE_LAUNCH_REPORTED",
            Self::AtomFlagFlipUpdateOccurred => "ATOM_FLAG_FLIP_UPDATE_OCCURRED",
            Self::AtomBinaryPushStateChanged => "ATOM_BINARY_PUSH_STATE_CHANGED",
            Self::AtomDevicePolicyEvent => "ATOM_DEVICE_POLICY_EVENT",
            Self::AtomDocsUiFileOpCanceled => "ATOM_DOCS_UI_FILE_OP_CANCELED",
            Self::AtomDocsUiFileOpCopyMoveModeReported => {
                "ATOM_DOCS_UI_FILE_OP_COPY_MOVE_MODE_REPORTED"
            }
            Self::AtomDocsUiFileOpFailure => "ATOM_DOCS_UI_FILE_OP_FAILURE",
            Self::AtomDocsUiProviderFileOp => "ATOM_DOCS_UI_PROVIDER_FILE_OP",
            Self::AtomDocsUiInvalidScopedAccessRequest => {
                "ATOM_DOCS_UI_INVALID_SCOPED_ACCESS_REQUEST"
            }
            Self::AtomDocsUiLaunchReported => "ATOM_DOCS_UI_LAUNCH_REPORTED",
            Self::AtomDocsUiRootVisited => "ATOM_DOCS_UI_ROOT_VISITED",
            Self::AtomDocsUiStartupMs => "ATOM_DOCS_UI_STARTUP_MS",
            Self::AtomDocsUiUserActionReported => "ATOM_DOCS_UI_USER_ACTION_REPORTED",
            Self::AtomWifiEnabledStateChanged => "ATOM_WIFI_ENABLED_STATE_CHANGED",
            Self::AtomWifiRunningStateChanged => "ATOM_WIFI_RUNNING_STATE_CHANGED",
            Self::AtomAppCompacted => "ATOM_APP_COMPACTED",
            Self::AtomNetworkDnsEventReported => "ATOM_NETWORK_DNS_EVENT_REPORTED",
            Self::AtomDocsUiPickerLaunchedFromReported => {
                "ATOM_DOCS_UI_PICKER_LAUNCHED_FROM_REPORTED"
            }
            Self::AtomDocsUiPickResultReported => "ATOM_DOCS_UI_PICK_RESULT_REPORTED",
            Self::AtomDocsUiSearchModeReported => "ATOM_DOCS_UI_SEARCH_MODE_REPORTED",
            Self::AtomDocsUiSearchTypeReported => "ATOM_DOCS_UI_SEARCH_TYPE_REPORTED",
            Self::AtomDataStallEvent => "ATOM_DATA_STALL_EVENT",
            Self::AtomRescuePartyResetReported => "ATOM_RESCUE_PARTY_RESET_REPORTED",
            Self::AtomSignedConfigReported => "ATOM_SIGNED_CONFIG_REPORTED",
            Self::AtomGnssNiEventReported => "ATOM_GNSS_NI_EVENT_REPORTED",
            Self::AtomBluetoothLinkLayerConnectionEvent => {
                "ATOM_BLUETOOTH_LINK_LAYER_CONNECTION_EVENT"
            }
            Self::AtomBluetoothAclConnectionStateChanged => {
                "ATOM_BLUETOOTH_ACL_CONNECTION_STATE_CHANGED"
            }
            Self::AtomBluetoothScoConnectionStateChanged => {
                "ATOM_BLUETOOTH_SCO_CONNECTION_STATE_CHANGED"
            }
            Self::AtomAppDowngraded => "ATOM_APP_DOWNGRADED",
            Self::AtomAppOptimizedAfterDowngraded => {
                "ATOM_APP_OPTIMIZED_AFTER_DOWNGRADED"
            }
            Self::AtomLowStorageStateChanged => "ATOM_LOW_STORAGE_STATE_CHANGED",
            Self::AtomGnssNfwNotificationReported => {
                "ATOM_GNSS_NFW_NOTIFICATION_REPORTED"
            }
            Self::AtomGnssConfigurationReported => "ATOM_GNSS_CONFIGURATION_REPORTED",
            Self::AtomUsbPortOverheatEventReported => {
                "ATOM_USB_PORT_OVERHEAT_EVENT_REPORTED"
            }
            Self::AtomNfcErrorOccurred => "ATOM_NFC_ERROR_OCCURRED",
            Self::AtomNfcStateChanged => "ATOM_NFC_STATE_CHANGED",
            Self::AtomNfcBeamOccurred => "ATOM_NFC_BEAM_OCCURRED",
            Self::AtomNfcCardemulationOccurred => "ATOM_NFC_CARDEMULATION_OCCURRED",
            Self::AtomNfcTagOccurred => "ATOM_NFC_TAG_OCCURRED",
            Self::AtomNfcHceTransactionOccurred => "ATOM_NFC_HCE_TRANSACTION_OCCURRED",
            Self::AtomSeStateChanged => "ATOM_SE_STATE_CHANGED",
            Self::AtomSeOmapiReported => "ATOM_SE_OMAPI_REPORTED",
            Self::AtomBroadcastDispatchLatencyReported => {
                "ATOM_BROADCAST_DISPATCH_LATENCY_REPORTED"
            }
            Self::AtomAttentionManagerServiceResultReported => {
                "ATOM_ATTENTION_MANAGER_SERVICE_RESULT_REPORTED"
            }
            Self::AtomAdbConnectionChanged => "ATOM_ADB_CONNECTION_CHANGED",
            Self::AtomSpeechDspStatReported => "ATOM_SPEECH_DSP_STAT_REPORTED",
            Self::AtomUsbContaminantReported => "ATOM_USB_CONTAMINANT_REPORTED",
            Self::AtomWatchdogRollbackOccurred => "ATOM_WATCHDOG_ROLLBACK_OCCURRED",
            Self::AtomBiometricSystemHealthIssueDetected => {
                "ATOM_BIOMETRIC_SYSTEM_HEALTH_ISSUE_DETECTED"
            }
            Self::AtomBubbleUiChanged => "ATOM_BUBBLE_UI_CHANGED",
            Self::AtomScheduledJobConstraintChanged => {
                "ATOM_SCHEDULED_JOB_CONSTRAINT_CHANGED"
            }
            Self::AtomBluetoothActiveDeviceChanged => {
                "ATOM_BLUETOOTH_ACTIVE_DEVICE_CHANGED"
            }
            Self::AtomBluetoothA2dpPlaybackStateChanged => {
                "ATOM_BLUETOOTH_A2DP_PLAYBACK_STATE_CHANGED"
            }
            Self::AtomBluetoothA2dpCodecConfigChanged => {
                "ATOM_BLUETOOTH_A2DP_CODEC_CONFIG_CHANGED"
            }
            Self::AtomBluetoothA2dpCodecCapabilityChanged => {
                "ATOM_BLUETOOTH_A2DP_CODEC_CAPABILITY_CHANGED"
            }
            Self::AtomBluetoothA2dpAudioUnderrunReported => {
                "ATOM_BLUETOOTH_A2DP_AUDIO_UNDERRUN_REPORTED"
            }
            Self::AtomBluetoothA2dpAudioOverrunReported => {
                "ATOM_BLUETOOTH_A2DP_AUDIO_OVERRUN_REPORTED"
            }
            Self::AtomBluetoothDeviceRssiReported => {
                "ATOM_BLUETOOTH_DEVICE_RSSI_REPORTED"
            }
            Self::AtomBluetoothDeviceFailedContactCounterReported => {
                "ATOM_BLUETOOTH_DEVICE_FAILED_CONTACT_COUNTER_REPORTED"
            }
            Self::AtomBluetoothDeviceTxPowerLevelReported => {
                "ATOM_BLUETOOTH_DEVICE_TX_POWER_LEVEL_REPORTED"
            }
            Self::AtomBluetoothHciTimeoutReported => {
                "ATOM_BLUETOOTH_HCI_TIMEOUT_REPORTED"
            }
            Self::AtomBluetoothQualityReportReported => {
                "ATOM_BLUETOOTH_QUALITY_REPORT_REPORTED"
            }
            Self::AtomBluetoothDeviceInfoReported => {
                "ATOM_BLUETOOTH_DEVICE_INFO_REPORTED"
            }
            Self::AtomBluetoothRemoteVersionInfoReported => {
                "ATOM_BLUETOOTH_REMOTE_VERSION_INFO_REPORTED"
            }
            Self::AtomBluetoothSdpAttributeReported => {
                "ATOM_BLUETOOTH_SDP_ATTRIBUTE_REPORTED"
            }
            Self::AtomBluetoothBondStateChanged => "ATOM_BLUETOOTH_BOND_STATE_CHANGED",
            Self::AtomBluetoothClassicPairingEventReported => {
                "ATOM_BLUETOOTH_CLASSIC_PAIRING_EVENT_REPORTED"
            }
            Self::AtomBluetoothSmpPairingEventReported => {
                "ATOM_BLUETOOTH_SMP_PAIRING_EVENT_REPORTED"
            }
            Self::AtomScreenTimeoutExtensionReported => {
                "ATOM_SCREEN_TIMEOUT_EXTENSION_REPORTED"
            }
            Self::AtomProcessStartTime => "ATOM_PROCESS_START_TIME",
            Self::AtomPermissionGrantRequestResultReported => {
                "ATOM_PERMISSION_GRANT_REQUEST_RESULT_REPORTED"
            }
            Self::AtomBluetoothSocketConnectionStateChanged => {
                "ATOM_BLUETOOTH_SOCKET_CONNECTION_STATE_CHANGED"
            }
            Self::AtomDeviceIdentifierAccessDenied => {
                "ATOM_DEVICE_IDENTIFIER_ACCESS_DENIED"
            }
            Self::AtomBubbleDeveloperErrorReported => {
                "ATOM_BUBBLE_DEVELOPER_ERROR_REPORTED"
            }
            Self::AtomAssistGestureStageReported => "ATOM_ASSIST_GESTURE_STAGE_REPORTED",
            Self::AtomAssistGestureFeedbackReported => {
                "ATOM_ASSIST_GESTURE_FEEDBACK_REPORTED"
            }
            Self::AtomAssistGestureProgressReported => {
                "ATOM_ASSIST_GESTURE_PROGRESS_REPORTED"
            }
            Self::AtomTouchGestureClassified => "ATOM_TOUCH_GESTURE_CLASSIFIED",
            Self::AtomHiddenApiUsed => "ATOM_HIDDEN_API_USED",
            Self::AtomStyleUiChanged => "ATOM_STYLE_UI_CHANGED",
            Self::AtomPrivacyIndicatorsInteracted => "ATOM_PRIVACY_INDICATORS_INTERACTED",
            Self::AtomAppInstallOnExternalStorageReported => {
                "ATOM_APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED"
            }
            Self::AtomNetworkStackReported => "ATOM_NETWORK_STACK_REPORTED",
            Self::AtomAppMovedStorageReported => "ATOM_APP_MOVED_STORAGE_REPORTED",
            Self::AtomBiometricEnrolled => "ATOM_BIOMETRIC_ENROLLED",
            Self::AtomSystemServerWatchdogOccurred => {
                "ATOM_SYSTEM_SERVER_WATCHDOG_OCCURRED"
            }
            Self::AtomTombStoneOccurred => "ATOM_TOMB_STONE_OCCURRED",
            Self::AtomBluetoothClassOfDeviceReported => {
                "ATOM_BLUETOOTH_CLASS_OF_DEVICE_REPORTED"
            }
            Self::AtomIntelligenceEventReported => "ATOM_INTELLIGENCE_EVENT_REPORTED",
            Self::AtomThermalThrottlingSeverityStateChanged => {
                "ATOM_THERMAL_THROTTLING_SEVERITY_STATE_CHANGED"
            }
            Self::AtomRoleRequestResultReported => "ATOM_ROLE_REQUEST_RESULT_REPORTED",
            Self::AtomMediametricsAudiopolicyReported => {
                "ATOM_MEDIAMETRICS_AUDIOPOLICY_REPORTED"
            }
            Self::AtomMediametricsAudiorecordReported => {
                "ATOM_MEDIAMETRICS_AUDIORECORD_REPORTED"
            }
            Self::AtomMediametricsAudiothreadReported => {
                "ATOM_MEDIAMETRICS_AUDIOTHREAD_REPORTED"
            }
            Self::AtomMediametricsAudiotrackReported => {
                "ATOM_MEDIAMETRICS_AUDIOTRACK_REPORTED"
            }
            Self::AtomMediametricsCodecReported => "ATOM_MEDIAMETRICS_CODEC_REPORTED",
            Self::AtomMediametricsDrmWidevineReported => {
                "ATOM_MEDIAMETRICS_DRM_WIDEVINE_REPORTED"
            }
            Self::AtomMediametricsExtractorReported => {
                "ATOM_MEDIAMETRICS_EXTRACTOR_REPORTED"
            }
            Self::AtomMediametricsMediadrmReported => {
                "ATOM_MEDIAMETRICS_MEDIADRM_REPORTED"
            }
            Self::AtomMediametricsNuplayerReported => {
                "ATOM_MEDIAMETRICS_NUPLAYER_REPORTED"
            }
            Self::AtomMediametricsRecorderReported => {
                "ATOM_MEDIAMETRICS_RECORDER_REPORTED"
            }
            Self::AtomMediametricsDrmmanagerReported => {
                "ATOM_MEDIAMETRICS_DRMMANAGER_REPORTED"
            }
            Self::AtomCarPowerStateChanged => "ATOM_CAR_POWER_STATE_CHANGED",
            Self::AtomGarageModeInfo => "ATOM_GARAGE_MODE_INFO",
            Self::AtomTestAtomReported => "ATOM_TEST_ATOM_REPORTED",
            Self::AtomContentCaptureCallerMismatchReported => {
                "ATOM_CONTENT_CAPTURE_CALLER_MISMATCH_REPORTED"
            }
            Self::AtomContentCaptureServiceEvents => {
                "ATOM_CONTENT_CAPTURE_SERVICE_EVENTS"
            }
            Self::AtomContentCaptureSessionEvents => {
                "ATOM_CONTENT_CAPTURE_SESSION_EVENTS"
            }
            Self::AtomContentCaptureFlushed => "ATOM_CONTENT_CAPTURE_FLUSHED",
            Self::AtomLocationManagerApiUsageReported => {
                "ATOM_LOCATION_MANAGER_API_USAGE_REPORTED"
            }
            Self::AtomReviewPermissionsFragmentResultReported => {
                "ATOM_REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED"
            }
            Self::AtomRuntimePermissionsUpgradeResult => {
                "ATOM_RUNTIME_PERMISSIONS_UPGRADE_RESULT"
            }
            Self::AtomGrantPermissionsActivityButtonActions => {
                "ATOM_GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS"
            }
            Self::AtomLocationAccessCheckNotificationAction => {
                "ATOM_LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION"
            }
            Self::AtomAppPermissionFragmentActionReported => {
                "ATOM_APP_PERMISSION_FRAGMENT_ACTION_REPORTED"
            }
            Self::AtomAppPermissionFragmentViewed => {
                "ATOM_APP_PERMISSION_FRAGMENT_VIEWED"
            }
            Self::AtomAppPermissionsFragmentViewed => {
                "ATOM_APP_PERMISSIONS_FRAGMENT_VIEWED"
            }
            Self::AtomPermissionAppsFragmentViewed => {
                "ATOM_PERMISSION_APPS_FRAGMENT_VIEWED"
            }
            Self::AtomTextSelectionEvent => "ATOM_TEXT_SELECTION_EVENT",
            Self::AtomTextLinkifyEvent => "ATOM_TEXT_LINKIFY_EVENT",
            Self::AtomConversationActionsEvent => "ATOM_CONVERSATION_ACTIONS_EVENT",
            Self::AtomLanguageDetectionEvent => "ATOM_LANGUAGE_DETECTION_EVENT",
            Self::AtomExclusionRectStateChanged => "ATOM_EXCLUSION_RECT_STATE_CHANGED",
            Self::AtomBackGestureReportedReported => {
                "ATOM_BACK_GESTURE_REPORTED_REPORTED"
            }
            Self::AtomUpdateEngineUpdateAttemptReported => {
                "ATOM_UPDATE_ENGINE_UPDATE_ATTEMPT_REPORTED"
            }
            Self::AtomUpdateEngineSuccessfulUpdateReported => {
                "ATOM_UPDATE_ENGINE_SUCCESSFUL_UPDATE_REPORTED"
            }
            Self::AtomCameraActionEvent => "ATOM_CAMERA_ACTION_EVENT",
            Self::AtomAppCompatibilityChangeReported => {
                "ATOM_APP_COMPATIBILITY_CHANGE_REPORTED"
            }
            Self::AtomPerfettoUploaded => "ATOM_PERFETTO_UPLOADED",
            Self::AtomVmsClientConnectionStateChanged => {
                "ATOM_VMS_CLIENT_CONNECTION_STATE_CHANGED"
            }
            Self::AtomMediaProviderScanOccurred => "ATOM_MEDIA_PROVIDER_SCAN_OCCURRED",
            Self::AtomMediaContentDeleted => "ATOM_MEDIA_CONTENT_DELETED",
            Self::AtomMediaProviderPermissionRequested => {
                "ATOM_MEDIA_PROVIDER_PERMISSION_REQUESTED"
            }
            Self::AtomMediaProviderSchemaChanged => "ATOM_MEDIA_PROVIDER_SCHEMA_CHANGED",
            Self::AtomMediaProviderIdleMaintenanceFinished => {
                "ATOM_MEDIA_PROVIDER_IDLE_MAINTENANCE_FINISHED"
            }
            Self::AtomRebootEscrowRecoveryReported => {
                "ATOM_REBOOT_ESCROW_RECOVERY_REPORTED"
            }
            Self::AtomBootTimeEventDurationReported => {
                "ATOM_BOOT_TIME_EVENT_DURATION_REPORTED"
            }
            Self::AtomBootTimeEventElapsedTimeReported => {
                "ATOM_BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED"
            }
            Self::AtomBootTimeEventUtcTimeReported => {
                "ATOM_BOOT_TIME_EVENT_UTC_TIME_REPORTED"
            }
            Self::AtomBootTimeEventErrorCodeReported => {
                "ATOM_BOOT_TIME_EVENT_ERROR_CODE_REPORTED"
            }
            Self::AtomUserspaceRebootReported => "ATOM_USERSPACE_REBOOT_REPORTED",
            Self::AtomNotificationReported => "ATOM_NOTIFICATION_REPORTED",
            Self::AtomNotificationPanelReported => "ATOM_NOTIFICATION_PANEL_REPORTED",
            Self::AtomNotificationChannelModified => "ATOM_NOTIFICATION_CHANNEL_MODIFIED",
            Self::AtomIntegrityCheckResultReported => {
                "ATOM_INTEGRITY_CHECK_RESULT_REPORTED"
            }
            Self::AtomIntegrityRulesPushed => "ATOM_INTEGRITY_RULES_PUSHED",
            Self::AtomCbMessageReported => "ATOM_CB_MESSAGE_REPORTED",
            Self::AtomCbMessageError => "ATOM_CB_MESSAGE_ERROR",
            Self::AtomWifiHealthStatReported => "ATOM_WIFI_HEALTH_STAT_REPORTED",
            Self::AtomWifiFailureStatReported => "ATOM_WIFI_FAILURE_STAT_REPORTED",
            Self::AtomWifiConnectionResultReported => {
                "ATOM_WIFI_CONNECTION_RESULT_REPORTED"
            }
            Self::AtomAppFreezeChanged => "ATOM_APP_FREEZE_CHANGED",
            Self::AtomSnapshotMergeReported => "ATOM_SNAPSHOT_MERGE_REPORTED",
            Self::AtomForegroundServiceAppOpSessionEnded => {
                "ATOM_FOREGROUND_SERVICE_APP_OP_SESSION_ENDED"
            }
            Self::AtomDisplayJankReported => "ATOM_DISPLAY_JANK_REPORTED",
            Self::AtomAppStandbyBucketChanged => "ATOM_APP_STANDBY_BUCKET_CHANGED",
            Self::AtomSharesheetStarted => "ATOM_SHARESHEET_STARTED",
            Self::AtomRankingSelected => "ATOM_RANKING_SELECTED",
            Self::AtomTvsettingsUiInteracted => "ATOM_TVSETTINGS_UI_INTERACTED",
            Self::AtomLauncherSnapshot => "ATOM_LAUNCHER_SNAPSHOT",
            Self::AtomPackageInstallerV2Reported => "ATOM_PACKAGE_INSTALLER_V2_REPORTED",
            Self::AtomUserLifecycleJourneyReported => {
                "ATOM_USER_LIFECYCLE_JOURNEY_REPORTED"
            }
            Self::AtomUserLifecycleEventOccurred => "ATOM_USER_LIFECYCLE_EVENT_OCCURRED",
            Self::AtomAccessibilityShortcutReported => {
                "ATOM_ACCESSIBILITY_SHORTCUT_REPORTED"
            }
            Self::AtomAccessibilityServiceReported => {
                "ATOM_ACCESSIBILITY_SERVICE_REPORTED"
            }
            Self::AtomDocsUiDragAndDropReported => "ATOM_DOCS_UI_DRAG_AND_DROP_REPORTED",
            Self::AtomAppUsageEventOccurred => "ATOM_APP_USAGE_EVENT_OCCURRED",
            Self::AtomAutoRevokeNotificationClicked => {
                "ATOM_AUTO_REVOKE_NOTIFICATION_CLICKED"
            }
            Self::AtomAutoRevokeFragmentAppViewed => {
                "ATOM_AUTO_REVOKE_FRAGMENT_APP_VIEWED"
            }
            Self::AtomAutoRevokedAppInteraction => "ATOM_AUTO_REVOKED_APP_INTERACTION",
            Self::AtomAppPermissionGroupsFragmentAutoRevokeAction => {
                "ATOM_APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION"
            }
            Self::AtomEvsUsageStatsReported => "ATOM_EVS_USAGE_STATS_REPORTED",
            Self::AtomAudioPowerUsageDataReported => {
                "ATOM_AUDIO_POWER_USAGE_DATA_REPORTED"
            }
            Self::AtomTvTunerStateChanged => "ATOM_TV_TUNER_STATE_CHANGED",
            Self::AtomMediaoutputOpSwitchReported => {
                "ATOM_MEDIAOUTPUT_OP_SWITCH_REPORTED"
            }
            Self::AtomCbMessageFiltered => "ATOM_CB_MESSAGE_FILTERED",
            Self::AtomTvTunerDvrStatus => "ATOM_TV_TUNER_DVR_STATUS",
            Self::AtomTvCasSessionOpenStatus => "ATOM_TV_CAS_SESSION_OPEN_STATUS",
            Self::AtomAssistantInvocationReported => "ATOM_ASSISTANT_INVOCATION_REPORTED",
            Self::AtomDisplayWakeReported => "ATOM_DISPLAY_WAKE_REPORTED",
            Self::AtomCarUserHalModifyUserRequestReported => {
                "ATOM_CAR_USER_HAL_MODIFY_USER_REQUEST_REPORTED"
            }
            Self::AtomCarUserHalModifyUserResponseReported => {
                "ATOM_CAR_USER_HAL_MODIFY_USER_RESPONSE_REPORTED"
            }
            Self::AtomCarUserHalPostSwitchResponseReported => {
                "ATOM_CAR_USER_HAL_POST_SWITCH_RESPONSE_REPORTED"
            }
            Self::AtomCarUserHalInitialUserInfoRequestReported => {
                "ATOM_CAR_USER_HAL_INITIAL_USER_INFO_REQUEST_REPORTED"
            }
            Self::AtomCarUserHalInitialUserInfoResponseReported => {
                "ATOM_CAR_USER_HAL_INITIAL_USER_INFO_RESPONSE_REPORTED"
            }
            Self::AtomCarUserHalUserAssociationRequestReported => {
                "ATOM_CAR_USER_HAL_USER_ASSOCIATION_REQUEST_REPORTED"
            }
            Self::AtomCarUserHalSetUserAssociationResponseReported => {
                "ATOM_CAR_USER_HAL_SET_USER_ASSOCIATION_RESPONSE_REPORTED"
            }
            Self::AtomNetworkIpProvisioningReported => {
                "ATOM_NETWORK_IP_PROVISIONING_REPORTED"
            }
            Self::AtomNetworkDhcpRenewReported => "ATOM_NETWORK_DHCP_RENEW_REPORTED",
            Self::AtomNetworkValidationReported => "ATOM_NETWORK_VALIDATION_REPORTED",
            Self::AtomNetworkStackQuirkReported => "ATOM_NETWORK_STACK_QUIRK_REPORTED",
            Self::AtomMediametricsAudiorecorddeviceusageReported => {
                "ATOM_MEDIAMETRICS_AUDIORECORDDEVICEUSAGE_REPORTED"
            }
            Self::AtomMediametricsAudiothreaddeviceusageReported => {
                "ATOM_MEDIAMETRICS_AUDIOTHREADDEVICEUSAGE_REPORTED"
            }
            Self::AtomMediametricsAudiotrackdeviceusageReported => {
                "ATOM_MEDIAMETRICS_AUDIOTRACKDEVICEUSAGE_REPORTED"
            }
            Self::AtomMediametricsAudiodeviceconnectionReported => {
                "ATOM_MEDIAMETRICS_AUDIODEVICECONNECTION_REPORTED"
            }
            Self::AtomBlobCommitted => "ATOM_BLOB_COMMITTED",
            Self::AtomBlobLeased => "ATOM_BLOB_LEASED",
            Self::AtomBlobOpened => "ATOM_BLOB_OPENED",
            Self::AtomContactsProviderStatusReported => {
                "ATOM_CONTACTS_PROVIDER_STATUS_REPORTED"
            }
            Self::AtomKeystoreKeyEventReported => "ATOM_KEYSTORE_KEY_EVENT_REPORTED",
            Self::AtomNetworkTetheringReported => "ATOM_NETWORK_TETHERING_REPORTED",
            Self::AtomImeTouchReported => "ATOM_IME_TOUCH_REPORTED",
            Self::AtomUiInteractionFrameInfoReported => {
                "ATOM_UI_INTERACTION_FRAME_INFO_REPORTED"
            }
            Self::AtomUiActionLatencyReported => "ATOM_UI_ACTION_LATENCY_REPORTED",
            Self::AtomWifiDisconnectReported => "ATOM_WIFI_DISCONNECT_REPORTED",
            Self::AtomWifiConnectionStateChanged => "ATOM_WIFI_CONNECTION_STATE_CHANGED",
            Self::AtomHdmiCecActiveSourceChanged => "ATOM_HDMI_CEC_ACTIVE_SOURCE_CHANGED",
            Self::AtomHdmiCecMessageReported => "ATOM_HDMI_CEC_MESSAGE_REPORTED",
            Self::AtomAirplaneMode => "ATOM_AIRPLANE_MODE",
            Self::AtomModemRestart => "ATOM_MODEM_RESTART",
            Self::AtomCarrierIdMismatchReported => "ATOM_CARRIER_ID_MISMATCH_REPORTED",
            Self::AtomCarrierIdTableUpdated => "ATOM_CARRIER_ID_TABLE_UPDATED",
            Self::AtomDataStallRecoveryReported => "ATOM_DATA_STALL_RECOVERY_REPORTED",
            Self::AtomMediametricsMediaparserReported => {
                "ATOM_MEDIAMETRICS_MEDIAPARSER_REPORTED"
            }
            Self::AtomTlsHandshakeReported => "ATOM_TLS_HANDSHAKE_REPORTED",
            Self::AtomTextClassifierApiUsageReported => {
                "ATOM_TEXT_CLASSIFIER_API_USAGE_REPORTED"
            }
            Self::AtomCarWatchdogKillStatsReported => {
                "ATOM_CAR_WATCHDOG_KILL_STATS_REPORTED"
            }
            Self::AtomMediametricsPlaybackReported => {
                "ATOM_MEDIAMETRICS_PLAYBACK_REPORTED"
            }
            Self::AtomMediaNetworkInfoChanged => "ATOM_MEDIA_NETWORK_INFO_CHANGED",
            Self::AtomMediaPlaybackStateChanged => "ATOM_MEDIA_PLAYBACK_STATE_CHANGED",
            Self::AtomMediaPlaybackErrorReported => "ATOM_MEDIA_PLAYBACK_ERROR_REPORTED",
            Self::AtomMediaPlaybackTrackChanged => "ATOM_MEDIA_PLAYBACK_TRACK_CHANGED",
            Self::AtomWifiScanReported => "ATOM_WIFI_SCAN_REPORTED",
            Self::AtomWifiPnoScanReported => "ATOM_WIFI_PNO_SCAN_REPORTED",
            Self::AtomTifTuneChanged => "ATOM_TIF_TUNE_CHANGED",
            Self::AtomAutoRotateReported => "ATOM_AUTO_ROTATE_REPORTED",
            Self::AtomPerfettoTrigger => "ATOM_PERFETTO_TRIGGER",
            Self::AtomTranscodingData => "ATOM_TRANSCODING_DATA",
            Self::AtomImsServiceEntitlementUpdated => {
                "ATOM_IMS_SERVICE_ENTITLEMENT_UPDATED"
            }
            Self::AtomDeviceRotated => "ATOM_DEVICE_ROTATED",
            Self::AtomSimSpecificSettingsRestored => {
                "ATOM_SIM_SPECIFIC_SETTINGS_RESTORED"
            }
            Self::AtomTextClassifierDownloadReported => {
                "ATOM_TEXT_CLASSIFIER_DOWNLOAD_REPORTED"
            }
            Self::AtomPinStorageEvent => "ATOM_PIN_STORAGE_EVENT",
            Self::AtomFaceDownReported => "ATOM_FACE_DOWN_REPORTED",
            Self::AtomBluetoothHalCrashReasonReported => {
                "ATOM_BLUETOOTH_HAL_CRASH_REASON_REPORTED"
            }
            Self::AtomRebootEscrowPreparationReported => {
                "ATOM_REBOOT_ESCROW_PREPARATION_REPORTED"
            }
            Self::AtomRebootEscrowLskfCaptureReported => {
                "ATOM_REBOOT_ESCROW_LSKF_CAPTURE_REPORTED"
            }
            Self::AtomRebootEscrowRebootReported => "ATOM_REBOOT_ESCROW_REBOOT_REPORTED",
            Self::AtomBinderLatencyReported => "ATOM_BINDER_LATENCY_REPORTED",
            Self::AtomMediametricsAaudiostreamReported => {
                "ATOM_MEDIAMETRICS_AAUDIOSTREAM_REPORTED"
            }
            Self::AtomMediaTranscodingSessionEnded => {
                "ATOM_MEDIA_TRANSCODING_SESSION_ENDED"
            }
            Self::AtomMagnificationUsageReported => "ATOM_MAGNIFICATION_USAGE_REPORTED",
            Self::AtomMagnificationModeWithImeOnReported => {
                "ATOM_MAGNIFICATION_MODE_WITH_IME_ON_REPORTED"
            }
            Self::AtomAppSearchCallStatsReported => "ATOM_APP_SEARCH_CALL_STATS_REPORTED",
            Self::AtomAppSearchPutDocumentStatsReported => {
                "ATOM_APP_SEARCH_PUT_DOCUMENT_STATS_REPORTED"
            }
            Self::AtomDeviceControlChanged => "ATOM_DEVICE_CONTROL_CHANGED",
            Self::AtomDeviceStateChanged => "ATOM_DEVICE_STATE_CHANGED",
            Self::AtomInputdeviceRegistered => "ATOM_INPUTDEVICE_REGISTERED",
            Self::AtomSmartspaceCardReported => "ATOM_SMARTSPACE_CARD_REPORTED",
            Self::AtomAuthPromptAuthenticateInvoked => {
                "ATOM_AUTH_PROMPT_AUTHENTICATE_INVOKED"
            }
            Self::AtomAuthManagerCanAuthenticateInvoked => {
                "ATOM_AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED"
            }
            Self::AtomAuthEnrollActionInvoked => "ATOM_AUTH_ENROLL_ACTION_INVOKED",
            Self::AtomAuthDeprecatedApiUsed => "ATOM_AUTH_DEPRECATED_API_USED",
            Self::AtomUnattendedRebootOccurred => "ATOM_UNATTENDED_REBOOT_OCCURRED",
            Self::AtomLongRebootBlockingReported => "ATOM_LONG_REBOOT_BLOCKING_REPORTED",
            Self::AtomLocationTimeZoneProviderStateChanged => {
                "ATOM_LOCATION_TIME_ZONE_PROVIDER_STATE_CHANGED"
            }
            Self::AtomFdtrackEventOccurred => "ATOM_FDTRACK_EVENT_OCCURRED",
            Self::AtomTimeoutAutoExtendedReported => {
                "ATOM_TIMEOUT_AUTO_EXTENDED_REPORTED"
            }
            Self::AtomAlarmBatchDelivered => "ATOM_ALARM_BATCH_DELIVERED",
            Self::AtomAlarmScheduled => "ATOM_ALARM_SCHEDULED",
            Self::AtomCarWatchdogIoOveruseStatsReported => {
                "ATOM_CAR_WATCHDOG_IO_OVERUSE_STATS_REPORTED"
            }
            Self::AtomUserLevelHibernationStateChanged => {
                "ATOM_USER_LEVEL_HIBERNATION_STATE_CHANGED"
            }
            Self::AtomAppSearchInitializeStatsReported => {
                "ATOM_APP_SEARCH_INITIALIZE_STATS_REPORTED"
            }
            Self::AtomAppSearchQueryStatsReported => {
                "ATOM_APP_SEARCH_QUERY_STATS_REPORTED"
            }
            Self::AtomAppProcessDied => "ATOM_APP_PROCESS_DIED",
            Self::AtomNetworkIpReachabilityMonitorReported => {
                "ATOM_NETWORK_IP_REACHABILITY_MONITOR_REPORTED"
            }
            Self::AtomSlowInputEventReported => "ATOM_SLOW_INPUT_EVENT_REPORTED",
            Self::AtomAnrOccurredProcessingStarted => {
                "ATOM_ANR_OCCURRED_PROCESSING_STARTED"
            }
            Self::AtomAppSearchRemoveStatsReported => {
                "ATOM_APP_SEARCH_REMOVE_STATS_REPORTED"
            }
            Self::AtomMediaCodecReported => "ATOM_MEDIA_CODEC_REPORTED",
            Self::AtomPermissionUsageFragmentInteraction => {
                "ATOM_PERMISSION_USAGE_FRAGMENT_INTERACTION"
            }
            Self::AtomPermissionDetailsInteraction => {
                "ATOM_PERMISSION_DETAILS_INTERACTION"
            }
            Self::AtomPrivacySensorToggleInteraction => {
                "ATOM_PRIVACY_SENSOR_TOGGLE_INTERACTION"
            }
            Self::AtomPrivacyToggleDialogInteraction => {
                "ATOM_PRIVACY_TOGGLE_DIALOG_INTERACTION"
            }
            Self::AtomAppSearchOptimizeStatsReported => {
                "ATOM_APP_SEARCH_OPTIMIZE_STATS_REPORTED"
            }
            Self::AtomNonA11yToolServiceWarningReport => {
                "ATOM_NON_A11Y_TOOL_SERVICE_WARNING_REPORT"
            }
            Self::AtomAppSearchSetSchemaStatsReported => {
                "ATOM_APP_SEARCH_SET_SCHEMA_STATS_REPORTED"
            }
            Self::AtomAppCompatStateChanged => "ATOM_APP_COMPAT_STATE_CHANGED",
            Self::AtomSizeCompatRestartButtonEventReported => {
                "ATOM_SIZE_COMPAT_RESTART_BUTTON_EVENT_REPORTED"
            }
            Self::AtomSplitscreenUiChanged => "ATOM_SPLITSCREEN_UI_CHANGED",
            Self::AtomNetworkDnsHandshakeReported => {
                "ATOM_NETWORK_DNS_HANDSHAKE_REPORTED"
            }
            Self::AtomBluetoothCodePathCounter => "ATOM_BLUETOOTH_CODE_PATH_COUNTER",
            Self::AtomBluetoothLeBatchScanReportDelay => {
                "ATOM_BLUETOOTH_LE_BATCH_SCAN_REPORT_DELAY"
            }
            Self::AtomAccessibilityFloatingMenuUiChanged => {
                "ATOM_ACCESSIBILITY_FLOATING_MENU_UI_CHANGED"
            }
            Self::AtomNeuralnetworksCompilationCompleted => {
                "ATOM_NEURALNETWORKS_COMPILATION_COMPLETED"
            }
            Self::AtomNeuralnetworksExecutionCompleted => {
                "ATOM_NEURALNETWORKS_EXECUTION_COMPLETED"
            }
            Self::AtomNeuralnetworksCompilationFailed => {
                "ATOM_NEURALNETWORKS_COMPILATION_FAILED"
            }
            Self::AtomNeuralnetworksExecutionFailed => {
                "ATOM_NEURALNETWORKS_EXECUTION_FAILED"
            }
            Self::AtomContextHubBooted => "ATOM_CONTEXT_HUB_BOOTED",
            Self::AtomContextHubRestarted => "ATOM_CONTEXT_HUB_RESTARTED",
            Self::AtomContextHubLoadedNanoappSnapshotReported => {
                "ATOM_CONTEXT_HUB_LOADED_NANOAPP_SNAPSHOT_REPORTED"
            }
            Self::AtomChreCodeDownloadTransacted => "ATOM_CHRE_CODE_DOWNLOAD_TRANSACTED",
            Self::AtomUwbSessionInited => "ATOM_UWB_SESSION_INITED",
            Self::AtomUwbSessionClosed => "ATOM_UWB_SESSION_CLOSED",
            Self::AtomUwbFirstRangingReceived => "ATOM_UWB_FIRST_RANGING_RECEIVED",
            Self::AtomUwbRangingMeasurementReceived => {
                "ATOM_UWB_RANGING_MEASUREMENT_RECEIVED"
            }
            Self::AtomTextClassifierDownloadWorkScheduled => {
                "ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_SCHEDULED"
            }
            Self::AtomTextClassifierDownloadWorkCompleted => {
                "ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_COMPLETED"
            }
            Self::AtomClipboardCleared => "ATOM_CLIPBOARD_CLEARED",
            Self::AtomVmCreationRequested => "ATOM_VM_CREATION_REQUESTED",
            Self::AtomNearbyDeviceScanStateChanged => {
                "ATOM_NEARBY_DEVICE_SCAN_STATE_CHANGED"
            }
            Self::AtomCameraCompatControlEventReported => {
                "ATOM_CAMERA_COMPAT_CONTROL_EVENT_REPORTED"
            }
            Self::AtomApplicationLocalesChanged => "ATOM_APPLICATION_LOCALES_CHANGED",
            Self::AtomMediametricsAudiotrackstatusReported => {
                "ATOM_MEDIAMETRICS_AUDIOTRACKSTATUS_REPORTED"
            }
            Self::AtomFoldStateDurationReported => "ATOM_FOLD_STATE_DURATION_REPORTED",
            Self::AtomLocationTimeZoneProviderControllerStateChanged => {
                "ATOM_LOCATION_TIME_ZONE_PROVIDER_CONTROLLER_STATE_CHANGED"
            }
            Self::AtomDisplayHbmStateChanged => "ATOM_DISPLAY_HBM_STATE_CHANGED",
            Self::AtomDisplayHbmBrightnessChanged => {
                "ATOM_DISPLAY_HBM_BRIGHTNESS_CHANGED"
            }
            Self::AtomPersistentUriPermissionsFlushed => {
                "ATOM_PERSISTENT_URI_PERMISSIONS_FLUSHED"
            }
            Self::AtomEarlyBootCompOsArtifactsCheckReported => {
                "ATOM_EARLY_BOOT_COMP_OS_ARTIFACTS_CHECK_REPORTED"
            }
            Self::AtomVbmetaDigestReported => "ATOM_VBMETA_DIGEST_REPORTED",
            Self::AtomApexInfoGathered => "ATOM_APEX_INFO_GATHERED",
            Self::AtomPvmInfoGathered => "ATOM_PVM_INFO_GATHERED",
            Self::AtomWearSettingsUiInteracted => "ATOM_WEAR_SETTINGS_UI_INTERACTED",
            Self::AtomTracingServiceReportEvent => "ATOM_TRACING_SERVICE_REPORT_EVENT",
            Self::AtomMediametricsAudiorecordstatusReported => {
                "ATOM_MEDIAMETRICS_AUDIORECORDSTATUS_REPORTED"
            }
            Self::AtomLauncherLatency => "ATOM_LAUNCHER_LATENCY",
            Self::AtomDropboxEntryDropped => "ATOM_DROPBOX_ENTRY_DROPPED",
            Self::AtomWifiP2pConnectionReported => "ATOM_WIFI_P2P_CONNECTION_REPORTED",
            Self::AtomGameStateChanged => "ATOM_GAME_STATE_CHANGED",
            Self::AtomHotwordDetectorCreateRequested => {
                "ATOM_HOTWORD_DETECTOR_CREATE_REQUESTED"
            }
            Self::AtomHotwordDetectionServiceInitResultReported => {
                "ATOM_HOTWORD_DETECTION_SERVICE_INIT_RESULT_REPORTED"
            }
            Self::AtomHotwordDetectionServiceRestarted => {
                "ATOM_HOTWORD_DETECTION_SERVICE_RESTARTED"
            }
            Self::AtomHotwordDetectorKeyphraseTriggered => {
                "ATOM_HOTWORD_DETECTOR_KEYPHRASE_TRIGGERED"
            }
            Self::AtomHotwordDetectorEvents => "ATOM_HOTWORD_DETECTOR_EVENTS",
            Self::AtomAdServicesApiCalled => "ATOM_AD_SERVICES_API_CALLED",
            Self::AtomAdServicesMesurementReportsUploaded => {
                "ATOM_AD_SERVICES_MESUREMENT_REPORTS_UPLOADED"
            }
            Self::AtomBootCompletedBroadcastCompletionLatencyReported => {
                "ATOM_BOOT_COMPLETED_BROADCAST_COMPLETION_LATENCY_REPORTED"
            }
            Self::AtomContactsIndexerUpdateStatsReported => {
                "ATOM_CONTACTS_INDEXER_UPDATE_STATS_REPORTED"
            }
            Self::AtomAppBackgroundRestrictionsInfo => {
                "ATOM_APP_BACKGROUND_RESTRICTIONS_INFO"
            }
            Self::AtomMmsSmsProviderGetThreadIdFailed => {
                "ATOM_MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED"
            }
            Self::AtomMmsSmsDatabaseHelperOnUpgradeFailed => {
                "ATOM_MMS_SMS_DATABASE_HELPER_ON_UPGRADE_FAILED"
            }
            Self::AtomPermissionReminderNotificationInteracted => {
                "ATOM_PERMISSION_REMINDER_NOTIFICATION_INTERACTED"
            }
            Self::AtomRecentPermissionDecisionsInteracted => {
                "ATOM_RECENT_PERMISSION_DECISIONS_INTERACTED"
            }
            Self::AtomGnssPsdsDownloadReported => "ATOM_GNSS_PSDS_DOWNLOAD_REPORTED",
            Self::AtomLeAudioConnectionSessionReported => {
                "ATOM_LE_AUDIO_CONNECTION_SESSION_REPORTED"
            }
            Self::AtomLeAudioBroadcastSessionReported => {
                "ATOM_LE_AUDIO_BROADCAST_SESSION_REPORTED"
            }
            Self::AtomDreamUiEventReported => "ATOM_DREAM_UI_EVENT_REPORTED",
            Self::AtomTaskManagerEventReported => "ATOM_TASK_MANAGER_EVENT_REPORTED",
            Self::AtomCdmAssociationAction => "ATOM_CDM_ASSOCIATION_ACTION",
            Self::AtomMagnificationTripleTapAndHoldActivatedSessionReported => {
                "ATOM_MAGNIFICATION_TRIPLE_TAP_AND_HOLD_ACTIVATED_SESSION_REPORTED"
            }
            Self::AtomMagnificationFollowTypingFocusActivatedSessionReported => {
                "ATOM_MAGNIFICATION_FOLLOW_TYPING_FOCUS_ACTIVATED_SESSION_REPORTED"
            }
            Self::AtomAccessibilityTextReadingOptionsChanged => {
                "ATOM_ACCESSIBILITY_TEXT_READING_OPTIONS_CHANGED"
            }
            Self::AtomWifiSetupFailureCrashReported => {
                "ATOM_WIFI_SETUP_FAILURE_CRASH_REPORTED"
            }
            Self::AtomUwbDeviceErrorReported => "ATOM_UWB_DEVICE_ERROR_REPORTED",
            Self::AtomIsolatedCompilationScheduled => {
                "ATOM_ISOLATED_COMPILATION_SCHEDULED"
            }
            Self::AtomIsolatedCompilationEnded => "ATOM_ISOLATED_COMPILATION_ENDED",
            Self::AtomOnsOpportunisticEsimProvisioningComplete => {
                "ATOM_ONS_OPPORTUNISTIC_ESIM_PROVISIONING_COMPLETE"
            }
            Self::AtomSystemServerPreWatchdogOccurred => {
                "ATOM_SYSTEM_SERVER_PRE_WATCHDOG_OCCURRED"
            }
            Self::AtomTelephonyAnomalyDetected => "ATOM_TELEPHONY_ANOMALY_DETECTED",
            Self::AtomLetterboxPositionChanged => "ATOM_LETTERBOX_POSITION_CHANGED",
            Self::AtomRemoteKeyProvisioningAttempt => {
                "ATOM_REMOTE_KEY_PROVISIONING_ATTEMPT"
            }
            Self::AtomRemoteKeyProvisioningNetworkInfo => {
                "ATOM_REMOTE_KEY_PROVISIONING_NETWORK_INFO"
            }
            Self::AtomRemoteKeyProvisioningTiming => {
                "ATOM_REMOTE_KEY_PROVISIONING_TIMING"
            }
            Self::AtomMediaoutputOpInteractionReport => {
                "ATOM_MEDIAOUTPUT_OP_INTERACTION_REPORT"
            }
            Self::AtomSyncExemptionOccurred => "ATOM_SYNC_EXEMPTION_OCCURRED",
            Self::AtomAutofillPresentationEventReported => {
                "ATOM_AUTOFILL_PRESENTATION_EVENT_REPORTED"
            }
            Self::AtomDockStateChanged => "ATOM_DOCK_STATE_CHANGED",
            Self::AtomSafetySourceStateCollected => "ATOM_SAFETY_SOURCE_STATE_COLLECTED",
            Self::AtomSafetyCenterSystemEventReported => {
                "ATOM_SAFETY_CENTER_SYSTEM_EVENT_REPORTED"
            }
            Self::AtomSafetyCenterInteractionReported => {
                "ATOM_SAFETY_CENTER_INTERACTION_REPORTED"
            }
            Self::AtomSettingsProviderSettingChanged => {
                "ATOM_SETTINGS_PROVIDER_SETTING_CHANGED"
            }
            Self::AtomBroadcastDeliveryEventReported => {
                "ATOM_BROADCAST_DELIVERY_EVENT_REPORTED"
            }
            Self::AtomServiceRequestEventReported => {
                "ATOM_SERVICE_REQUEST_EVENT_REPORTED"
            }
            Self::AtomProviderAcquisitionEventReported => {
                "ATOM_PROVIDER_ACQUISITION_EVENT_REPORTED"
            }
            Self::AtomBluetoothDeviceNameReported => {
                "ATOM_BLUETOOTH_DEVICE_NAME_REPORTED"
            }
            Self::AtomCbConfigUpdated => "ATOM_CB_CONFIG_UPDATED",
            Self::AtomCbModuleErrorReported => "ATOM_CB_MODULE_ERROR_REPORTED",
            Self::AtomCbServiceFeatureChanged => "ATOM_CB_SERVICE_FEATURE_CHANGED",
            Self::AtomCbReceiverFeatureChanged => "ATOM_CB_RECEIVER_FEATURE_CHANGED",
            Self::AtomJsscriptengineLatencyReported => {
                "ATOM_JSSCRIPTENGINE_LATENCY_REPORTED"
            }
            Self::AtomPrivacySignalNotificationInteraction => {
                "ATOM_PRIVACY_SIGNAL_NOTIFICATION_INTERACTION"
            }
            Self::AtomPrivacySignalIssueCardInteraction => {
                "ATOM_PRIVACY_SIGNAL_ISSUE_CARD_INTERACTION"
            }
            Self::AtomPrivacySignalsJobFailure => "ATOM_PRIVACY_SIGNALS_JOB_FAILURE",
            Self::AtomVibrationReported => "ATOM_VIBRATION_REPORTED",
            Self::AtomUwbRangingStart => "ATOM_UWB_RANGING_START",
            Self::AtomMobileDataDownloadFileGroupStatusReported => {
                "ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STATUS_REPORTED"
            }
            Self::AtomAppCompactedV2 => "ATOM_APP_COMPACTED_V2",
            Self::AtomAdServicesSettingsUsageReported => {
                "ATOM_AD_SERVICES_SETTINGS_USAGE_REPORTED"
            }
            Self::AtomDisplayBrightnessChanged => "ATOM_DISPLAY_BRIGHTNESS_CHANGED",
            Self::AtomActivityActionBlocked => "ATOM_ACTIVITY_ACTION_BLOCKED",
            Self::AtomBackgroundFetchProcessReported => {
                "ATOM_BACKGROUND_FETCH_PROCESS_REPORTED"
            }
            Self::AtomUpdateCustomAudienceProcessReported => {
                "ATOM_UPDATE_CUSTOM_AUDIENCE_PROCESS_REPORTED"
            }
            Self::AtomRunAdBiddingProcessReported => {
                "ATOM_RUN_AD_BIDDING_PROCESS_REPORTED"
            }
            Self::AtomRunAdScoringProcessReported => {
                "ATOM_RUN_AD_SCORING_PROCESS_REPORTED"
            }
            Self::AtomRunAdSelectionProcessReported => {
                "ATOM_RUN_AD_SELECTION_PROCESS_REPORTED"
            }
            Self::AtomRunAdBiddingPerCaProcessReported => {
                "ATOM_RUN_AD_BIDDING_PER_CA_PROCESS_REPORTED"
            }
            Self::AtomMobileDataDownloadDownloadResultReported => {
                "ATOM_MOBILE_DATA_DOWNLOAD_DOWNLOAD_RESULT_REPORTED"
            }
            Self::AtomMobileDataDownloadFileGroupStorageStatsReported => {
                "ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STORAGE_STATS_REPORTED"
            }
            Self::AtomNetworkDnsServerSupportReported => {
                "ATOM_NETWORK_DNS_SERVER_SUPPORT_REPORTED"
            }
            Self::AtomVmBooted => "ATOM_VM_BOOTED",
            Self::AtomVmExited => "ATOM_VM_EXITED",
            Self::AtomAmbientBrightnessStatsReported => {
                "ATOM_AMBIENT_BRIGHTNESS_STATS_REPORTED"
            }
            Self::AtomMediametricsSpatializercapabilitiesReported => {
                "ATOM_MEDIAMETRICS_SPATIALIZERCAPABILITIES_REPORTED"
            }
            Self::AtomMediametricsSpatializerdeviceenabledReported => {
                "ATOM_MEDIAMETRICS_SPATIALIZERDEVICEENABLED_REPORTED"
            }
            Self::AtomMediametricsHeadtrackerdeviceenabledReported => {
                "ATOM_MEDIAMETRICS_HEADTRACKERDEVICEENABLED_REPORTED"
            }
            Self::AtomMediametricsHeadtrackerdevicesupportedReported => {
                "ATOM_MEDIAMETRICS_HEADTRACKERDEVICESUPPORTED_REPORTED"
            }
            Self::AtomAdServicesMeasurementRegistrations => {
                "ATOM_AD_SERVICES_MEASUREMENT_REGISTRATIONS"
            }
            Self::AtomHearingAidInfoReported => "ATOM_HEARING_AID_INFO_REPORTED",
            Self::AtomDeviceWideJobConstraintChanged => {
                "ATOM_DEVICE_WIDE_JOB_CONSTRAINT_CHANGED"
            }
            Self::AtomAmbientModeChanged => "ATOM_AMBIENT_MODE_CHANGED",
            Self::AtomAnrLatencyReported => "ATOM_ANR_LATENCY_REPORTED",
            Self::AtomResourceApiInfo => "ATOM_RESOURCE_API_INFO",
            Self::AtomSystemDefaultNetworkChanged => {
                "ATOM_SYSTEM_DEFAULT_NETWORK_CHANGED"
            }
            Self::AtomIwlanSetupDataCallResultReported => {
                "ATOM_IWLAN_SETUP_DATA_CALL_RESULT_REPORTED"
            }
            Self::AtomIwlanPdnDisconnectedReasonReported => {
                "ATOM_IWLAN_PDN_DISCONNECTED_REASON_REPORTED"
            }
            Self::AtomAirplaneModeSessionReported => {
                "ATOM_AIRPLANE_MODE_SESSION_REPORTED"
            }
            Self::AtomVmCpuStatusReported => "ATOM_VM_CPU_STATUS_REPORTED",
            Self::AtomVmMemStatusReported => "ATOM_VM_MEM_STATUS_REPORTED",
            Self::AtomPackageInstallationSessionReported => {
                "ATOM_PACKAGE_INSTALLATION_SESSION_REPORTED"
            }
            Self::AtomDefaultNetworkRematchInfo => "ATOM_DEFAULT_NETWORK_REMATCH_INFO",
            Self::AtomNetworkSelectionPerformance => "ATOM_NETWORK_SELECTION_PERFORMANCE",
            Self::AtomNetworkNsdReported => "ATOM_NETWORK_NSD_REPORTED",
            Self::AtomBluetoothDisconnectionReasonReported => {
                "ATOM_BLUETOOTH_DISCONNECTION_REASON_REPORTED"
            }
            Self::AtomBluetoothLocalVersionsReported => {
                "ATOM_BLUETOOTH_LOCAL_VERSIONS_REPORTED"
            }
            Self::AtomBluetoothRemoteSupportedFeaturesReported => {
                "ATOM_BLUETOOTH_REMOTE_SUPPORTED_FEATURES_REPORTED"
            }
            Self::AtomBluetoothLocalSupportedFeaturesReported => {
                "ATOM_BLUETOOTH_LOCAL_SUPPORTED_FEATURES_REPORTED"
            }
            Self::AtomBluetoothGattAppInfo => "ATOM_BLUETOOTH_GATT_APP_INFO",
            Self::AtomBrightnessConfigurationUpdated => {
                "ATOM_BRIGHTNESS_CONFIGURATION_UPDATED"
            }
            Self::AtomAdServicesGetTopicsReported => {
                "ATOM_AD_SERVICES_GET_TOPICS_REPORTED"
            }
            Self::AtomAdServicesEpochComputationGetTopTopicsReported => {
                "ATOM_AD_SERVICES_EPOCH_COMPUTATION_GET_TOP_TOPICS_REPORTED"
            }
            Self::AtomAdServicesEpochComputationClassifierReported => {
                "ATOM_AD_SERVICES_EPOCH_COMPUTATION_CLASSIFIER_REPORTED"
            }
            Self::AtomWearMediaOutputSwitcherLaunched => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_LAUNCHED"
            }
            Self::AtomWearMediaOutputSwitcherFinished => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FINISHED"
            }
            Self::AtomWearMediaOutputSwitcherConnectionReported => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECTION_REPORTED"
            }
            Self::AtomWearMediaOutputSwitcherDeviceScanTriggered => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_TRIGGERED"
            }
            Self::AtomWearMediaOutputSwitcherFirstDeviceScanLatency => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FIRST_DEVICE_SCAN_LATENCY"
            }
            Self::AtomWearMediaOutputSwitcherConnectDeviceLatency => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECT_DEVICE_LATENCY"
            }
            Self::AtomPackageManagerSnapshotReported => {
                "ATOM_PACKAGE_MANAGER_SNAPSHOT_REPORTED"
            }
            Self::AtomPackageManagerAppsFilterCacheBuildReported => {
                "ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_BUILD_REPORTED"
            }
            Self::AtomPackageManagerAppsFilterCacheUpdateReported => {
                "ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_UPDATE_REPORTED"
            }
            Self::AtomLauncherImpressionEvent => "ATOM_LAUNCHER_IMPRESSION_EVENT",
            Self::AtomWearMediaOutputSwitcherAllDevicesScanLatency => {
                "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_ALL_DEVICES_SCAN_LATENCY"
            }
            Self::AtomWsWatchFaceEdited => "ATOM_WS_WATCH_FACE_EDITED",
            Self::AtomWsWatchFaceFavoriteActionReported => {
                "ATOM_WS_WATCH_FACE_FAVORITE_ACTION_REPORTED"
            }
            Self::AtomWsWatchFaceSetActionReported => {
                "ATOM_WS_WATCH_FACE_SET_ACTION_REPORTED"
            }
            Self::AtomPackageUninstallationReported => {
                "ATOM_PACKAGE_UNINSTALLATION_REPORTED"
            }
            Self::AtomGameModeChanged => "ATOM_GAME_MODE_CHANGED",
            Self::AtomGameModeConfigurationChanged => {
                "ATOM_GAME_MODE_CONFIGURATION_CHANGED"
            }
            Self::AtomBedtimeModeStateChanged => "ATOM_BEDTIME_MODE_STATE_CHANGED",
            Self::AtomNetworkSliceSessionEnded => "ATOM_NETWORK_SLICE_SESSION_ENDED",
            Self::AtomNetworkSliceDailyDataUsageReported => {
                "ATOM_NETWORK_SLICE_DAILY_DATA_USAGE_REPORTED"
            }
            Self::AtomNfcTagTypeOccurred => "ATOM_NFC_TAG_TYPE_OCCURRED",
            Self::AtomNfcAidConflictOccurred => "ATOM_NFC_AID_CONFLICT_OCCURRED",
            Self::AtomNfcReaderConflictOccurred => "ATOM_NFC_READER_CONFLICT_OCCURRED",
            Self::AtomWsTileListChanged => "ATOM_WS_TILE_LIST_CHANGED",
            Self::AtomGetTypeAccessedWithoutPermission => {
                "ATOM_GET_TYPE_ACCESSED_WITHOUT_PERMISSION"
            }
            Self::AtomMobileBundledAppInfoGathered => {
                "ATOM_MOBILE_BUNDLED_APP_INFO_GATHERED"
            }
            Self::AtomWsWatchFaceComplicationSetChanged => {
                "ATOM_WS_WATCH_FACE_COMPLICATION_SET_CHANGED"
            }
            Self::AtomMediaDrmCreated => "ATOM_MEDIA_DRM_CREATED",
            Self::AtomMediaDrmErrored => "ATOM_MEDIA_DRM_ERRORED",
            Self::AtomMediaDrmSessionOpened => "ATOM_MEDIA_DRM_SESSION_OPENED",
            Self::AtomMediaDrmSessionClosed => "ATOM_MEDIA_DRM_SESSION_CLOSED",
            Self::AtomUserSelectedResolution => "ATOM_USER_SELECTED_RESOLUTION",
            Self::AtomUnsafeIntentEventReported => "ATOM_UNSAFE_INTENT_EVENT_REPORTED",
            Self::AtomPerformanceHintSessionReported => {
                "ATOM_PERFORMANCE_HINT_SESSION_REPORTED"
            }
            Self::AtomMediametricsMidiDeviceCloseReported => {
                "ATOM_MEDIAMETRICS_MIDI_DEVICE_CLOSE_REPORTED"
            }
            Self::AtomBiometricTouchReported => "ATOM_BIOMETRIC_TOUCH_REPORTED",
            Self::AtomHotwordAudioEgressEventReported => {
                "ATOM_HOTWORD_AUDIO_EGRESS_EVENT_REPORTED"
            }
            Self::AtomAppSearchSchemaMigrationStatsReported => {
                "ATOM_APP_SEARCH_SCHEMA_MIGRATION_STATS_REPORTED"
            }
            Self::AtomLocationEnabledStateChanged => {
                "ATOM_LOCATION_ENABLED_STATE_CHANGED"
            }
            Self::AtomImeRequestFinished => "ATOM_IME_REQUEST_FINISHED",
            Self::AtomUsbComplianceWarningsReported => {
                "ATOM_USB_COMPLIANCE_WARNINGS_REPORTED"
            }
            Self::AtomAppSupportedLocalesChanged => "ATOM_APP_SUPPORTED_LOCALES_CHANGED",
            Self::AtomGrammaticalInflectionChanged => {
                "ATOM_GRAMMATICAL_INFLECTION_CHANGED"
            }
            Self::AtomMediaProviderVolumeRecoveryReported => {
                "ATOM_MEDIA_PROVIDER_VOLUME_RECOVERY_REPORTED"
            }
            Self::AtomBiometricPropertiesCollected => {
                "ATOM_BIOMETRIC_PROPERTIES_COLLECTED"
            }
            Self::AtomKernelWakeupAttributed => "ATOM_KERNEL_WAKEUP_ATTRIBUTED",
            Self::AtomScreenStateChangedV2 => "ATOM_SCREEN_STATE_CHANGED_V2",
            Self::AtomWsBackupActionReported => "ATOM_WS_BACKUP_ACTION_REPORTED",
            Self::AtomWsRestoreActionReported => "ATOM_WS_RESTORE_ACTION_REPORTED",
            Self::AtomDeviceLogAccessEventReported => {
                "ATOM_DEVICE_LOG_ACCESS_EVENT_REPORTED"
            }
            Self::AtomMediaSessionUpdated => "ATOM_MEDIA_SESSION_UPDATED",
            Self::AtomWearOobeStateChanged => "ATOM_WEAR_OOBE_STATE_CHANGED",
            Self::AtomWsNotificationUpdated => "ATOM_WS_NOTIFICATION_UPDATED",
            Self::AtomNetworkValidationFailureStatsDailyReported => {
                "ATOM_NETWORK_VALIDATION_FAILURE_STATS_DAILY_REPORTED"
            }
            Self::AtomWsComplicationTapped => "ATOM_WS_COMPLICATION_TAPPED",
            Self::AtomWsWearTimeSession => "ATOM_WS_WEAR_TIME_SESSION",
            Self::AtomWifiBytesTransfer => "ATOM_WIFI_BYTES_TRANSFER",
            Self::AtomWifiBytesTransferByFgBg => "ATOM_WIFI_BYTES_TRANSFER_BY_FG_BG",
            Self::AtomMobileBytesTransfer => "ATOM_MOBILE_BYTES_TRANSFER",
            Self::AtomMobileBytesTransferByFgBg => "ATOM_MOBILE_BYTES_TRANSFER_BY_FG_BG",
            Self::AtomBluetoothBytesTransfer => "ATOM_BLUETOOTH_BYTES_TRANSFER",
            Self::AtomKernelWakelock => "ATOM_KERNEL_WAKELOCK",
            Self::AtomSubsystemSleepState => "ATOM_SUBSYSTEM_SLEEP_STATE",
            Self::AtomCpuTimePerUid => "ATOM_CPU_TIME_PER_UID",
            Self::AtomCpuTimePerUidFreq => "ATOM_CPU_TIME_PER_UID_FREQ",
            Self::AtomWifiActivityInfo => "ATOM_WIFI_ACTIVITY_INFO",
            Self::AtomModemActivityInfo => "ATOM_MODEM_ACTIVITY_INFO",
            Self::AtomBluetoothActivityInfo => "ATOM_BLUETOOTH_ACTIVITY_INFO",
            Self::AtomProcessMemoryState => "ATOM_PROCESS_MEMORY_STATE",
            Self::AtomSystemElapsedRealtime => "ATOM_SYSTEM_ELAPSED_REALTIME",
            Self::AtomSystemUptime => "ATOM_SYSTEM_UPTIME",
            Self::AtomCpuActiveTime => "ATOM_CPU_ACTIVE_TIME",
            Self::AtomCpuClusterTime => "ATOM_CPU_CLUSTER_TIME",
            Self::AtomDiskSpace => "ATOM_DISK_SPACE",
            Self::AtomRemainingBatteryCapacity => "ATOM_REMAINING_BATTERY_CAPACITY",
            Self::AtomFullBatteryCapacity => "ATOM_FULL_BATTERY_CAPACITY",
            Self::AtomTemperature => "ATOM_TEMPERATURE",
            Self::AtomBinderCalls => "ATOM_BINDER_CALLS",
            Self::AtomBinderCallsExceptions => "ATOM_BINDER_CALLS_EXCEPTIONS",
            Self::AtomLooperStats => "ATOM_LOOPER_STATS",
            Self::AtomDiskStats => "ATOM_DISK_STATS",
            Self::AtomDirectoryUsage => "ATOM_DIRECTORY_USAGE",
            Self::AtomAppSize => "ATOM_APP_SIZE",
            Self::AtomCategorySize => "ATOM_CATEGORY_SIZE",
            Self::AtomProcStats => "ATOM_PROC_STATS",
            Self::AtomBatteryVoltage => "ATOM_BATTERY_VOLTAGE",
            Self::AtomNumFingerprintsEnrolled => "ATOM_NUM_FINGERPRINTS_ENROLLED",
            Self::AtomDiskIo => "ATOM_DISK_IO",
            Self::AtomPowerProfile => "ATOM_POWER_PROFILE",
            Self::AtomProcStatsPkgProc => "ATOM_PROC_STATS_PKG_PROC",
            Self::AtomProcessCpuTime => "ATOM_PROCESS_CPU_TIME",
            Self::AtomCpuTimePerThreadFreq => "ATOM_CPU_TIME_PER_THREAD_FREQ",
            Self::AtomOnDevicePowerMeasurement => "ATOM_ON_DEVICE_POWER_MEASUREMENT",
            Self::AtomDeviceCalculatedPowerUse => "ATOM_DEVICE_CALCULATED_POWER_USE",
            Self::AtomProcessMemoryHighWaterMark => "ATOM_PROCESS_MEMORY_HIGH_WATER_MARK",
            Self::AtomBatteryLevel => "ATOM_BATTERY_LEVEL",
            Self::AtomBuildInformation => "ATOM_BUILD_INFORMATION",
            Self::AtomBatteryCycleCount => "ATOM_BATTERY_CYCLE_COUNT",
            Self::AtomDebugElapsedClock => "ATOM_DEBUG_ELAPSED_CLOCK",
            Self::AtomDebugFailingElapsedClock => "ATOM_DEBUG_FAILING_ELAPSED_CLOCK",
            Self::AtomNumFacesEnrolled => "ATOM_NUM_FACES_ENROLLED",
            Self::AtomRoleHolder => "ATOM_ROLE_HOLDER",
            Self::AtomDangerousPermissionState => "ATOM_DANGEROUS_PERMISSION_STATE",
            Self::AtomTrainInfo => "ATOM_TRAIN_INFO",
            Self::AtomTimeZoneDataInfo => "ATOM_TIME_ZONE_DATA_INFO",
            Self::AtomExternalStorageInfo => "ATOM_EXTERNAL_STORAGE_INFO",
            Self::AtomGpuStatsGlobalInfo => "ATOM_GPU_STATS_GLOBAL_INFO",
            Self::AtomGpuStatsAppInfo => "ATOM_GPU_STATS_APP_INFO",
            Self::AtomSystemIonHeapSize => "ATOM_SYSTEM_ION_HEAP_SIZE",
            Self::AtomAppsOnExternalStorageInfo => "ATOM_APPS_ON_EXTERNAL_STORAGE_INFO",
            Self::AtomFaceSettings => "ATOM_FACE_SETTINGS",
            Self::AtomCoolingDevice => "ATOM_COOLING_DEVICE",
            Self::AtomAppOps => "ATOM_APP_OPS",
            Self::AtomProcessSystemIonHeapSize => "ATOM_PROCESS_SYSTEM_ION_HEAP_SIZE",
            Self::AtomSurfaceflingerStatsGlobalInfo => {
                "ATOM_SURFACEFLINGER_STATS_GLOBAL_INFO"
            }
            Self::AtomSurfaceflingerStatsLayerInfo => {
                "ATOM_SURFACEFLINGER_STATS_LAYER_INFO"
            }
            Self::AtomProcessMemorySnapshot => "ATOM_PROCESS_MEMORY_SNAPSHOT",
            Self::AtomVmsClientStats => "ATOM_VMS_CLIENT_STATS",
            Self::AtomNotificationRemoteViews => "ATOM_NOTIFICATION_REMOTE_VIEWS",
            Self::AtomDangerousPermissionStateSampled => {
                "ATOM_DANGEROUS_PERMISSION_STATE_SAMPLED"
            }
            Self::AtomGraphicsStats => "ATOM_GRAPHICS_STATS",
            Self::AtomRuntimeAppOpAccess => "ATOM_RUNTIME_APP_OP_ACCESS",
            Self::AtomIonHeapSize => "ATOM_ION_HEAP_SIZE",
            Self::AtomPackageNotificationPreferences => {
                "ATOM_PACKAGE_NOTIFICATION_PREFERENCES"
            }
            Self::AtomPackageNotificationChannelPreferences => {
                "ATOM_PACKAGE_NOTIFICATION_CHANNEL_PREFERENCES"
            }
            Self::AtomPackageNotificationChannelGroupPreferences => {
                "ATOM_PACKAGE_NOTIFICATION_CHANNEL_GROUP_PREFERENCES"
            }
            Self::AtomGnssStats => "ATOM_GNSS_STATS",
            Self::AtomAttributedAppOps => "ATOM_ATTRIBUTED_APP_OPS",
            Self::AtomVoiceCallSession => "ATOM_VOICE_CALL_SESSION",
            Self::AtomVoiceCallRatUsage => "ATOM_VOICE_CALL_RAT_USAGE",
            Self::AtomSimSlotState => "ATOM_SIM_SLOT_STATE",
            Self::AtomSupportedRadioAccessFamily => "ATOM_SUPPORTED_RADIO_ACCESS_FAMILY",
            Self::AtomSettingSnapshot => "ATOM_SETTING_SNAPSHOT",
            Self::AtomBlobInfo => "ATOM_BLOB_INFO",
            Self::AtomDataUsageBytesTransfer => "ATOM_DATA_USAGE_BYTES_TRANSFER",
            Self::AtomBytesTransferByTagAndMetered => {
                "ATOM_BYTES_TRANSFER_BY_TAG_AND_METERED"
            }
            Self::AtomDndModeRule => "ATOM_DND_MODE_RULE",
            Self::AtomGeneralExternalStorageAccessStats => {
                "ATOM_GENERAL_EXTERNAL_STORAGE_ACCESS_STATS"
            }
            Self::AtomIncomingSms => "ATOM_INCOMING_SMS",
            Self::AtomOutgoingSms => "ATOM_OUTGOING_SMS",
            Self::AtomCarrierIdTableVersion => "ATOM_CARRIER_ID_TABLE_VERSION",
            Self::AtomDataCallSession => "ATOM_DATA_CALL_SESSION",
            Self::AtomCellularServiceState => "ATOM_CELLULAR_SERVICE_STATE",
            Self::AtomCellularDataServiceSwitch => "ATOM_CELLULAR_DATA_SERVICE_SWITCH",
            Self::AtomSystemMemory => "ATOM_SYSTEM_MEMORY",
            Self::AtomImsRegistrationTermination => "ATOM_IMS_REGISTRATION_TERMINATION",
            Self::AtomImsRegistrationStats => "ATOM_IMS_REGISTRATION_STATS",
            Self::AtomCpuTimePerClusterFreq => "ATOM_CPU_TIME_PER_CLUSTER_FREQ",
            Self::AtomCpuCyclesPerUidCluster => "ATOM_CPU_CYCLES_PER_UID_CLUSTER",
            Self::AtomDeviceRotatedData => "ATOM_DEVICE_ROTATED_DATA",
            Self::AtomCpuCyclesPerThreadGroupCluster => {
                "ATOM_CPU_CYCLES_PER_THREAD_GROUP_CLUSTER"
            }
            Self::AtomMediaDrmActivityInfo => "ATOM_MEDIA_DRM_ACTIVITY_INFO",
            Self::AtomOemManagedBytesTransfer => "ATOM_OEM_MANAGED_BYTES_TRANSFER",
            Self::AtomGnssPowerStats => "ATOM_GNSS_POWER_STATS",
            Self::AtomTimeZoneDetectorState => "ATOM_TIME_ZONE_DETECTOR_STATE",
            Self::AtomKeystore2StorageStats => "ATOM_KEYSTORE2_STORAGE_STATS",
            Self::AtomRkpPoolStats => "ATOM_RKP_POOL_STATS",
            Self::AtomProcessDmabufMemory => "ATOM_PROCESS_DMABUF_MEMORY",
            Self::AtomPendingAlarmInfo => "ATOM_PENDING_ALARM_INFO",
            Self::AtomUserLevelHibernatedApps => "ATOM_USER_LEVEL_HIBERNATED_APPS",
            Self::AtomLauncherLayoutSnapshot => "ATOM_LAUNCHER_LAYOUT_SNAPSHOT",
            Self::AtomGlobalHibernatedApps => "ATOM_GLOBAL_HIBERNATED_APPS",
            Self::AtomInputEventLatencySketch => "ATOM_INPUT_EVENT_LATENCY_SKETCH",
            Self::AtomBatteryUsageStatsBeforeReset => {
                "ATOM_BATTERY_USAGE_STATS_BEFORE_RESET"
            }
            Self::AtomBatteryUsageStatsSinceReset => {
                "ATOM_BATTERY_USAGE_STATS_SINCE_RESET"
            }
            Self::AtomBatteryUsageStatsSinceResetUsingPowerProfileModel => {
                "ATOM_BATTERY_USAGE_STATS_SINCE_RESET_USING_POWER_PROFILE_MODEL"
            }
            Self::AtomInstalledIncrementalPackage => "ATOM_INSTALLED_INCREMENTAL_PACKAGE",
            Self::AtomTelephonyNetworkRequests => "ATOM_TELEPHONY_NETWORK_REQUESTS",
            Self::AtomAppSearchStorageInfo => "ATOM_APP_SEARCH_STORAGE_INFO",
            Self::AtomVmstat => "ATOM_VMSTAT",
            Self::AtomKeystore2KeyCreationWithGeneralInfo => {
                "ATOM_KEYSTORE2_KEY_CREATION_WITH_GENERAL_INFO"
            }
            Self::AtomKeystore2KeyCreationWithAuthInfo => {
                "ATOM_KEYSTORE2_KEY_CREATION_WITH_AUTH_INFO"
            }
            Self::AtomKeystore2KeyCreationWithPurposeAndModesInfo => {
                "ATOM_KEYSTORE2_KEY_CREATION_WITH_PURPOSE_AND_MODES_INFO"
            }
            Self::AtomKeystore2AtomWithOverflow => "ATOM_KEYSTORE2_ATOM_WITH_OVERFLOW",
            Self::AtomKeystore2KeyOperationWithPurposeAndModesInfo => {
                "ATOM_KEYSTORE2_KEY_OPERATION_WITH_PURPOSE_AND_MODES_INFO"
            }
            Self::AtomKeystore2KeyOperationWithGeneralInfo => {
                "ATOM_KEYSTORE2_KEY_OPERATION_WITH_GENERAL_INFO"
            }
            Self::AtomRkpErrorStats => "ATOM_RKP_ERROR_STATS",
            Self::AtomKeystore2CrashStats => "ATOM_KEYSTORE2_CRASH_STATS",
            Self::AtomVendorApexInfo => "ATOM_VENDOR_APEX_INFO",
            Self::AtomAccessibilityShortcutStats => "ATOM_ACCESSIBILITY_SHORTCUT_STATS",
            Self::AtomAccessibilityFloatingMenuStats => {
                "ATOM_ACCESSIBILITY_FLOATING_MENU_STATS"
            }
            Self::AtomDataUsageBytesTransferV2 => "ATOM_DATA_USAGE_BYTES_TRANSFER_V2",
            Self::AtomMediaCapabilities => "ATOM_MEDIA_CAPABILITIES",
            Self::AtomCarWatchdogSystemIoUsageSummary => {
                "ATOM_CAR_WATCHDOG_SYSTEM_IO_USAGE_SUMMARY"
            }
            Self::AtomCarWatchdogUidIoUsageSummary => {
                "ATOM_CAR_WATCHDOG_UID_IO_USAGE_SUMMARY"
            }
            Self::AtomImsRegistrationFeatureTagStats => {
                "ATOM_IMS_REGISTRATION_FEATURE_TAG_STATS"
            }
            Self::AtomRcsClientProvisioningStats => "ATOM_RCS_CLIENT_PROVISIONING_STATS",
            Self::AtomRcsAcsProvisioningStats => "ATOM_RCS_ACS_PROVISIONING_STATS",
            Self::AtomSipDelegateStats => "ATOM_SIP_DELEGATE_STATS",
            Self::AtomSipTransportFeatureTagStats => {
                "ATOM_SIP_TRANSPORT_FEATURE_TAG_STATS"
            }
            Self::AtomSipMessageResponse => "ATOM_SIP_MESSAGE_RESPONSE",
            Self::AtomSipTransportSession => "ATOM_SIP_TRANSPORT_SESSION",
            Self::AtomImsDedicatedBearerListenerEvent => {
                "ATOM_IMS_DEDICATED_BEARER_LISTENER_EVENT"
            }
            Self::AtomImsDedicatedBearerEvent => "ATOM_IMS_DEDICATED_BEARER_EVENT",
            Self::AtomImsRegistrationServiceDescStats => {
                "ATOM_IMS_REGISTRATION_SERVICE_DESC_STATS"
            }
            Self::AtomUceEventStats => "ATOM_UCE_EVENT_STATS",
            Self::AtomPresenceNotifyEvent => "ATOM_PRESENCE_NOTIFY_EVENT",
            Self::AtomGbaEvent => "ATOM_GBA_EVENT",
            Self::AtomPerSimStatus => "ATOM_PER_SIM_STATUS",
            Self::AtomGpuWorkPerUid => "ATOM_GPU_WORK_PER_UID",
            Self::AtomPersistentUriPermissionsAmountPerPackage => {
                "ATOM_PERSISTENT_URI_PERMISSIONS_AMOUNT_PER_PACKAGE"
            }
            Self::AtomSignedPartitionInfo => "ATOM_SIGNED_PARTITION_INFO",
            Self::AtomPinnedFileSizesPerPackage => "ATOM_PINNED_FILE_SIZES_PER_PACKAGE",
            Self::AtomPendingIntentsPerPackage => "ATOM_PENDING_INTENTS_PER_PACKAGE",
            Self::AtomUserInfo => "ATOM_USER_INFO",
            Self::AtomTelephonyNetworkRequestsV2 => "ATOM_TELEPHONY_NETWORK_REQUESTS_V2",
            Self::AtomDeviceTelephonyProperties => "ATOM_DEVICE_TELEPHONY_PROPERTIES",
            Self::AtomRemoteKeyProvisioningErrorCounts => {
                "ATOM_REMOTE_KEY_PROVISIONING_ERROR_COUNTS"
            }
            Self::AtomSafetyState => "ATOM_SAFETY_STATE",
            Self::AtomIncomingMms => "ATOM_INCOMING_MMS",
            Self::AtomOutgoingMms => "ATOM_OUTGOING_MMS",
            Self::AtomMultiUserInfo => "ATOM_MULTI_USER_INFO",
            Self::AtomNetworkBpfMapInfo => "ATOM_NETWORK_BPF_MAP_INFO",
            Self::AtomOutgoingShortCodeSms => "ATOM_OUTGOING_SHORT_CODE_SMS",
            Self::AtomConnectivityStateSample => "ATOM_CONNECTIVITY_STATE_SAMPLE",
            Self::AtomNetworkSelectionRematchReasonsInfo => {
                "ATOM_NETWORK_SELECTION_REMATCH_REASONS_INFO"
            }
            Self::AtomGameModeInfo => "ATOM_GAME_MODE_INFO",
            Self::AtomGameModeConfiguration => "ATOM_GAME_MODE_CONFIGURATION",
            Self::AtomGameModeListener => "ATOM_GAME_MODE_LISTENER",
            Self::AtomNetworkSliceRequestCount => "ATOM_NETWORK_SLICE_REQUEST_COUNT",
            Self::AtomWsTileSnapshot => "ATOM_WS_TILE_SNAPSHOT",
            Self::AtomWsActiveWatchFaceComplicationSetSnapshot => {
                "ATOM_WS_ACTIVE_WATCH_FACE_COMPLICATION_SET_SNAPSHOT"
            }
            Self::AtomProcessState => "ATOM_PROCESS_STATE",
            Self::AtomProcessAssociation => "ATOM_PROCESS_ASSOCIATION",
            Self::AtomAdpfSystemComponentInfo => "ATOM_ADPF_SYSTEM_COMPONENT_INFO",
            Self::AtomNotificationMemoryUse => "ATOM_NOTIFICATION_MEMORY_USE",
            Self::AtomHdrCapabilities => "ATOM_HDR_CAPABILITIES",
            Self::AtomWsFavouriteWatchFaceListSnapshot => {
                "ATOM_WS_FAVOURITE_WATCH_FACE_LIST_SNAPSHOT"
            }
            Self::AtomWifiAwareNdpReported => "ATOM_WIFI_AWARE_NDP_REPORTED",
            Self::AtomWifiAwareAttachReported => "ATOM_WIFI_AWARE_ATTACH_REPORTED",
            Self::AtomWifiSelfRecoveryTriggered => "ATOM_WIFI_SELF_RECOVERY_TRIGGERED",
            Self::AtomSoftApStarted => "ATOM_SOFT_AP_STARTED",
            Self::AtomSoftApStopped => "ATOM_SOFT_AP_STOPPED",
            Self::AtomWifiLockReleased => "ATOM_WIFI_LOCK_RELEASED",
            Self::AtomWifiLockDeactivated => "ATOM_WIFI_LOCK_DEACTIVATED",
            Self::AtomWifiConfigSaved => "ATOM_WIFI_CONFIG_SAVED",
            Self::AtomWifiAwareResourceUsingChanged => {
                "ATOM_WIFI_AWARE_RESOURCE_USING_CHANGED"
            }
            Self::AtomWifiAwareHalApiCalled => "ATOM_WIFI_AWARE_HAL_API_CALLED",
            Self::AtomWifiLocalOnlyRequestReceived => {
                "ATOM_WIFI_LOCAL_ONLY_REQUEST_RECEIVED"
            }
            Self::AtomWifiLocalOnlyRequestScanTriggered => {
                "ATOM_WIFI_LOCAL_ONLY_REQUEST_SCAN_TRIGGERED"
            }
            Self::AtomWifiThreadTaskExecuted => "ATOM_WIFI_THREAD_TASK_EXECUTED",
            Self::AtomWifiStateChanged => "ATOM_WIFI_STATE_CHANGED",
            Self::AtomWifiAwareCapabilities => "ATOM_WIFI_AWARE_CAPABILITIES",
            Self::AtomWifiModuleInfo => "ATOM_WIFI_MODULE_INFO",
            Self::AtomSettingsSpaReported => "ATOM_SETTINGS_SPA_REPORTED",
            Self::AtomExpressEventReported => "ATOM_EXPRESS_EVENT_REPORTED",
            Self::AtomExpressHistogramSampleReported => {
                "ATOM_EXPRESS_HISTOGRAM_SAMPLE_REPORTED"
            }
            Self::AtomExpressUidEventReported => "ATOM_EXPRESS_UID_EVENT_REPORTED",
            Self::AtomExpressUidHistogramSampleReported => {
                "ATOM_EXPRESS_UID_HISTOGRAM_SAMPLE_REPORTED"
            }
            Self::AtomPermissionRationaleDialogViewed => {
                "ATOM_PERMISSION_RATIONALE_DIALOG_VIEWED"
            }
            Self::AtomPermissionRationaleDialogActionReported => {
                "ATOM_PERMISSION_RATIONALE_DIALOG_ACTION_REPORTED"
            }
            Self::AtomAppDataSharingUpdatesNotificationInteraction => {
                "ATOM_APP_DATA_SHARING_UPDATES_NOTIFICATION_INTERACTION"
            }
            Self::AtomAppDataSharingUpdatesFragmentViewed => {
                "ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_VIEWED"
            }
            Self::AtomAppDataSharingUpdatesFragmentActionReported => {
                "ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_ACTION_REPORTED"
            }
            Self::AtomWsIncomingCallActionReported => {
                "ATOM_WS_INCOMING_CALL_ACTION_REPORTED"
            }
            Self::AtomWsCallDisconnectionReported => {
                "ATOM_WS_CALL_DISCONNECTION_REPORTED"
            }
            Self::AtomWsCallDurationReported => "ATOM_WS_CALL_DURATION_REPORTED",
            Self::AtomWsCallUserExperienceLatencyReported => {
                "ATOM_WS_CALL_USER_EXPERIENCE_LATENCY_REPORTED"
            }
            Self::AtomWsCallInteractionReported => "ATOM_WS_CALL_INTERACTION_REPORTED",
            Self::AtomFullScreenIntentLaunched => "ATOM_FULL_SCREEN_INTENT_LAUNCHED",
            Self::AtomBalAllowed => "ATOM_BAL_ALLOWED",
            Self::AtomInTaskActivityStarted => "ATOM_IN_TASK_ACTIVITY_STARTED",
            Self::AtomCachedAppsHighWatermark => "ATOM_CACHED_APPS_HIGH_WATERMARK",
            Self::AtomOdrefreshReported => "ATOM_ODREFRESH_REPORTED",
            Self::AtomOdsignReported => "ATOM_ODSIGN_REPORTED",
            Self::AtomArtDatumReported => "ATOM_ART_DATUM_REPORTED",
            Self::AtomArtDeviceDatumReported => "ATOM_ART_DEVICE_DATUM_REPORTED",
            Self::AtomArtDatumDeltaReported => "ATOM_ART_DATUM_DELTA_REPORTED",
            Self::AtomBackgroundDexoptJobEnded => "ATOM_BACKGROUND_DEXOPT_JOB_ENDED",
            Self::AtomWearAdaptiveSuspendStatsReported => {
                "ATOM_WEAR_ADAPTIVE_SUSPEND_STATS_REPORTED"
            }
            Self::AtomWearPowerAnomalyServiceOperationalStatsReported => {
                "ATOM_WEAR_POWER_ANOMALY_SERVICE_OPERATIONAL_STATS_REPORTED"
            }
            Self::AtomWearPowerAnomalyServiceEventStatsReported => {
                "ATOM_WEAR_POWER_ANOMALY_SERVICE_EVENT_STATS_REPORTED"
            }
            Self::AtomEmergencyStateChanged => "ATOM_EMERGENCY_STATE_CHANGED",
            Self::AtomDndStateChanged => "ATOM_DND_STATE_CHANGED",
            Self::AtomMteState => "ATOM_MTE_STATE",
            Self::AtomAdServicesBackCompatGetTopicsReported => {
                "ATOM_AD_SERVICES_BACK_COMPAT_GET_TOPICS_REPORTED"
            }
            Self::AtomAdServicesBackCompatEpochComputationClassifierReported => {
                "ATOM_AD_SERVICES_BACK_COMPAT_EPOCH_COMPUTATION_CLASSIFIER_REPORTED"
            }
            Self::AtomAdServicesMeasurementDebugKeys => {
                "ATOM_AD_SERVICES_MEASUREMENT_DEBUG_KEYS"
            }
            Self::AtomAdServicesErrorReported => "ATOM_AD_SERVICES_ERROR_REPORTED",
            Self::AtomAdServicesBackgroundJobsExecutionReported => {
                "ATOM_AD_SERVICES_BACKGROUND_JOBS_EXECUTION_REPORTED"
            }
            Self::AtomAdServicesMeasurementDelayedSourceRegistration => {
                "ATOM_AD_SERVICES_MEASUREMENT_DELAYED_SOURCE_REGISTRATION"
            }
            Self::AtomAdServicesMeasurementAttribution => {
                "ATOM_AD_SERVICES_MEASUREMENT_ATTRIBUTION"
            }
            Self::AtomAdServicesMeasurementJobs => "ATOM_AD_SERVICES_MEASUREMENT_JOBS",
            Self::AtomAdServicesMeasurementWipeout => {
                "ATOM_AD_SERVICES_MEASUREMENT_WIPEOUT"
            }
            Self::AtomAdServicesConsentMigrated => "ATOM_AD_SERVICES_CONSENT_MIGRATED",
            Self::AtomRkpdPoolStats => "ATOM_RKPD_POOL_STATS",
            Self::AtomRkpdClientOperation => "ATOM_RKPD_CLIENT_OPERATION",
            Self::AtomAutofillUiEventReported => "ATOM_AUTOFILL_UI_EVENT_REPORTED",
            Self::AtomAutofillFillRequestReported => {
                "ATOM_AUTOFILL_FILL_REQUEST_REPORTED"
            }
            Self::AtomAutofillFillResponseReported => {
                "ATOM_AUTOFILL_FILL_RESPONSE_REPORTED"
            }
            Self::AtomAutofillSaveEventReported => "ATOM_AUTOFILL_SAVE_EVENT_REPORTED",
            Self::AtomAutofillSessionCommitted => "ATOM_AUTOFILL_SESSION_COMMITTED",
            Self::AtomAutofillFieldClassificationEventReported => {
                "ATOM_AUTOFILL_FIELD_CLASSIFICATION_EVENT_REPORTED"
            }
            Self::AtomTestExtensionAtomReported => "ATOM_TEST_EXTENSION_ATOM_REPORTED",
            Self::AtomTestRestrictedAtomReported => "ATOM_TEST_RESTRICTED_ATOM_REPORTED",
            Self::AtomStatsSocketLossReported => "ATOM_STATS_SOCKET_LOSS_REPORTED",
            Self::AtomPluginInitialized => "ATOM_PLUGIN_INITIALIZED",
            Self::AtomTvLowPowerStandbyPolicy => "ATOM_TV_LOW_POWER_STANDBY_POLICY",
            Self::AtomLockscreenShortcutSelected => "ATOM_LOCKSCREEN_SHORTCUT_SELECTED",
            Self::AtomLockscreenShortcutTriggered => "ATOM_LOCKSCREEN_SHORTCUT_TRIGGERED",
            Self::AtomEmergencyNumbersInfo => "ATOM_EMERGENCY_NUMBERS_INFO",
            Self::AtomQualifiedRatListChanged => "ATOM_QUALIFIED_RAT_LIST_CHANGED",
            Self::AtomQnsImsCallDropStats => "ATOM_QNS_IMS_CALL_DROP_STATS",
            Self::AtomQnsFallbackRestrictionChanged => {
                "ATOM_QNS_FALLBACK_RESTRICTION_CHANGED"
            }
            Self::AtomQnsRatPreferenceMismatchInfo => {
                "ATOM_QNS_RAT_PREFERENCE_MISMATCH_INFO"
            }
            Self::AtomQnsHandoverTimeMillis => "ATOM_QNS_HANDOVER_TIME_MILLIS",
            Self::AtomQnsHandoverPingpong => "ATOM_QNS_HANDOVER_PINGPONG",
            Self::AtomSatelliteController => "ATOM_SATELLITE_CONTROLLER",
            Self::AtomSatelliteSession => "ATOM_SATELLITE_SESSION",
            Self::AtomSatelliteIncomingDatagram => "ATOM_SATELLITE_INCOMING_DATAGRAM",
            Self::AtomSatelliteOutgoingDatagram => "ATOM_SATELLITE_OUTGOING_DATAGRAM",
            Self::AtomSatelliteProvision => "ATOM_SATELLITE_PROVISION",
            Self::AtomSatelliteSosMessageRecommender => {
                "ATOM_SATELLITE_SOS_MESSAGE_RECOMMENDER"
            }
            Self::AtomIkeSessionTerminated => "ATOM_IKE_SESSION_TERMINATED",
            Self::AtomIkeLivenessCheckSessionValidated => {
                "ATOM_IKE_LIVENESS_CHECK_SESSION_VALIDATED"
            }
            Self::AtomBluetoothHashedDeviceNameReported => {
                "ATOM_BLUETOOTH_HASHED_DEVICE_NAME_REPORTED"
            }
            Self::AtomBluetoothL2capCocClientConnection => {
                "ATOM_BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION"
            }
            Self::AtomBluetoothL2capCocServerConnection => {
                "ATOM_BLUETOOTH_L2CAP_COC_SERVER_CONNECTION"
            }
            Self::AtomBluetoothLeSessionConnected => {
                "ATOM_BLUETOOTH_LE_SESSION_CONNECTED"
            }
            Self::AtomRestrictedBluetoothDeviceNameReported => {
                "ATOM_RESTRICTED_BLUETOOTH_DEVICE_NAME_REPORTED"
            }
            Self::AtomBluetoothProfileConnectionAttempted => {
                "ATOM_BLUETOOTH_PROFILE_CONNECTION_ATTEMPTED"
            }
            Self::AtomHealthConnectUiImpression => "ATOM_HEALTH_CONNECT_UI_IMPRESSION",
            Self::AtomHealthConnectUiInteraction => "ATOM_HEALTH_CONNECT_UI_INTERACTION",
            Self::AtomHealthConnectAppOpenedReported => {
                "ATOM_HEALTH_CONNECT_APP_OPENED_REPORTED"
            }
            Self::AtomHealthConnectApiCalled => "ATOM_HEALTH_CONNECT_API_CALLED",
            Self::AtomHealthConnectUsageStats => "ATOM_HEALTH_CONNECT_USAGE_STATS",
            Self::AtomHealthConnectStorageStats => "ATOM_HEALTH_CONNECT_STORAGE_STATS",
            Self::AtomHealthConnectApiInvoked => "ATOM_HEALTH_CONNECT_API_INVOKED",
            Self::AtomExerciseRouteApiCalled => "ATOM_EXERCISE_ROUTE_API_CALLED",
            Self::AtomAtom9999 => "ATOM_ATOM_9999",
            Self::AtomAtom99999 => "ATOM_ATOM_99999",
            Self::AtomThreadnetworkTelemetryDataReported => {
                "ATOM_THREADNETWORK_TELEMETRY_DATA_REPORTED"
            }
            Self::AtomThreadnetworkTopoEntryRepeated => {
                "ATOM_THREADNETWORK_TOPO_ENTRY_REPEATED"
            }
            Self::AtomThreadnetworkDeviceInfoReported => {
                "ATOM_THREADNETWORK_DEVICE_INFO_REPORTED"
            }
            Self::AtomEmergencyNumberDialed => "ATOM_EMERGENCY_NUMBER_DIALED",
            Self::AtomSandboxApiCalled => "ATOM_SANDBOX_API_CALLED",
            Self::AtomSandboxActivityEventOccurred => {
                "ATOM_SANDBOX_ACTIVITY_EVENT_OCCURRED"
            }
            Self::AtomSandboxSdkStorage => "ATOM_SANDBOX_SDK_STORAGE",
            Self::AtomCronetEngineCreated => "ATOM_CRONET_ENGINE_CREATED",
            Self::AtomCronetTrafficReported => "ATOM_CRONET_TRAFFIC_REPORTED",
            Self::AtomCronetEngineBuilderInitialized => {
                "ATOM_CRONET_ENGINE_BUILDER_INITIALIZED"
            }
            Self::AtomCronetHttpFlagsInitialized => "ATOM_CRONET_HTTP_FLAGS_INITIALIZED",
            Self::AtomCronetInitialized => "ATOM_CRONET_INITIALIZED",
            Self::AtomDailyKeepaliveInfoReported => "ATOM_DAILY_KEEPALIVE_INFO_REPORTED",
            Self::AtomIpClientRaInfoReported => "ATOM_IP_CLIENT_RA_INFO_REPORTED",
            Self::AtomApfSessionInfoReported => "ATOM_APF_SESSION_INFO_REPORTED",
            Self::AtomCredentialManagerApiCalled => "ATOM_CREDENTIAL_MANAGER_API_CALLED",
            Self::AtomCredentialManagerInitPhaseReported => {
                "ATOM_CREDENTIAL_MANAGER_INIT_PHASE_REPORTED"
            }
            Self::AtomCredentialManagerCandidatePhaseReported => {
                "ATOM_CREDENTIAL_MANAGER_CANDIDATE_PHASE_REPORTED"
            }
            Self::AtomCredentialManagerFinalPhaseReported => {
                "ATOM_CREDENTIAL_MANAGER_FINAL_PHASE_REPORTED"
            }
            Self::AtomCredentialManagerTotalReported => {
                "ATOM_CREDENTIAL_MANAGER_TOTAL_REPORTED"
            }
            Self::AtomCredentialManagerFinalnouidReported => {
                "ATOM_CREDENTIAL_MANAGER_FINALNOUID_REPORTED"
            }
            Self::AtomCredentialManagerGetReported => {
                "ATOM_CREDENTIAL_MANAGER_GET_REPORTED"
            }
            Self::AtomCredentialManagerAuthClickReported => {
                "ATOM_CREDENTIAL_MANAGER_AUTH_CLICK_REPORTED"
            }
            Self::AtomCredentialManagerApiv2Called => {
                "ATOM_CREDENTIAL_MANAGER_APIV2_CALLED"
            }
            Self::AtomUwbActivityInfo => "ATOM_UWB_ACTIVITY_INFO",
            Self::AtomMediaActionReported => "ATOM_MEDIA_ACTION_REPORTED",
            Self::AtomMediaControlsLaunched => "ATOM_MEDIA_CONTROLS_LAUNCHED",
            Self::AtomMediaCodecReclaimRequestCompleted => {
                "ATOM_MEDIA_CODEC_RECLAIM_REQUEST_COMPLETED"
            }
            Self::AtomMediaCodecStarted => "ATOM_MEDIA_CODEC_STARTED",
            Self::AtomMediaCodecStopped => "ATOM_MEDIA_CODEC_STOPPED",
            Self::AtomMediaCodecRendered => "ATOM_MEDIA_CODEC_RENDERED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ATOM_UNSPECIFIED" => Some(Self::AtomUnspecified),
            "ATOM_BLE_SCAN_STATE_CHANGED" => Some(Self::AtomBleScanStateChanged),
            "ATOM_PROCESS_STATE_CHANGED" => Some(Self::AtomProcessStateChanged),
            "ATOM_BLE_SCAN_RESULT_RECEIVED" => Some(Self::AtomBleScanResultReceived),
            "ATOM_SENSOR_STATE_CHANGED" => Some(Self::AtomSensorStateChanged),
            "ATOM_GPS_SCAN_STATE_CHANGED" => Some(Self::AtomGpsScanStateChanged),
            "ATOM_SYNC_STATE_CHANGED" => Some(Self::AtomSyncStateChanged),
            "ATOM_SCHEDULED_JOB_STATE_CHANGED" => {
                Some(Self::AtomScheduledJobStateChanged)
            }
            "ATOM_SCREEN_BRIGHTNESS_CHANGED" => Some(Self::AtomScreenBrightnessChanged),
            "ATOM_WAKELOCK_STATE_CHANGED" => Some(Self::AtomWakelockStateChanged),
            "ATOM_LONG_PARTIAL_WAKELOCK_STATE_CHANGED" => {
                Some(Self::AtomLongPartialWakelockStateChanged)
            }
            "ATOM_MOBILE_RADIO_POWER_STATE_CHANGED" => {
                Some(Self::AtomMobileRadioPowerStateChanged)
            }
            "ATOM_WIFI_RADIO_POWER_STATE_CHANGED" => {
                Some(Self::AtomWifiRadioPowerStateChanged)
            }
            "ATOM_ACTIVITY_MANAGER_SLEEP_STATE_CHANGED" => {
                Some(Self::AtomActivityManagerSleepStateChanged)
            }
            "ATOM_MEMORY_FACTOR_STATE_CHANGED" => {
                Some(Self::AtomMemoryFactorStateChanged)
            }
            "ATOM_EXCESSIVE_CPU_USAGE_REPORTED" => {
                Some(Self::AtomExcessiveCpuUsageReported)
            }
            "ATOM_CACHED_KILL_REPORTED" => Some(Self::AtomCachedKillReported),
            "ATOM_PROCESS_MEMORY_STAT_REPORTED" => {
                Some(Self::AtomProcessMemoryStatReported)
            }
            "ATOM_LAUNCHER_EVENT" => Some(Self::AtomLauncherEvent),
            "ATOM_BATTERY_SAVER_MODE_STATE_CHANGED" => {
                Some(Self::AtomBatterySaverModeStateChanged)
            }
            "ATOM_DEVICE_IDLE_MODE_STATE_CHANGED" => {
                Some(Self::AtomDeviceIdleModeStateChanged)
            }
            "ATOM_DEVICE_IDLING_MODE_STATE_CHANGED" => {
                Some(Self::AtomDeviceIdlingModeStateChanged)
            }
            "ATOM_AUDIO_STATE_CHANGED" => Some(Self::AtomAudioStateChanged),
            "ATOM_MEDIA_CODEC_STATE_CHANGED" => Some(Self::AtomMediaCodecStateChanged),
            "ATOM_CAMERA_STATE_CHANGED" => Some(Self::AtomCameraStateChanged),
            "ATOM_FLASHLIGHT_STATE_CHANGED" => Some(Self::AtomFlashlightStateChanged),
            "ATOM_UID_PROCESS_STATE_CHANGED" => Some(Self::AtomUidProcessStateChanged),
            "ATOM_PROCESS_LIFE_CYCLE_STATE_CHANGED" => {
                Some(Self::AtomProcessLifeCycleStateChanged)
            }
            "ATOM_SCREEN_STATE_CHANGED" => Some(Self::AtomScreenStateChanged),
            "ATOM_BATTERY_LEVEL_CHANGED" => Some(Self::AtomBatteryLevelChanged),
            "ATOM_CHARGING_STATE_CHANGED" => Some(Self::AtomChargingStateChanged),
            "ATOM_PLUGGED_STATE_CHANGED" => Some(Self::AtomPluggedStateChanged),
            "ATOM_INTERACTIVE_STATE_CHANGED" => Some(Self::AtomInteractiveStateChanged),
            "ATOM_TOUCH_EVENT_REPORTED" => Some(Self::AtomTouchEventReported),
            "ATOM_WAKEUP_ALARM_OCCURRED" => Some(Self::AtomWakeupAlarmOccurred),
            "ATOM_KERNEL_WAKEUP_REPORTED" => Some(Self::AtomKernelWakeupReported),
            "ATOM_WIFI_LOCK_STATE_CHANGED" => Some(Self::AtomWifiLockStateChanged),
            "ATOM_WIFI_SIGNAL_STRENGTH_CHANGED" => {
                Some(Self::AtomWifiSignalStrengthChanged)
            }
            "ATOM_WIFI_SCAN_STATE_CHANGED" => Some(Self::AtomWifiScanStateChanged),
            "ATOM_PHONE_SIGNAL_STRENGTH_CHANGED" => {
                Some(Self::AtomPhoneSignalStrengthChanged)
            }
            "ATOM_SETTING_CHANGED" => Some(Self::AtomSettingChanged),
            "ATOM_ACTIVITY_FOREGROUND_STATE_CHANGED" => {
                Some(Self::AtomActivityForegroundStateChanged)
            }
            "ATOM_ISOLATED_UID_CHANGED" => Some(Self::AtomIsolatedUidChanged),
            "ATOM_PACKET_WAKEUP_OCCURRED" => Some(Self::AtomPacketWakeupOccurred),
            "ATOM_WALL_CLOCK_TIME_SHIFTED" => Some(Self::AtomWallClockTimeShifted),
            "ATOM_ANOMALY_DETECTED" => Some(Self::AtomAnomalyDetected),
            "ATOM_APP_BREADCRUMB_REPORTED" => Some(Self::AtomAppBreadcrumbReported),
            "ATOM_APP_START_OCCURRED" => Some(Self::AtomAppStartOccurred),
            "ATOM_APP_START_CANCELED" => Some(Self::AtomAppStartCanceled),
            "ATOM_APP_START_FULLY_DRAWN" => Some(Self::AtomAppStartFullyDrawn),
            "ATOM_LMK_KILL_OCCURRED" => Some(Self::AtomLmkKillOccurred),
            "ATOM_PICTURE_IN_PICTURE_STATE_CHANGED" => {
                Some(Self::AtomPictureInPictureStateChanged)
            }
            "ATOM_WIFI_MULTICAST_LOCK_STATE_CHANGED" => {
                Some(Self::AtomWifiMulticastLockStateChanged)
            }
            "ATOM_LMK_STATE_CHANGED" => Some(Self::AtomLmkStateChanged),
            "ATOM_APP_START_MEMORY_STATE_CAPTURED" => {
                Some(Self::AtomAppStartMemoryStateCaptured)
            }
            "ATOM_SHUTDOWN_SEQUENCE_REPORTED" => Some(Self::AtomShutdownSequenceReported),
            "ATOM_BOOT_SEQUENCE_REPORTED" => Some(Self::AtomBootSequenceReported),
            "ATOM_DAVEY_OCCURRED" => Some(Self::AtomDaveyOccurred),
            "ATOM_OVERLAY_STATE_CHANGED" => Some(Self::AtomOverlayStateChanged),
            "ATOM_FOREGROUND_SERVICE_STATE_CHANGED" => {
                Some(Self::AtomForegroundServiceStateChanged)
            }
            "ATOM_CALL_STATE_CHANGED" => Some(Self::AtomCallStateChanged),
            "ATOM_KEYGUARD_STATE_CHANGED" => Some(Self::AtomKeyguardStateChanged),
            "ATOM_KEYGUARD_BOUNCER_STATE_CHANGED" => {
                Some(Self::AtomKeyguardBouncerStateChanged)
            }
            "ATOM_KEYGUARD_BOUNCER_PASSWORD_ENTERED" => {
                Some(Self::AtomKeyguardBouncerPasswordEntered)
            }
            "ATOM_APP_DIED" => Some(Self::AtomAppDied),
            "ATOM_RESOURCE_CONFIGURATION_CHANGED" => {
                Some(Self::AtomResourceConfigurationChanged)
            }
            "ATOM_BLUETOOTH_ENABLED_STATE_CHANGED" => {
                Some(Self::AtomBluetoothEnabledStateChanged)
            }
            "ATOM_BLUETOOTH_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomBluetoothConnectionStateChanged)
            }
            "ATOM_GPS_SIGNAL_QUALITY_CHANGED" => Some(Self::AtomGpsSignalQualityChanged),
            "ATOM_USB_CONNECTOR_STATE_CHANGED" => {
                Some(Self::AtomUsbConnectorStateChanged)
            }
            "ATOM_SPEAKER_IMPEDANCE_REPORTED" => Some(Self::AtomSpeakerImpedanceReported),
            "ATOM_HARDWARE_FAILED" => Some(Self::AtomHardwareFailed),
            "ATOM_PHYSICAL_DROP_DETECTED" => Some(Self::AtomPhysicalDropDetected),
            "ATOM_CHARGE_CYCLES_REPORTED" => Some(Self::AtomChargeCyclesReported),
            "ATOM_MOBILE_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomMobileConnectionStateChanged)
            }
            "ATOM_MOBILE_RADIO_TECHNOLOGY_CHANGED" => {
                Some(Self::AtomMobileRadioTechnologyChanged)
            }
            "ATOM_USB_DEVICE_ATTACHED" => Some(Self::AtomUsbDeviceAttached),
            "ATOM_APP_CRASH_OCCURRED" => Some(Self::AtomAppCrashOccurred),
            "ATOM_ANR_OCCURRED" => Some(Self::AtomAnrOccurred),
            "ATOM_WTF_OCCURRED" => Some(Self::AtomWtfOccurred),
            "ATOM_LOW_MEM_REPORTED" => Some(Self::AtomLowMemReported),
            "ATOM_GENERIC_ATOM" => Some(Self::AtomGenericAtom),
            "ATOM_VIBRATOR_STATE_CHANGED" => Some(Self::AtomVibratorStateChanged),
            "ATOM_DEFERRED_JOB_STATS_REPORTED" => {
                Some(Self::AtomDeferredJobStatsReported)
            }
            "ATOM_THERMAL_THROTTLING" => Some(Self::AtomThermalThrottling),
            "ATOM_BIOMETRIC_ACQUIRED" => Some(Self::AtomBiometricAcquired),
            "ATOM_BIOMETRIC_AUTHENTICATED" => Some(Self::AtomBiometricAuthenticated),
            "ATOM_BIOMETRIC_ERROR_OCCURRED" => Some(Self::AtomBiometricErrorOccurred),
            "ATOM_UI_EVENT_REPORTED" => Some(Self::AtomUiEventReported),
            "ATOM_BATTERY_HEALTH_SNAPSHOT" => Some(Self::AtomBatteryHealthSnapshot),
            "ATOM_SLOW_IO" => Some(Self::AtomSlowIo),
            "ATOM_BATTERY_CAUSED_SHUTDOWN" => Some(Self::AtomBatteryCausedShutdown),
            "ATOM_PHONE_SERVICE_STATE_CHANGED" => {
                Some(Self::AtomPhoneServiceStateChanged)
            }
            "ATOM_PHONE_STATE_CHANGED" => Some(Self::AtomPhoneStateChanged),
            "ATOM_USER_RESTRICTION_CHANGED" => Some(Self::AtomUserRestrictionChanged),
            "ATOM_SETTINGS_UI_CHANGED" => Some(Self::AtomSettingsUiChanged),
            "ATOM_CONNECTIVITY_STATE_CHANGED" => Some(Self::AtomConnectivityStateChanged),
            "ATOM_SERVICE_STATE_CHANGED" => Some(Self::AtomServiceStateChanged),
            "ATOM_SERVICE_LAUNCH_REPORTED" => Some(Self::AtomServiceLaunchReported),
            "ATOM_FLAG_FLIP_UPDATE_OCCURRED" => Some(Self::AtomFlagFlipUpdateOccurred),
            "ATOM_BINARY_PUSH_STATE_CHANGED" => Some(Self::AtomBinaryPushStateChanged),
            "ATOM_DEVICE_POLICY_EVENT" => Some(Self::AtomDevicePolicyEvent),
            "ATOM_DOCS_UI_FILE_OP_CANCELED" => Some(Self::AtomDocsUiFileOpCanceled),
            "ATOM_DOCS_UI_FILE_OP_COPY_MOVE_MODE_REPORTED" => {
                Some(Self::AtomDocsUiFileOpCopyMoveModeReported)
            }
            "ATOM_DOCS_UI_FILE_OP_FAILURE" => Some(Self::AtomDocsUiFileOpFailure),
            "ATOM_DOCS_UI_PROVIDER_FILE_OP" => Some(Self::AtomDocsUiProviderFileOp),
            "ATOM_DOCS_UI_INVALID_SCOPED_ACCESS_REQUEST" => {
                Some(Self::AtomDocsUiInvalidScopedAccessRequest)
            }
            "ATOM_DOCS_UI_LAUNCH_REPORTED" => Some(Self::AtomDocsUiLaunchReported),
            "ATOM_DOCS_UI_ROOT_VISITED" => Some(Self::AtomDocsUiRootVisited),
            "ATOM_DOCS_UI_STARTUP_MS" => Some(Self::AtomDocsUiStartupMs),
            "ATOM_DOCS_UI_USER_ACTION_REPORTED" => {
                Some(Self::AtomDocsUiUserActionReported)
            }
            "ATOM_WIFI_ENABLED_STATE_CHANGED" => Some(Self::AtomWifiEnabledStateChanged),
            "ATOM_WIFI_RUNNING_STATE_CHANGED" => Some(Self::AtomWifiRunningStateChanged),
            "ATOM_APP_COMPACTED" => Some(Self::AtomAppCompacted),
            "ATOM_NETWORK_DNS_EVENT_REPORTED" => Some(Self::AtomNetworkDnsEventReported),
            "ATOM_DOCS_UI_PICKER_LAUNCHED_FROM_REPORTED" => {
                Some(Self::AtomDocsUiPickerLaunchedFromReported)
            }
            "ATOM_DOCS_UI_PICK_RESULT_REPORTED" => {
                Some(Self::AtomDocsUiPickResultReported)
            }
            "ATOM_DOCS_UI_SEARCH_MODE_REPORTED" => {
                Some(Self::AtomDocsUiSearchModeReported)
            }
            "ATOM_DOCS_UI_SEARCH_TYPE_REPORTED" => {
                Some(Self::AtomDocsUiSearchTypeReported)
            }
            "ATOM_DATA_STALL_EVENT" => Some(Self::AtomDataStallEvent),
            "ATOM_RESCUE_PARTY_RESET_REPORTED" => {
                Some(Self::AtomRescuePartyResetReported)
            }
            "ATOM_SIGNED_CONFIG_REPORTED" => Some(Self::AtomSignedConfigReported),
            "ATOM_GNSS_NI_EVENT_REPORTED" => Some(Self::AtomGnssNiEventReported),
            "ATOM_BLUETOOTH_LINK_LAYER_CONNECTION_EVENT" => {
                Some(Self::AtomBluetoothLinkLayerConnectionEvent)
            }
            "ATOM_BLUETOOTH_ACL_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomBluetoothAclConnectionStateChanged)
            }
            "ATOM_BLUETOOTH_SCO_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomBluetoothScoConnectionStateChanged)
            }
            "ATOM_APP_DOWNGRADED" => Some(Self::AtomAppDowngraded),
            "ATOM_APP_OPTIMIZED_AFTER_DOWNGRADED" => {
                Some(Self::AtomAppOptimizedAfterDowngraded)
            }
            "ATOM_LOW_STORAGE_STATE_CHANGED" => Some(Self::AtomLowStorageStateChanged),
            "ATOM_GNSS_NFW_NOTIFICATION_REPORTED" => {
                Some(Self::AtomGnssNfwNotificationReported)
            }
            "ATOM_GNSS_CONFIGURATION_REPORTED" => {
                Some(Self::AtomGnssConfigurationReported)
            }
            "ATOM_USB_PORT_OVERHEAT_EVENT_REPORTED" => {
                Some(Self::AtomUsbPortOverheatEventReported)
            }
            "ATOM_NFC_ERROR_OCCURRED" => Some(Self::AtomNfcErrorOccurred),
            "ATOM_NFC_STATE_CHANGED" => Some(Self::AtomNfcStateChanged),
            "ATOM_NFC_BEAM_OCCURRED" => Some(Self::AtomNfcBeamOccurred),
            "ATOM_NFC_CARDEMULATION_OCCURRED" => Some(Self::AtomNfcCardemulationOccurred),
            "ATOM_NFC_TAG_OCCURRED" => Some(Self::AtomNfcTagOccurred),
            "ATOM_NFC_HCE_TRANSACTION_OCCURRED" => {
                Some(Self::AtomNfcHceTransactionOccurred)
            }
            "ATOM_SE_STATE_CHANGED" => Some(Self::AtomSeStateChanged),
            "ATOM_SE_OMAPI_REPORTED" => Some(Self::AtomSeOmapiReported),
            "ATOM_BROADCAST_DISPATCH_LATENCY_REPORTED" => {
                Some(Self::AtomBroadcastDispatchLatencyReported)
            }
            "ATOM_ATTENTION_MANAGER_SERVICE_RESULT_REPORTED" => {
                Some(Self::AtomAttentionManagerServiceResultReported)
            }
            "ATOM_ADB_CONNECTION_CHANGED" => Some(Self::AtomAdbConnectionChanged),
            "ATOM_SPEECH_DSP_STAT_REPORTED" => Some(Self::AtomSpeechDspStatReported),
            "ATOM_USB_CONTAMINANT_REPORTED" => Some(Self::AtomUsbContaminantReported),
            "ATOM_WATCHDOG_ROLLBACK_OCCURRED" => Some(Self::AtomWatchdogRollbackOccurred),
            "ATOM_BIOMETRIC_SYSTEM_HEALTH_ISSUE_DETECTED" => {
                Some(Self::AtomBiometricSystemHealthIssueDetected)
            }
            "ATOM_BUBBLE_UI_CHANGED" => Some(Self::AtomBubbleUiChanged),
            "ATOM_SCHEDULED_JOB_CONSTRAINT_CHANGED" => {
                Some(Self::AtomScheduledJobConstraintChanged)
            }
            "ATOM_BLUETOOTH_ACTIVE_DEVICE_CHANGED" => {
                Some(Self::AtomBluetoothActiveDeviceChanged)
            }
            "ATOM_BLUETOOTH_A2DP_PLAYBACK_STATE_CHANGED" => {
                Some(Self::AtomBluetoothA2dpPlaybackStateChanged)
            }
            "ATOM_BLUETOOTH_A2DP_CODEC_CONFIG_CHANGED" => {
                Some(Self::AtomBluetoothA2dpCodecConfigChanged)
            }
            "ATOM_BLUETOOTH_A2DP_CODEC_CAPABILITY_CHANGED" => {
                Some(Self::AtomBluetoothA2dpCodecCapabilityChanged)
            }
            "ATOM_BLUETOOTH_A2DP_AUDIO_UNDERRUN_REPORTED" => {
                Some(Self::AtomBluetoothA2dpAudioUnderrunReported)
            }
            "ATOM_BLUETOOTH_A2DP_AUDIO_OVERRUN_REPORTED" => {
                Some(Self::AtomBluetoothA2dpAudioOverrunReported)
            }
            "ATOM_BLUETOOTH_DEVICE_RSSI_REPORTED" => {
                Some(Self::AtomBluetoothDeviceRssiReported)
            }
            "ATOM_BLUETOOTH_DEVICE_FAILED_CONTACT_COUNTER_REPORTED" => {
                Some(Self::AtomBluetoothDeviceFailedContactCounterReported)
            }
            "ATOM_BLUETOOTH_DEVICE_TX_POWER_LEVEL_REPORTED" => {
                Some(Self::AtomBluetoothDeviceTxPowerLevelReported)
            }
            "ATOM_BLUETOOTH_HCI_TIMEOUT_REPORTED" => {
                Some(Self::AtomBluetoothHciTimeoutReported)
            }
            "ATOM_BLUETOOTH_QUALITY_REPORT_REPORTED" => {
                Some(Self::AtomBluetoothQualityReportReported)
            }
            "ATOM_BLUETOOTH_DEVICE_INFO_REPORTED" => {
                Some(Self::AtomBluetoothDeviceInfoReported)
            }
            "ATOM_BLUETOOTH_REMOTE_VERSION_INFO_REPORTED" => {
                Some(Self::AtomBluetoothRemoteVersionInfoReported)
            }
            "ATOM_BLUETOOTH_SDP_ATTRIBUTE_REPORTED" => {
                Some(Self::AtomBluetoothSdpAttributeReported)
            }
            "ATOM_BLUETOOTH_BOND_STATE_CHANGED" => {
                Some(Self::AtomBluetoothBondStateChanged)
            }
            "ATOM_BLUETOOTH_CLASSIC_PAIRING_EVENT_REPORTED" => {
                Some(Self::AtomBluetoothClassicPairingEventReported)
            }
            "ATOM_BLUETOOTH_SMP_PAIRING_EVENT_REPORTED" => {
                Some(Self::AtomBluetoothSmpPairingEventReported)
            }
            "ATOM_SCREEN_TIMEOUT_EXTENSION_REPORTED" => {
                Some(Self::AtomScreenTimeoutExtensionReported)
            }
            "ATOM_PROCESS_START_TIME" => Some(Self::AtomProcessStartTime),
            "ATOM_PERMISSION_GRANT_REQUEST_RESULT_REPORTED" => {
                Some(Self::AtomPermissionGrantRequestResultReported)
            }
            "ATOM_BLUETOOTH_SOCKET_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomBluetoothSocketConnectionStateChanged)
            }
            "ATOM_DEVICE_IDENTIFIER_ACCESS_DENIED" => {
                Some(Self::AtomDeviceIdentifierAccessDenied)
            }
            "ATOM_BUBBLE_DEVELOPER_ERROR_REPORTED" => {
                Some(Self::AtomBubbleDeveloperErrorReported)
            }
            "ATOM_ASSIST_GESTURE_STAGE_REPORTED" => {
                Some(Self::AtomAssistGestureStageReported)
            }
            "ATOM_ASSIST_GESTURE_FEEDBACK_REPORTED" => {
                Some(Self::AtomAssistGestureFeedbackReported)
            }
            "ATOM_ASSIST_GESTURE_PROGRESS_REPORTED" => {
                Some(Self::AtomAssistGestureProgressReported)
            }
            "ATOM_TOUCH_GESTURE_CLASSIFIED" => Some(Self::AtomTouchGestureClassified),
            "ATOM_HIDDEN_API_USED" => Some(Self::AtomHiddenApiUsed),
            "ATOM_STYLE_UI_CHANGED" => Some(Self::AtomStyleUiChanged),
            "ATOM_PRIVACY_INDICATORS_INTERACTED" => {
                Some(Self::AtomPrivacyIndicatorsInteracted)
            }
            "ATOM_APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED" => {
                Some(Self::AtomAppInstallOnExternalStorageReported)
            }
            "ATOM_NETWORK_STACK_REPORTED" => Some(Self::AtomNetworkStackReported),
            "ATOM_APP_MOVED_STORAGE_REPORTED" => Some(Self::AtomAppMovedStorageReported),
            "ATOM_BIOMETRIC_ENROLLED" => Some(Self::AtomBiometricEnrolled),
            "ATOM_SYSTEM_SERVER_WATCHDOG_OCCURRED" => {
                Some(Self::AtomSystemServerWatchdogOccurred)
            }
            "ATOM_TOMB_STONE_OCCURRED" => Some(Self::AtomTombStoneOccurred),
            "ATOM_BLUETOOTH_CLASS_OF_DEVICE_REPORTED" => {
                Some(Self::AtomBluetoothClassOfDeviceReported)
            }
            "ATOM_INTELLIGENCE_EVENT_REPORTED" => {
                Some(Self::AtomIntelligenceEventReported)
            }
            "ATOM_THERMAL_THROTTLING_SEVERITY_STATE_CHANGED" => {
                Some(Self::AtomThermalThrottlingSeverityStateChanged)
            }
            "ATOM_ROLE_REQUEST_RESULT_REPORTED" => {
                Some(Self::AtomRoleRequestResultReported)
            }
            "ATOM_MEDIAMETRICS_AUDIOPOLICY_REPORTED" => {
                Some(Self::AtomMediametricsAudiopolicyReported)
            }
            "ATOM_MEDIAMETRICS_AUDIORECORD_REPORTED" => {
                Some(Self::AtomMediametricsAudiorecordReported)
            }
            "ATOM_MEDIAMETRICS_AUDIOTHREAD_REPORTED" => {
                Some(Self::AtomMediametricsAudiothreadReported)
            }
            "ATOM_MEDIAMETRICS_AUDIOTRACK_REPORTED" => {
                Some(Self::AtomMediametricsAudiotrackReported)
            }
            "ATOM_MEDIAMETRICS_CODEC_REPORTED" => {
                Some(Self::AtomMediametricsCodecReported)
            }
            "ATOM_MEDIAMETRICS_DRM_WIDEVINE_REPORTED" => {
                Some(Self::AtomMediametricsDrmWidevineReported)
            }
            "ATOM_MEDIAMETRICS_EXTRACTOR_REPORTED" => {
                Some(Self::AtomMediametricsExtractorReported)
            }
            "ATOM_MEDIAMETRICS_MEDIADRM_REPORTED" => {
                Some(Self::AtomMediametricsMediadrmReported)
            }
            "ATOM_MEDIAMETRICS_NUPLAYER_REPORTED" => {
                Some(Self::AtomMediametricsNuplayerReported)
            }
            "ATOM_MEDIAMETRICS_RECORDER_REPORTED" => {
                Some(Self::AtomMediametricsRecorderReported)
            }
            "ATOM_MEDIAMETRICS_DRMMANAGER_REPORTED" => {
                Some(Self::AtomMediametricsDrmmanagerReported)
            }
            "ATOM_CAR_POWER_STATE_CHANGED" => Some(Self::AtomCarPowerStateChanged),
            "ATOM_GARAGE_MODE_INFO" => Some(Self::AtomGarageModeInfo),
            "ATOM_TEST_ATOM_REPORTED" => Some(Self::AtomTestAtomReported),
            "ATOM_CONTENT_CAPTURE_CALLER_MISMATCH_REPORTED" => {
                Some(Self::AtomContentCaptureCallerMismatchReported)
            }
            "ATOM_CONTENT_CAPTURE_SERVICE_EVENTS" => {
                Some(Self::AtomContentCaptureServiceEvents)
            }
            "ATOM_CONTENT_CAPTURE_SESSION_EVENTS" => {
                Some(Self::AtomContentCaptureSessionEvents)
            }
            "ATOM_CONTENT_CAPTURE_FLUSHED" => Some(Self::AtomContentCaptureFlushed),
            "ATOM_LOCATION_MANAGER_API_USAGE_REPORTED" => {
                Some(Self::AtomLocationManagerApiUsageReported)
            }
            "ATOM_REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED" => {
                Some(Self::AtomReviewPermissionsFragmentResultReported)
            }
            "ATOM_RUNTIME_PERMISSIONS_UPGRADE_RESULT" => {
                Some(Self::AtomRuntimePermissionsUpgradeResult)
            }
            "ATOM_GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS" => {
                Some(Self::AtomGrantPermissionsActivityButtonActions)
            }
            "ATOM_LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION" => {
                Some(Self::AtomLocationAccessCheckNotificationAction)
            }
            "ATOM_APP_PERMISSION_FRAGMENT_ACTION_REPORTED" => {
                Some(Self::AtomAppPermissionFragmentActionReported)
            }
            "ATOM_APP_PERMISSION_FRAGMENT_VIEWED" => {
                Some(Self::AtomAppPermissionFragmentViewed)
            }
            "ATOM_APP_PERMISSIONS_FRAGMENT_VIEWED" => {
                Some(Self::AtomAppPermissionsFragmentViewed)
            }
            "ATOM_PERMISSION_APPS_FRAGMENT_VIEWED" => {
                Some(Self::AtomPermissionAppsFragmentViewed)
            }
            "ATOM_TEXT_SELECTION_EVENT" => Some(Self::AtomTextSelectionEvent),
            "ATOM_TEXT_LINKIFY_EVENT" => Some(Self::AtomTextLinkifyEvent),
            "ATOM_CONVERSATION_ACTIONS_EVENT" => Some(Self::AtomConversationActionsEvent),
            "ATOM_LANGUAGE_DETECTION_EVENT" => Some(Self::AtomLanguageDetectionEvent),
            "ATOM_EXCLUSION_RECT_STATE_CHANGED" => {
                Some(Self::AtomExclusionRectStateChanged)
            }
            "ATOM_BACK_GESTURE_REPORTED_REPORTED" => {
                Some(Self::AtomBackGestureReportedReported)
            }
            "ATOM_UPDATE_ENGINE_UPDATE_ATTEMPT_REPORTED" => {
                Some(Self::AtomUpdateEngineUpdateAttemptReported)
            }
            "ATOM_UPDATE_ENGINE_SUCCESSFUL_UPDATE_REPORTED" => {
                Some(Self::AtomUpdateEngineSuccessfulUpdateReported)
            }
            "ATOM_CAMERA_ACTION_EVENT" => Some(Self::AtomCameraActionEvent),
            "ATOM_APP_COMPATIBILITY_CHANGE_REPORTED" => {
                Some(Self::AtomAppCompatibilityChangeReported)
            }
            "ATOM_PERFETTO_UPLOADED" => Some(Self::AtomPerfettoUploaded),
            "ATOM_VMS_CLIENT_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomVmsClientConnectionStateChanged)
            }
            "ATOM_MEDIA_PROVIDER_SCAN_OCCURRED" => {
                Some(Self::AtomMediaProviderScanOccurred)
            }
            "ATOM_MEDIA_CONTENT_DELETED" => Some(Self::AtomMediaContentDeleted),
            "ATOM_MEDIA_PROVIDER_PERMISSION_REQUESTED" => {
                Some(Self::AtomMediaProviderPermissionRequested)
            }
            "ATOM_MEDIA_PROVIDER_SCHEMA_CHANGED" => {
                Some(Self::AtomMediaProviderSchemaChanged)
            }
            "ATOM_MEDIA_PROVIDER_IDLE_MAINTENANCE_FINISHED" => {
                Some(Self::AtomMediaProviderIdleMaintenanceFinished)
            }
            "ATOM_REBOOT_ESCROW_RECOVERY_REPORTED" => {
                Some(Self::AtomRebootEscrowRecoveryReported)
            }
            "ATOM_BOOT_TIME_EVENT_DURATION_REPORTED" => {
                Some(Self::AtomBootTimeEventDurationReported)
            }
            "ATOM_BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED" => {
                Some(Self::AtomBootTimeEventElapsedTimeReported)
            }
            "ATOM_BOOT_TIME_EVENT_UTC_TIME_REPORTED" => {
                Some(Self::AtomBootTimeEventUtcTimeReported)
            }
            "ATOM_BOOT_TIME_EVENT_ERROR_CODE_REPORTED" => {
                Some(Self::AtomBootTimeEventErrorCodeReported)
            }
            "ATOM_USERSPACE_REBOOT_REPORTED" => Some(Self::AtomUserspaceRebootReported),
            "ATOM_NOTIFICATION_REPORTED" => Some(Self::AtomNotificationReported),
            "ATOM_NOTIFICATION_PANEL_REPORTED" => {
                Some(Self::AtomNotificationPanelReported)
            }
            "ATOM_NOTIFICATION_CHANNEL_MODIFIED" => {
                Some(Self::AtomNotificationChannelModified)
            }
            "ATOM_INTEGRITY_CHECK_RESULT_REPORTED" => {
                Some(Self::AtomIntegrityCheckResultReported)
            }
            "ATOM_INTEGRITY_RULES_PUSHED" => Some(Self::AtomIntegrityRulesPushed),
            "ATOM_CB_MESSAGE_REPORTED" => Some(Self::AtomCbMessageReported),
            "ATOM_CB_MESSAGE_ERROR" => Some(Self::AtomCbMessageError),
            "ATOM_WIFI_HEALTH_STAT_REPORTED" => Some(Self::AtomWifiHealthStatReported),
            "ATOM_WIFI_FAILURE_STAT_REPORTED" => Some(Self::AtomWifiFailureStatReported),
            "ATOM_WIFI_CONNECTION_RESULT_REPORTED" => {
                Some(Self::AtomWifiConnectionResultReported)
            }
            "ATOM_APP_FREEZE_CHANGED" => Some(Self::AtomAppFreezeChanged),
            "ATOM_SNAPSHOT_MERGE_REPORTED" => Some(Self::AtomSnapshotMergeReported),
            "ATOM_FOREGROUND_SERVICE_APP_OP_SESSION_ENDED" => {
                Some(Self::AtomForegroundServiceAppOpSessionEnded)
            }
            "ATOM_DISPLAY_JANK_REPORTED" => Some(Self::AtomDisplayJankReported),
            "ATOM_APP_STANDBY_BUCKET_CHANGED" => Some(Self::AtomAppStandbyBucketChanged),
            "ATOM_SHARESHEET_STARTED" => Some(Self::AtomSharesheetStarted),
            "ATOM_RANKING_SELECTED" => Some(Self::AtomRankingSelected),
            "ATOM_TVSETTINGS_UI_INTERACTED" => Some(Self::AtomTvsettingsUiInteracted),
            "ATOM_LAUNCHER_SNAPSHOT" => Some(Self::AtomLauncherSnapshot),
            "ATOM_PACKAGE_INSTALLER_V2_REPORTED" => {
                Some(Self::AtomPackageInstallerV2Reported)
            }
            "ATOM_USER_LIFECYCLE_JOURNEY_REPORTED" => {
                Some(Self::AtomUserLifecycleJourneyReported)
            }
            "ATOM_USER_LIFECYCLE_EVENT_OCCURRED" => {
                Some(Self::AtomUserLifecycleEventOccurred)
            }
            "ATOM_ACCESSIBILITY_SHORTCUT_REPORTED" => {
                Some(Self::AtomAccessibilityShortcutReported)
            }
            "ATOM_ACCESSIBILITY_SERVICE_REPORTED" => {
                Some(Self::AtomAccessibilityServiceReported)
            }
            "ATOM_DOCS_UI_DRAG_AND_DROP_REPORTED" => {
                Some(Self::AtomDocsUiDragAndDropReported)
            }
            "ATOM_APP_USAGE_EVENT_OCCURRED" => Some(Self::AtomAppUsageEventOccurred),
            "ATOM_AUTO_REVOKE_NOTIFICATION_CLICKED" => {
                Some(Self::AtomAutoRevokeNotificationClicked)
            }
            "ATOM_AUTO_REVOKE_FRAGMENT_APP_VIEWED" => {
                Some(Self::AtomAutoRevokeFragmentAppViewed)
            }
            "ATOM_AUTO_REVOKED_APP_INTERACTION" => {
                Some(Self::AtomAutoRevokedAppInteraction)
            }
            "ATOM_APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION" => {
                Some(Self::AtomAppPermissionGroupsFragmentAutoRevokeAction)
            }
            "ATOM_EVS_USAGE_STATS_REPORTED" => Some(Self::AtomEvsUsageStatsReported),
            "ATOM_AUDIO_POWER_USAGE_DATA_REPORTED" => {
                Some(Self::AtomAudioPowerUsageDataReported)
            }
            "ATOM_TV_TUNER_STATE_CHANGED" => Some(Self::AtomTvTunerStateChanged),
            "ATOM_MEDIAOUTPUT_OP_SWITCH_REPORTED" => {
                Some(Self::AtomMediaoutputOpSwitchReported)
            }
            "ATOM_CB_MESSAGE_FILTERED" => Some(Self::AtomCbMessageFiltered),
            "ATOM_TV_TUNER_DVR_STATUS" => Some(Self::AtomTvTunerDvrStatus),
            "ATOM_TV_CAS_SESSION_OPEN_STATUS" => Some(Self::AtomTvCasSessionOpenStatus),
            "ATOM_ASSISTANT_INVOCATION_REPORTED" => {
                Some(Self::AtomAssistantInvocationReported)
            }
            "ATOM_DISPLAY_WAKE_REPORTED" => Some(Self::AtomDisplayWakeReported),
            "ATOM_CAR_USER_HAL_MODIFY_USER_REQUEST_REPORTED" => {
                Some(Self::AtomCarUserHalModifyUserRequestReported)
            }
            "ATOM_CAR_USER_HAL_MODIFY_USER_RESPONSE_REPORTED" => {
                Some(Self::AtomCarUserHalModifyUserResponseReported)
            }
            "ATOM_CAR_USER_HAL_POST_SWITCH_RESPONSE_REPORTED" => {
                Some(Self::AtomCarUserHalPostSwitchResponseReported)
            }
            "ATOM_CAR_USER_HAL_INITIAL_USER_INFO_REQUEST_REPORTED" => {
                Some(Self::AtomCarUserHalInitialUserInfoRequestReported)
            }
            "ATOM_CAR_USER_HAL_INITIAL_USER_INFO_RESPONSE_REPORTED" => {
                Some(Self::AtomCarUserHalInitialUserInfoResponseReported)
            }
            "ATOM_CAR_USER_HAL_USER_ASSOCIATION_REQUEST_REPORTED" => {
                Some(Self::AtomCarUserHalUserAssociationRequestReported)
            }
            "ATOM_CAR_USER_HAL_SET_USER_ASSOCIATION_RESPONSE_REPORTED" => {
                Some(Self::AtomCarUserHalSetUserAssociationResponseReported)
            }
            "ATOM_NETWORK_IP_PROVISIONING_REPORTED" => {
                Some(Self::AtomNetworkIpProvisioningReported)
            }
            "ATOM_NETWORK_DHCP_RENEW_REPORTED" => {
                Some(Self::AtomNetworkDhcpRenewReported)
            }
            "ATOM_NETWORK_VALIDATION_REPORTED" => {
                Some(Self::AtomNetworkValidationReported)
            }
            "ATOM_NETWORK_STACK_QUIRK_REPORTED" => {
                Some(Self::AtomNetworkStackQuirkReported)
            }
            "ATOM_MEDIAMETRICS_AUDIORECORDDEVICEUSAGE_REPORTED" => {
                Some(Self::AtomMediametricsAudiorecorddeviceusageReported)
            }
            "ATOM_MEDIAMETRICS_AUDIOTHREADDEVICEUSAGE_REPORTED" => {
                Some(Self::AtomMediametricsAudiothreaddeviceusageReported)
            }
            "ATOM_MEDIAMETRICS_AUDIOTRACKDEVICEUSAGE_REPORTED" => {
                Some(Self::AtomMediametricsAudiotrackdeviceusageReported)
            }
            "ATOM_MEDIAMETRICS_AUDIODEVICECONNECTION_REPORTED" => {
                Some(Self::AtomMediametricsAudiodeviceconnectionReported)
            }
            "ATOM_BLOB_COMMITTED" => Some(Self::AtomBlobCommitted),
            "ATOM_BLOB_LEASED" => Some(Self::AtomBlobLeased),
            "ATOM_BLOB_OPENED" => Some(Self::AtomBlobOpened),
            "ATOM_CONTACTS_PROVIDER_STATUS_REPORTED" => {
                Some(Self::AtomContactsProviderStatusReported)
            }
            "ATOM_KEYSTORE_KEY_EVENT_REPORTED" => {
                Some(Self::AtomKeystoreKeyEventReported)
            }
            "ATOM_NETWORK_TETHERING_REPORTED" => Some(Self::AtomNetworkTetheringReported),
            "ATOM_IME_TOUCH_REPORTED" => Some(Self::AtomImeTouchReported),
            "ATOM_UI_INTERACTION_FRAME_INFO_REPORTED" => {
                Some(Self::AtomUiInteractionFrameInfoReported)
            }
            "ATOM_UI_ACTION_LATENCY_REPORTED" => Some(Self::AtomUiActionLatencyReported),
            "ATOM_WIFI_DISCONNECT_REPORTED" => Some(Self::AtomWifiDisconnectReported),
            "ATOM_WIFI_CONNECTION_STATE_CHANGED" => {
                Some(Self::AtomWifiConnectionStateChanged)
            }
            "ATOM_HDMI_CEC_ACTIVE_SOURCE_CHANGED" => {
                Some(Self::AtomHdmiCecActiveSourceChanged)
            }
            "ATOM_HDMI_CEC_MESSAGE_REPORTED" => Some(Self::AtomHdmiCecMessageReported),
            "ATOM_AIRPLANE_MODE" => Some(Self::AtomAirplaneMode),
            "ATOM_MODEM_RESTART" => Some(Self::AtomModemRestart),
            "ATOM_CARRIER_ID_MISMATCH_REPORTED" => {
                Some(Self::AtomCarrierIdMismatchReported)
            }
            "ATOM_CARRIER_ID_TABLE_UPDATED" => Some(Self::AtomCarrierIdTableUpdated),
            "ATOM_DATA_STALL_RECOVERY_REPORTED" => {
                Some(Self::AtomDataStallRecoveryReported)
            }
            "ATOM_MEDIAMETRICS_MEDIAPARSER_REPORTED" => {
                Some(Self::AtomMediametricsMediaparserReported)
            }
            "ATOM_TLS_HANDSHAKE_REPORTED" => Some(Self::AtomTlsHandshakeReported),
            "ATOM_TEXT_CLASSIFIER_API_USAGE_REPORTED" => {
                Some(Self::AtomTextClassifierApiUsageReported)
            }
            "ATOM_CAR_WATCHDOG_KILL_STATS_REPORTED" => {
                Some(Self::AtomCarWatchdogKillStatsReported)
            }
            "ATOM_MEDIAMETRICS_PLAYBACK_REPORTED" => {
                Some(Self::AtomMediametricsPlaybackReported)
            }
            "ATOM_MEDIA_NETWORK_INFO_CHANGED" => Some(Self::AtomMediaNetworkInfoChanged),
            "ATOM_MEDIA_PLAYBACK_STATE_CHANGED" => {
                Some(Self::AtomMediaPlaybackStateChanged)
            }
            "ATOM_MEDIA_PLAYBACK_ERROR_REPORTED" => {
                Some(Self::AtomMediaPlaybackErrorReported)
            }
            "ATOM_MEDIA_PLAYBACK_TRACK_CHANGED" => {
                Some(Self::AtomMediaPlaybackTrackChanged)
            }
            "ATOM_WIFI_SCAN_REPORTED" => Some(Self::AtomWifiScanReported),
            "ATOM_WIFI_PNO_SCAN_REPORTED" => Some(Self::AtomWifiPnoScanReported),
            "ATOM_TIF_TUNE_CHANGED" => Some(Self::AtomTifTuneChanged),
            "ATOM_AUTO_ROTATE_REPORTED" => Some(Self::AtomAutoRotateReported),
            "ATOM_PERFETTO_TRIGGER" => Some(Self::AtomPerfettoTrigger),
            "ATOM_TRANSCODING_DATA" => Some(Self::AtomTranscodingData),
            "ATOM_IMS_SERVICE_ENTITLEMENT_UPDATED" => {
                Some(Self::AtomImsServiceEntitlementUpdated)
            }
            "ATOM_DEVICE_ROTATED" => Some(Self::AtomDeviceRotated),
            "ATOM_SIM_SPECIFIC_SETTINGS_RESTORED" => {
                Some(Self::AtomSimSpecificSettingsRestored)
            }
            "ATOM_TEXT_CLASSIFIER_DOWNLOAD_REPORTED" => {
                Some(Self::AtomTextClassifierDownloadReported)
            }
            "ATOM_PIN_STORAGE_EVENT" => Some(Self::AtomPinStorageEvent),
            "ATOM_FACE_DOWN_REPORTED" => Some(Self::AtomFaceDownReported),
            "ATOM_BLUETOOTH_HAL_CRASH_REASON_REPORTED" => {
                Some(Self::AtomBluetoothHalCrashReasonReported)
            }
            "ATOM_REBOOT_ESCROW_PREPARATION_REPORTED" => {
                Some(Self::AtomRebootEscrowPreparationReported)
            }
            "ATOM_REBOOT_ESCROW_LSKF_CAPTURE_REPORTED" => {
                Some(Self::AtomRebootEscrowLskfCaptureReported)
            }
            "ATOM_REBOOT_ESCROW_REBOOT_REPORTED" => {
                Some(Self::AtomRebootEscrowRebootReported)
            }
            "ATOM_BINDER_LATENCY_REPORTED" => Some(Self::AtomBinderLatencyReported),
            "ATOM_MEDIAMETRICS_AAUDIOSTREAM_REPORTED" => {
                Some(Self::AtomMediametricsAaudiostreamReported)
            }
            "ATOM_MEDIA_TRANSCODING_SESSION_ENDED" => {
                Some(Self::AtomMediaTranscodingSessionEnded)
            }
            "ATOM_MAGNIFICATION_USAGE_REPORTED" => {
                Some(Self::AtomMagnificationUsageReported)
            }
            "ATOM_MAGNIFICATION_MODE_WITH_IME_ON_REPORTED" => {
                Some(Self::AtomMagnificationModeWithImeOnReported)
            }
            "ATOM_APP_SEARCH_CALL_STATS_REPORTED" => {
                Some(Self::AtomAppSearchCallStatsReported)
            }
            "ATOM_APP_SEARCH_PUT_DOCUMENT_STATS_REPORTED" => {
                Some(Self::AtomAppSearchPutDocumentStatsReported)
            }
            "ATOM_DEVICE_CONTROL_CHANGED" => Some(Self::AtomDeviceControlChanged),
            "ATOM_DEVICE_STATE_CHANGED" => Some(Self::AtomDeviceStateChanged),
            "ATOM_INPUTDEVICE_REGISTERED" => Some(Self::AtomInputdeviceRegistered),
            "ATOM_SMARTSPACE_CARD_REPORTED" => Some(Self::AtomSmartspaceCardReported),
            "ATOM_AUTH_PROMPT_AUTHENTICATE_INVOKED" => {
                Some(Self::AtomAuthPromptAuthenticateInvoked)
            }
            "ATOM_AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED" => {
                Some(Self::AtomAuthManagerCanAuthenticateInvoked)
            }
            "ATOM_AUTH_ENROLL_ACTION_INVOKED" => Some(Self::AtomAuthEnrollActionInvoked),
            "ATOM_AUTH_DEPRECATED_API_USED" => Some(Self::AtomAuthDeprecatedApiUsed),
            "ATOM_UNATTENDED_REBOOT_OCCURRED" => Some(Self::AtomUnattendedRebootOccurred),
            "ATOM_LONG_REBOOT_BLOCKING_REPORTED" => {
                Some(Self::AtomLongRebootBlockingReported)
            }
            "ATOM_LOCATION_TIME_ZONE_PROVIDER_STATE_CHANGED" => {
                Some(Self::AtomLocationTimeZoneProviderStateChanged)
            }
            "ATOM_FDTRACK_EVENT_OCCURRED" => Some(Self::AtomFdtrackEventOccurred),
            "ATOM_TIMEOUT_AUTO_EXTENDED_REPORTED" => {
                Some(Self::AtomTimeoutAutoExtendedReported)
            }
            "ATOM_ALARM_BATCH_DELIVERED" => Some(Self::AtomAlarmBatchDelivered),
            "ATOM_ALARM_SCHEDULED" => Some(Self::AtomAlarmScheduled),
            "ATOM_CAR_WATCHDOG_IO_OVERUSE_STATS_REPORTED" => {
                Some(Self::AtomCarWatchdogIoOveruseStatsReported)
            }
            "ATOM_USER_LEVEL_HIBERNATION_STATE_CHANGED" => {
                Some(Self::AtomUserLevelHibernationStateChanged)
            }
            "ATOM_APP_SEARCH_INITIALIZE_STATS_REPORTED" => {
                Some(Self::AtomAppSearchInitializeStatsReported)
            }
            "ATOM_APP_SEARCH_QUERY_STATS_REPORTED" => {
                Some(Self::AtomAppSearchQueryStatsReported)
            }
            "ATOM_APP_PROCESS_DIED" => Some(Self::AtomAppProcessDied),
            "ATOM_NETWORK_IP_REACHABILITY_MONITOR_REPORTED" => {
                Some(Self::AtomNetworkIpReachabilityMonitorReported)
            }
            "ATOM_SLOW_INPUT_EVENT_REPORTED" => Some(Self::AtomSlowInputEventReported),
            "ATOM_ANR_OCCURRED_PROCESSING_STARTED" => {
                Some(Self::AtomAnrOccurredProcessingStarted)
            }
            "ATOM_APP_SEARCH_REMOVE_STATS_REPORTED" => {
                Some(Self::AtomAppSearchRemoveStatsReported)
            }
            "ATOM_MEDIA_CODEC_REPORTED" => Some(Self::AtomMediaCodecReported),
            "ATOM_PERMISSION_USAGE_FRAGMENT_INTERACTION" => {
                Some(Self::AtomPermissionUsageFragmentInteraction)
            }
            "ATOM_PERMISSION_DETAILS_INTERACTION" => {
                Some(Self::AtomPermissionDetailsInteraction)
            }
            "ATOM_PRIVACY_SENSOR_TOGGLE_INTERACTION" => {
                Some(Self::AtomPrivacySensorToggleInteraction)
            }
            "ATOM_PRIVACY_TOGGLE_DIALOG_INTERACTION" => {
                Some(Self::AtomPrivacyToggleDialogInteraction)
            }
            "ATOM_APP_SEARCH_OPTIMIZE_STATS_REPORTED" => {
                Some(Self::AtomAppSearchOptimizeStatsReported)
            }
            "ATOM_NON_A11Y_TOOL_SERVICE_WARNING_REPORT" => {
                Some(Self::AtomNonA11yToolServiceWarningReport)
            }
            "ATOM_APP_SEARCH_SET_SCHEMA_STATS_REPORTED" => {
                Some(Self::AtomAppSearchSetSchemaStatsReported)
            }
            "ATOM_APP_COMPAT_STATE_CHANGED" => Some(Self::AtomAppCompatStateChanged),
            "ATOM_SIZE_COMPAT_RESTART_BUTTON_EVENT_REPORTED" => {
                Some(Self::AtomSizeCompatRestartButtonEventReported)
            }
            "ATOM_SPLITSCREEN_UI_CHANGED" => Some(Self::AtomSplitscreenUiChanged),
            "ATOM_NETWORK_DNS_HANDSHAKE_REPORTED" => {
                Some(Self::AtomNetworkDnsHandshakeReported)
            }
            "ATOM_BLUETOOTH_CODE_PATH_COUNTER" => {
                Some(Self::AtomBluetoothCodePathCounter)
            }
            "ATOM_BLUETOOTH_LE_BATCH_SCAN_REPORT_DELAY" => {
                Some(Self::AtomBluetoothLeBatchScanReportDelay)
            }
            "ATOM_ACCESSIBILITY_FLOATING_MENU_UI_CHANGED" => {
                Some(Self::AtomAccessibilityFloatingMenuUiChanged)
            }
            "ATOM_NEURALNETWORKS_COMPILATION_COMPLETED" => {
                Some(Self::AtomNeuralnetworksCompilationCompleted)
            }
            "ATOM_NEURALNETWORKS_EXECUTION_COMPLETED" => {
                Some(Self::AtomNeuralnetworksExecutionCompleted)
            }
            "ATOM_NEURALNETWORKS_COMPILATION_FAILED" => {
                Some(Self::AtomNeuralnetworksCompilationFailed)
            }
            "ATOM_NEURALNETWORKS_EXECUTION_FAILED" => {
                Some(Self::AtomNeuralnetworksExecutionFailed)
            }
            "ATOM_CONTEXT_HUB_BOOTED" => Some(Self::AtomContextHubBooted),
            "ATOM_CONTEXT_HUB_RESTARTED" => Some(Self::AtomContextHubRestarted),
            "ATOM_CONTEXT_HUB_LOADED_NANOAPP_SNAPSHOT_REPORTED" => {
                Some(Self::AtomContextHubLoadedNanoappSnapshotReported)
            }
            "ATOM_CHRE_CODE_DOWNLOAD_TRANSACTED" => {
                Some(Self::AtomChreCodeDownloadTransacted)
            }
            "ATOM_UWB_SESSION_INITED" => Some(Self::AtomUwbSessionInited),
            "ATOM_UWB_SESSION_CLOSED" => Some(Self::AtomUwbSessionClosed),
            "ATOM_UWB_FIRST_RANGING_RECEIVED" => Some(Self::AtomUwbFirstRangingReceived),
            "ATOM_UWB_RANGING_MEASUREMENT_RECEIVED" => {
                Some(Self::AtomUwbRangingMeasurementReceived)
            }
            "ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_SCHEDULED" => {
                Some(Self::AtomTextClassifierDownloadWorkScheduled)
            }
            "ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_COMPLETED" => {
                Some(Self::AtomTextClassifierDownloadWorkCompleted)
            }
            "ATOM_CLIPBOARD_CLEARED" => Some(Self::AtomClipboardCleared),
            "ATOM_VM_CREATION_REQUESTED" => Some(Self::AtomVmCreationRequested),
            "ATOM_NEARBY_DEVICE_SCAN_STATE_CHANGED" => {
                Some(Self::AtomNearbyDeviceScanStateChanged)
            }
            "ATOM_CAMERA_COMPAT_CONTROL_EVENT_REPORTED" => {
                Some(Self::AtomCameraCompatControlEventReported)
            }
            "ATOM_APPLICATION_LOCALES_CHANGED" => {
                Some(Self::AtomApplicationLocalesChanged)
            }
            "ATOM_MEDIAMETRICS_AUDIOTRACKSTATUS_REPORTED" => {
                Some(Self::AtomMediametricsAudiotrackstatusReported)
            }
            "ATOM_FOLD_STATE_DURATION_REPORTED" => {
                Some(Self::AtomFoldStateDurationReported)
            }
            "ATOM_LOCATION_TIME_ZONE_PROVIDER_CONTROLLER_STATE_CHANGED" => {
                Some(Self::AtomLocationTimeZoneProviderControllerStateChanged)
            }
            "ATOM_DISPLAY_HBM_STATE_CHANGED" => Some(Self::AtomDisplayHbmStateChanged),
            "ATOM_DISPLAY_HBM_BRIGHTNESS_CHANGED" => {
                Some(Self::AtomDisplayHbmBrightnessChanged)
            }
            "ATOM_PERSISTENT_URI_PERMISSIONS_FLUSHED" => {
                Some(Self::AtomPersistentUriPermissionsFlushed)
            }
            "ATOM_EARLY_BOOT_COMP_OS_ARTIFACTS_CHECK_REPORTED" => {
                Some(Self::AtomEarlyBootCompOsArtifactsCheckReported)
            }
            "ATOM_VBMETA_DIGEST_REPORTED" => Some(Self::AtomVbmetaDigestReported),
            "ATOM_APEX_INFO_GATHERED" => Some(Self::AtomApexInfoGathered),
            "ATOM_PVM_INFO_GATHERED" => Some(Self::AtomPvmInfoGathered),
            "ATOM_WEAR_SETTINGS_UI_INTERACTED" => {
                Some(Self::AtomWearSettingsUiInteracted)
            }
            "ATOM_TRACING_SERVICE_REPORT_EVENT" => {
                Some(Self::AtomTracingServiceReportEvent)
            }
            "ATOM_MEDIAMETRICS_AUDIORECORDSTATUS_REPORTED" => {
                Some(Self::AtomMediametricsAudiorecordstatusReported)
            }
            "ATOM_LAUNCHER_LATENCY" => Some(Self::AtomLauncherLatency),
            "ATOM_DROPBOX_ENTRY_DROPPED" => Some(Self::AtomDropboxEntryDropped),
            "ATOM_WIFI_P2P_CONNECTION_REPORTED" => {
                Some(Self::AtomWifiP2pConnectionReported)
            }
            "ATOM_GAME_STATE_CHANGED" => Some(Self::AtomGameStateChanged),
            "ATOM_HOTWORD_DETECTOR_CREATE_REQUESTED" => {
                Some(Self::AtomHotwordDetectorCreateRequested)
            }
            "ATOM_HOTWORD_DETECTION_SERVICE_INIT_RESULT_REPORTED" => {
                Some(Self::AtomHotwordDetectionServiceInitResultReported)
            }
            "ATOM_HOTWORD_DETECTION_SERVICE_RESTARTED" => {
                Some(Self::AtomHotwordDetectionServiceRestarted)
            }
            "ATOM_HOTWORD_DETECTOR_KEYPHRASE_TRIGGERED" => {
                Some(Self::AtomHotwordDetectorKeyphraseTriggered)
            }
            "ATOM_HOTWORD_DETECTOR_EVENTS" => Some(Self::AtomHotwordDetectorEvents),
            "ATOM_AD_SERVICES_API_CALLED" => Some(Self::AtomAdServicesApiCalled),
            "ATOM_AD_SERVICES_MESUREMENT_REPORTS_UPLOADED" => {
                Some(Self::AtomAdServicesMesurementReportsUploaded)
            }
            "ATOM_BOOT_COMPLETED_BROADCAST_COMPLETION_LATENCY_REPORTED" => {
                Some(Self::AtomBootCompletedBroadcastCompletionLatencyReported)
            }
            "ATOM_CONTACTS_INDEXER_UPDATE_STATS_REPORTED" => {
                Some(Self::AtomContactsIndexerUpdateStatsReported)
            }
            "ATOM_APP_BACKGROUND_RESTRICTIONS_INFO" => {
                Some(Self::AtomAppBackgroundRestrictionsInfo)
            }
            "ATOM_MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED" => {
                Some(Self::AtomMmsSmsProviderGetThreadIdFailed)
            }
            "ATOM_MMS_SMS_DATABASE_HELPER_ON_UPGRADE_FAILED" => {
                Some(Self::AtomMmsSmsDatabaseHelperOnUpgradeFailed)
            }
            "ATOM_PERMISSION_REMINDER_NOTIFICATION_INTERACTED" => {
                Some(Self::AtomPermissionReminderNotificationInteracted)
            }
            "ATOM_RECENT_PERMISSION_DECISIONS_INTERACTED" => {
                Some(Self::AtomRecentPermissionDecisionsInteracted)
            }
            "ATOM_GNSS_PSDS_DOWNLOAD_REPORTED" => {
                Some(Self::AtomGnssPsdsDownloadReported)
            }
            "ATOM_LE_AUDIO_CONNECTION_SESSION_REPORTED" => {
                Some(Self::AtomLeAudioConnectionSessionReported)
            }
            "ATOM_LE_AUDIO_BROADCAST_SESSION_REPORTED" => {
                Some(Self::AtomLeAudioBroadcastSessionReported)
            }
            "ATOM_DREAM_UI_EVENT_REPORTED" => Some(Self::AtomDreamUiEventReported),
            "ATOM_TASK_MANAGER_EVENT_REPORTED" => {
                Some(Self::AtomTaskManagerEventReported)
            }
            "ATOM_CDM_ASSOCIATION_ACTION" => Some(Self::AtomCdmAssociationAction),
            "ATOM_MAGNIFICATION_TRIPLE_TAP_AND_HOLD_ACTIVATED_SESSION_REPORTED" => {
                Some(Self::AtomMagnificationTripleTapAndHoldActivatedSessionReported)
            }
            "ATOM_MAGNIFICATION_FOLLOW_TYPING_FOCUS_ACTIVATED_SESSION_REPORTED" => {
                Some(Self::AtomMagnificationFollowTypingFocusActivatedSessionReported)
            }
            "ATOM_ACCESSIBILITY_TEXT_READING_OPTIONS_CHANGED" => {
                Some(Self::AtomAccessibilityTextReadingOptionsChanged)
            }
            "ATOM_WIFI_SETUP_FAILURE_CRASH_REPORTED" => {
                Some(Self::AtomWifiSetupFailureCrashReported)
            }
            "ATOM_UWB_DEVICE_ERROR_REPORTED" => Some(Self::AtomUwbDeviceErrorReported),
            "ATOM_ISOLATED_COMPILATION_SCHEDULED" => {
                Some(Self::AtomIsolatedCompilationScheduled)
            }
            "ATOM_ISOLATED_COMPILATION_ENDED" => Some(Self::AtomIsolatedCompilationEnded),
            "ATOM_ONS_OPPORTUNISTIC_ESIM_PROVISIONING_COMPLETE" => {
                Some(Self::AtomOnsOpportunisticEsimProvisioningComplete)
            }
            "ATOM_SYSTEM_SERVER_PRE_WATCHDOG_OCCURRED" => {
                Some(Self::AtomSystemServerPreWatchdogOccurred)
            }
            "ATOM_TELEPHONY_ANOMALY_DETECTED" => Some(Self::AtomTelephonyAnomalyDetected),
            "ATOM_LETTERBOX_POSITION_CHANGED" => Some(Self::AtomLetterboxPositionChanged),
            "ATOM_REMOTE_KEY_PROVISIONING_ATTEMPT" => {
                Some(Self::AtomRemoteKeyProvisioningAttempt)
            }
            "ATOM_REMOTE_KEY_PROVISIONING_NETWORK_INFO" => {
                Some(Self::AtomRemoteKeyProvisioningNetworkInfo)
            }
            "ATOM_REMOTE_KEY_PROVISIONING_TIMING" => {
                Some(Self::AtomRemoteKeyProvisioningTiming)
            }
            "ATOM_MEDIAOUTPUT_OP_INTERACTION_REPORT" => {
                Some(Self::AtomMediaoutputOpInteractionReport)
            }
            "ATOM_SYNC_EXEMPTION_OCCURRED" => Some(Self::AtomSyncExemptionOccurred),
            "ATOM_AUTOFILL_PRESENTATION_EVENT_REPORTED" => {
                Some(Self::AtomAutofillPresentationEventReported)
            }
            "ATOM_DOCK_STATE_CHANGED" => Some(Self::AtomDockStateChanged),
            "ATOM_SAFETY_SOURCE_STATE_COLLECTED" => {
                Some(Self::AtomSafetySourceStateCollected)
            }
            "ATOM_SAFETY_CENTER_SYSTEM_EVENT_REPORTED" => {
                Some(Self::AtomSafetyCenterSystemEventReported)
            }
            "ATOM_SAFETY_CENTER_INTERACTION_REPORTED" => {
                Some(Self::AtomSafetyCenterInteractionReported)
            }
            "ATOM_SETTINGS_PROVIDER_SETTING_CHANGED" => {
                Some(Self::AtomSettingsProviderSettingChanged)
            }
            "ATOM_BROADCAST_DELIVERY_EVENT_REPORTED" => {
                Some(Self::AtomBroadcastDeliveryEventReported)
            }
            "ATOM_SERVICE_REQUEST_EVENT_REPORTED" => {
                Some(Self::AtomServiceRequestEventReported)
            }
            "ATOM_PROVIDER_ACQUISITION_EVENT_REPORTED" => {
                Some(Self::AtomProviderAcquisitionEventReported)
            }
            "ATOM_BLUETOOTH_DEVICE_NAME_REPORTED" => {
                Some(Self::AtomBluetoothDeviceNameReported)
            }
            "ATOM_CB_CONFIG_UPDATED" => Some(Self::AtomCbConfigUpdated),
            "ATOM_CB_MODULE_ERROR_REPORTED" => Some(Self::AtomCbModuleErrorReported),
            "ATOM_CB_SERVICE_FEATURE_CHANGED" => Some(Self::AtomCbServiceFeatureChanged),
            "ATOM_CB_RECEIVER_FEATURE_CHANGED" => {
                Some(Self::AtomCbReceiverFeatureChanged)
            }
            "ATOM_JSSCRIPTENGINE_LATENCY_REPORTED" => {
                Some(Self::AtomJsscriptengineLatencyReported)
            }
            "ATOM_PRIVACY_SIGNAL_NOTIFICATION_INTERACTION" => {
                Some(Self::AtomPrivacySignalNotificationInteraction)
            }
            "ATOM_PRIVACY_SIGNAL_ISSUE_CARD_INTERACTION" => {
                Some(Self::AtomPrivacySignalIssueCardInteraction)
            }
            "ATOM_PRIVACY_SIGNALS_JOB_FAILURE" => {
                Some(Self::AtomPrivacySignalsJobFailure)
            }
            "ATOM_VIBRATION_REPORTED" => Some(Self::AtomVibrationReported),
            "ATOM_UWB_RANGING_START" => Some(Self::AtomUwbRangingStart),
            "ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STATUS_REPORTED" => {
                Some(Self::AtomMobileDataDownloadFileGroupStatusReported)
            }
            "ATOM_APP_COMPACTED_V2" => Some(Self::AtomAppCompactedV2),
            "ATOM_AD_SERVICES_SETTINGS_USAGE_REPORTED" => {
                Some(Self::AtomAdServicesSettingsUsageReported)
            }
            "ATOM_DISPLAY_BRIGHTNESS_CHANGED" => Some(Self::AtomDisplayBrightnessChanged),
            "ATOM_ACTIVITY_ACTION_BLOCKED" => Some(Self::AtomActivityActionBlocked),
            "ATOM_BACKGROUND_FETCH_PROCESS_REPORTED" => {
                Some(Self::AtomBackgroundFetchProcessReported)
            }
            "ATOM_UPDATE_CUSTOM_AUDIENCE_PROCESS_REPORTED" => {
                Some(Self::AtomUpdateCustomAudienceProcessReported)
            }
            "ATOM_RUN_AD_BIDDING_PROCESS_REPORTED" => {
                Some(Self::AtomRunAdBiddingProcessReported)
            }
            "ATOM_RUN_AD_SCORING_PROCESS_REPORTED" => {
                Some(Self::AtomRunAdScoringProcessReported)
            }
            "ATOM_RUN_AD_SELECTION_PROCESS_REPORTED" => {
                Some(Self::AtomRunAdSelectionProcessReported)
            }
            "ATOM_RUN_AD_BIDDING_PER_CA_PROCESS_REPORTED" => {
                Some(Self::AtomRunAdBiddingPerCaProcessReported)
            }
            "ATOM_MOBILE_DATA_DOWNLOAD_DOWNLOAD_RESULT_REPORTED" => {
                Some(Self::AtomMobileDataDownloadDownloadResultReported)
            }
            "ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STORAGE_STATS_REPORTED" => {
                Some(Self::AtomMobileDataDownloadFileGroupStorageStatsReported)
            }
            "ATOM_NETWORK_DNS_SERVER_SUPPORT_REPORTED" => {
                Some(Self::AtomNetworkDnsServerSupportReported)
            }
            "ATOM_VM_BOOTED" => Some(Self::AtomVmBooted),
            "ATOM_VM_EXITED" => Some(Self::AtomVmExited),
            "ATOM_AMBIENT_BRIGHTNESS_STATS_REPORTED" => {
                Some(Self::AtomAmbientBrightnessStatsReported)
            }
            "ATOM_MEDIAMETRICS_SPATIALIZERCAPABILITIES_REPORTED" => {
                Some(Self::AtomMediametricsSpatializercapabilitiesReported)
            }
            "ATOM_MEDIAMETRICS_SPATIALIZERDEVICEENABLED_REPORTED" => {
                Some(Self::AtomMediametricsSpatializerdeviceenabledReported)
            }
            "ATOM_MEDIAMETRICS_HEADTRACKERDEVICEENABLED_REPORTED" => {
                Some(Self::AtomMediametricsHeadtrackerdeviceenabledReported)
            }
            "ATOM_MEDIAMETRICS_HEADTRACKERDEVICESUPPORTED_REPORTED" => {
                Some(Self::AtomMediametricsHeadtrackerdevicesupportedReported)
            }
            "ATOM_AD_SERVICES_MEASUREMENT_REGISTRATIONS" => {
                Some(Self::AtomAdServicesMeasurementRegistrations)
            }
            "ATOM_HEARING_AID_INFO_REPORTED" => Some(Self::AtomHearingAidInfoReported),
            "ATOM_DEVICE_WIDE_JOB_CONSTRAINT_CHANGED" => {
                Some(Self::AtomDeviceWideJobConstraintChanged)
            }
            "ATOM_AMBIENT_MODE_CHANGED" => Some(Self::AtomAmbientModeChanged),
            "ATOM_ANR_LATENCY_REPORTED" => Some(Self::AtomAnrLatencyReported),
            "ATOM_RESOURCE_API_INFO" => Some(Self::AtomResourceApiInfo),
            "ATOM_SYSTEM_DEFAULT_NETWORK_CHANGED" => {
                Some(Self::AtomSystemDefaultNetworkChanged)
            }
            "ATOM_IWLAN_SETUP_DATA_CALL_RESULT_REPORTED" => {
                Some(Self::AtomIwlanSetupDataCallResultReported)
            }
            "ATOM_IWLAN_PDN_DISCONNECTED_REASON_REPORTED" => {
                Some(Self::AtomIwlanPdnDisconnectedReasonReported)
            }
            "ATOM_AIRPLANE_MODE_SESSION_REPORTED" => {
                Some(Self::AtomAirplaneModeSessionReported)
            }
            "ATOM_VM_CPU_STATUS_REPORTED" => Some(Self::AtomVmCpuStatusReported),
            "ATOM_VM_MEM_STATUS_REPORTED" => Some(Self::AtomVmMemStatusReported),
            "ATOM_PACKAGE_INSTALLATION_SESSION_REPORTED" => {
                Some(Self::AtomPackageInstallationSessionReported)
            }
            "ATOM_DEFAULT_NETWORK_REMATCH_INFO" => {
                Some(Self::AtomDefaultNetworkRematchInfo)
            }
            "ATOM_NETWORK_SELECTION_PERFORMANCE" => {
                Some(Self::AtomNetworkSelectionPerformance)
            }
            "ATOM_NETWORK_NSD_REPORTED" => Some(Self::AtomNetworkNsdReported),
            "ATOM_BLUETOOTH_DISCONNECTION_REASON_REPORTED" => {
                Some(Self::AtomBluetoothDisconnectionReasonReported)
            }
            "ATOM_BLUETOOTH_LOCAL_VERSIONS_REPORTED" => {
                Some(Self::AtomBluetoothLocalVersionsReported)
            }
            "ATOM_BLUETOOTH_REMOTE_SUPPORTED_FEATURES_REPORTED" => {
                Some(Self::AtomBluetoothRemoteSupportedFeaturesReported)
            }
            "ATOM_BLUETOOTH_LOCAL_SUPPORTED_FEATURES_REPORTED" => {
                Some(Self::AtomBluetoothLocalSupportedFeaturesReported)
            }
            "ATOM_BLUETOOTH_GATT_APP_INFO" => Some(Self::AtomBluetoothGattAppInfo),
            "ATOM_BRIGHTNESS_CONFIGURATION_UPDATED" => {
                Some(Self::AtomBrightnessConfigurationUpdated)
            }
            "ATOM_AD_SERVICES_GET_TOPICS_REPORTED" => {
                Some(Self::AtomAdServicesGetTopicsReported)
            }
            "ATOM_AD_SERVICES_EPOCH_COMPUTATION_GET_TOP_TOPICS_REPORTED" => {
                Some(Self::AtomAdServicesEpochComputationGetTopTopicsReported)
            }
            "ATOM_AD_SERVICES_EPOCH_COMPUTATION_CLASSIFIER_REPORTED" => {
                Some(Self::AtomAdServicesEpochComputationClassifierReported)
            }
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_LAUNCHED" => {
                Some(Self::AtomWearMediaOutputSwitcherLaunched)
            }
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FINISHED" => {
                Some(Self::AtomWearMediaOutputSwitcherFinished)
            }
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECTION_REPORTED" => {
                Some(Self::AtomWearMediaOutputSwitcherConnectionReported)
            }
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_TRIGGERED" => {
                Some(Self::AtomWearMediaOutputSwitcherDeviceScanTriggered)
            }
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FIRST_DEVICE_SCAN_LATENCY" => {
                Some(Self::AtomWearMediaOutputSwitcherFirstDeviceScanLatency)
            }
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECT_DEVICE_LATENCY" => {
                Some(Self::AtomWearMediaOutputSwitcherConnectDeviceLatency)
            }
            "ATOM_PACKAGE_MANAGER_SNAPSHOT_REPORTED" => {
                Some(Self::AtomPackageManagerSnapshotReported)
            }
            "ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_BUILD_REPORTED" => {
                Some(Self::AtomPackageManagerAppsFilterCacheBuildReported)
            }
            "ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_UPDATE_REPORTED" => {
                Some(Self::AtomPackageManagerAppsFilterCacheUpdateReported)
            }
            "ATOM_LAUNCHER_IMPRESSION_EVENT" => Some(Self::AtomLauncherImpressionEvent),
            "ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_ALL_DEVICES_SCAN_LATENCY" => {
                Some(Self::AtomWearMediaOutputSwitcherAllDevicesScanLatency)
            }
            "ATOM_WS_WATCH_FACE_EDITED" => Some(Self::AtomWsWatchFaceEdited),
            "ATOM_WS_WATCH_FACE_FAVORITE_ACTION_REPORTED" => {
                Some(Self::AtomWsWatchFaceFavoriteActionReported)
            }
            "ATOM_WS_WATCH_FACE_SET_ACTION_REPORTED" => {
                Some(Self::AtomWsWatchFaceSetActionReported)
            }
            "ATOM_PACKAGE_UNINSTALLATION_REPORTED" => {
                Some(Self::AtomPackageUninstallationReported)
            }
            "ATOM_GAME_MODE_CHANGED" => Some(Self::AtomGameModeChanged),
            "ATOM_GAME_MODE_CONFIGURATION_CHANGED" => {
                Some(Self::AtomGameModeConfigurationChanged)
            }
            "ATOM_BEDTIME_MODE_STATE_CHANGED" => Some(Self::AtomBedtimeModeStateChanged),
            "ATOM_NETWORK_SLICE_SESSION_ENDED" => {
                Some(Self::AtomNetworkSliceSessionEnded)
            }
            "ATOM_NETWORK_SLICE_DAILY_DATA_USAGE_REPORTED" => {
                Some(Self::AtomNetworkSliceDailyDataUsageReported)
            }
            "ATOM_NFC_TAG_TYPE_OCCURRED" => Some(Self::AtomNfcTagTypeOccurred),
            "ATOM_NFC_AID_CONFLICT_OCCURRED" => Some(Self::AtomNfcAidConflictOccurred),
            "ATOM_NFC_READER_CONFLICT_OCCURRED" => {
                Some(Self::AtomNfcReaderConflictOccurred)
            }
            "ATOM_WS_TILE_LIST_CHANGED" => Some(Self::AtomWsTileListChanged),
            "ATOM_GET_TYPE_ACCESSED_WITHOUT_PERMISSION" => {
                Some(Self::AtomGetTypeAccessedWithoutPermission)
            }
            "ATOM_MOBILE_BUNDLED_APP_INFO_GATHERED" => {
                Some(Self::AtomMobileBundledAppInfoGathered)
            }
            "ATOM_WS_WATCH_FACE_COMPLICATION_SET_CHANGED" => {
                Some(Self::AtomWsWatchFaceComplicationSetChanged)
            }
            "ATOM_MEDIA_DRM_CREATED" => Some(Self::AtomMediaDrmCreated),
            "ATOM_MEDIA_DRM_ERRORED" => Some(Self::AtomMediaDrmErrored),
            "ATOM_MEDIA_DRM_SESSION_OPENED" => Some(Self::AtomMediaDrmSessionOpened),
            "ATOM_MEDIA_DRM_SESSION_CLOSED" => Some(Self::AtomMediaDrmSessionClosed),
            "ATOM_USER_SELECTED_RESOLUTION" => Some(Self::AtomUserSelectedResolution),
            "ATOM_UNSAFE_INTENT_EVENT_REPORTED" => {
                Some(Self::AtomUnsafeIntentEventReported)
            }
            "ATOM_PERFORMANCE_HINT_SESSION_REPORTED" => {
                Some(Self::AtomPerformanceHintSessionReported)
            }
            "ATOM_MEDIAMETRICS_MIDI_DEVICE_CLOSE_REPORTED" => {
                Some(Self::AtomMediametricsMidiDeviceCloseReported)
            }
            "ATOM_BIOMETRIC_TOUCH_REPORTED" => Some(Self::AtomBiometricTouchReported),
            "ATOM_HOTWORD_AUDIO_EGRESS_EVENT_REPORTED" => {
                Some(Self::AtomHotwordAudioEgressEventReported)
            }
            "ATOM_APP_SEARCH_SCHEMA_MIGRATION_STATS_REPORTED" => {
                Some(Self::AtomAppSearchSchemaMigrationStatsReported)
            }
            "ATOM_LOCATION_ENABLED_STATE_CHANGED" => {
                Some(Self::AtomLocationEnabledStateChanged)
            }
            "ATOM_IME_REQUEST_FINISHED" => Some(Self::AtomImeRequestFinished),
            "ATOM_USB_COMPLIANCE_WARNINGS_REPORTED" => {
                Some(Self::AtomUsbComplianceWarningsReported)
            }
            "ATOM_APP_SUPPORTED_LOCALES_CHANGED" => {
                Some(Self::AtomAppSupportedLocalesChanged)
            }
            "ATOM_GRAMMATICAL_INFLECTION_CHANGED" => {
                Some(Self::AtomGrammaticalInflectionChanged)
            }
            "ATOM_MEDIA_PROVIDER_VOLUME_RECOVERY_REPORTED" => {
                Some(Self::AtomMediaProviderVolumeRecoveryReported)
            }
            "ATOM_BIOMETRIC_PROPERTIES_COLLECTED" => {
                Some(Self::AtomBiometricPropertiesCollected)
            }
            "ATOM_KERNEL_WAKEUP_ATTRIBUTED" => Some(Self::AtomKernelWakeupAttributed),
            "ATOM_SCREEN_STATE_CHANGED_V2" => Some(Self::AtomScreenStateChangedV2),
            "ATOM_WS_BACKUP_ACTION_REPORTED" => Some(Self::AtomWsBackupActionReported),
            "ATOM_WS_RESTORE_ACTION_REPORTED" => Some(Self::AtomWsRestoreActionReported),
            "ATOM_DEVICE_LOG_ACCESS_EVENT_REPORTED" => {
                Some(Self::AtomDeviceLogAccessEventReported)
            }
            "ATOM_MEDIA_SESSION_UPDATED" => Some(Self::AtomMediaSessionUpdated),
            "ATOM_WEAR_OOBE_STATE_CHANGED" => Some(Self::AtomWearOobeStateChanged),
            "ATOM_WS_NOTIFICATION_UPDATED" => Some(Self::AtomWsNotificationUpdated),
            "ATOM_NETWORK_VALIDATION_FAILURE_STATS_DAILY_REPORTED" => {
                Some(Self::AtomNetworkValidationFailureStatsDailyReported)
            }
            "ATOM_WS_COMPLICATION_TAPPED" => Some(Self::AtomWsComplicationTapped),
            "ATOM_WS_WEAR_TIME_SESSION" => Some(Self::AtomWsWearTimeSession),
            "ATOM_WIFI_BYTES_TRANSFER" => Some(Self::AtomWifiBytesTransfer),
            "ATOM_WIFI_BYTES_TRANSFER_BY_FG_BG" => {
                Some(Self::AtomWifiBytesTransferByFgBg)
            }
            "ATOM_MOBILE_BYTES_TRANSFER" => Some(Self::AtomMobileBytesTransfer),
            "ATOM_MOBILE_BYTES_TRANSFER_BY_FG_BG" => {
                Some(Self::AtomMobileBytesTransferByFgBg)
            }
            "ATOM_BLUETOOTH_BYTES_TRANSFER" => Some(Self::AtomBluetoothBytesTransfer),
            "ATOM_KERNEL_WAKELOCK" => Some(Self::AtomKernelWakelock),
            "ATOM_SUBSYSTEM_SLEEP_STATE" => Some(Self::AtomSubsystemSleepState),
            "ATOM_CPU_TIME_PER_UID" => Some(Self::AtomCpuTimePerUid),
            "ATOM_CPU_TIME_PER_UID_FREQ" => Some(Self::AtomCpuTimePerUidFreq),
            "ATOM_WIFI_ACTIVITY_INFO" => Some(Self::AtomWifiActivityInfo),
            "ATOM_MODEM_ACTIVITY_INFO" => Some(Self::AtomModemActivityInfo),
            "ATOM_BLUETOOTH_ACTIVITY_INFO" => Some(Self::AtomBluetoothActivityInfo),
            "ATOM_PROCESS_MEMORY_STATE" => Some(Self::AtomProcessMemoryState),
            "ATOM_SYSTEM_ELAPSED_REALTIME" => Some(Self::AtomSystemElapsedRealtime),
            "ATOM_SYSTEM_UPTIME" => Some(Self::AtomSystemUptime),
            "ATOM_CPU_ACTIVE_TIME" => Some(Self::AtomCpuActiveTime),
            "ATOM_CPU_CLUSTER_TIME" => Some(Self::AtomCpuClusterTime),
            "ATOM_DISK_SPACE" => Some(Self::AtomDiskSpace),
            "ATOM_REMAINING_BATTERY_CAPACITY" => Some(Self::AtomRemainingBatteryCapacity),
            "ATOM_FULL_BATTERY_CAPACITY" => Some(Self::AtomFullBatteryCapacity),
            "ATOM_TEMPERATURE" => Some(Self::AtomTemperature),
            "ATOM_BINDER_CALLS" => Some(Self::AtomBinderCalls),
            "ATOM_BINDER_CALLS_EXCEPTIONS" => Some(Self::AtomBinderCallsExceptions),
            "ATOM_LOOPER_STATS" => Some(Self::AtomLooperStats),
            "ATOM_DISK_STATS" => Some(Self::AtomDiskStats),
            "ATOM_DIRECTORY_USAGE" => Some(Self::AtomDirectoryUsage),
            "ATOM_APP_SIZE" => Some(Self::AtomAppSize),
            "ATOM_CATEGORY_SIZE" => Some(Self::AtomCategorySize),
            "ATOM_PROC_STATS" => Some(Self::AtomProcStats),
            "ATOM_BATTERY_VOLTAGE" => Some(Self::AtomBatteryVoltage),
            "ATOM_NUM_FINGERPRINTS_ENROLLED" => Some(Self::AtomNumFingerprintsEnrolled),
            "ATOM_DISK_IO" => Some(Self::AtomDiskIo),
            "ATOM_POWER_PROFILE" => Some(Self::AtomPowerProfile),
            "ATOM_PROC_STATS_PKG_PROC" => Some(Self::AtomProcStatsPkgProc),
            "ATOM_PROCESS_CPU_TIME" => Some(Self::AtomProcessCpuTime),
            "ATOM_CPU_TIME_PER_THREAD_FREQ" => Some(Self::AtomCpuTimePerThreadFreq),
            "ATOM_ON_DEVICE_POWER_MEASUREMENT" => {
                Some(Self::AtomOnDevicePowerMeasurement)
            }
            "ATOM_DEVICE_CALCULATED_POWER_USE" => {
                Some(Self::AtomDeviceCalculatedPowerUse)
            }
            "ATOM_PROCESS_MEMORY_HIGH_WATER_MARK" => {
                Some(Self::AtomProcessMemoryHighWaterMark)
            }
            "ATOM_BATTERY_LEVEL" => Some(Self::AtomBatteryLevel),
            "ATOM_BUILD_INFORMATION" => Some(Self::AtomBuildInformation),
            "ATOM_BATTERY_CYCLE_COUNT" => Some(Self::AtomBatteryCycleCount),
            "ATOM_DEBUG_ELAPSED_CLOCK" => Some(Self::AtomDebugElapsedClock),
            "ATOM_DEBUG_FAILING_ELAPSED_CLOCK" => {
                Some(Self::AtomDebugFailingElapsedClock)
            }
            "ATOM_NUM_FACES_ENROLLED" => Some(Self::AtomNumFacesEnrolled),
            "ATOM_ROLE_HOLDER" => Some(Self::AtomRoleHolder),
            "ATOM_DANGEROUS_PERMISSION_STATE" => Some(Self::AtomDangerousPermissionState),
            "ATOM_TRAIN_INFO" => Some(Self::AtomTrainInfo),
            "ATOM_TIME_ZONE_DATA_INFO" => Some(Self::AtomTimeZoneDataInfo),
            "ATOM_EXTERNAL_STORAGE_INFO" => Some(Self::AtomExternalStorageInfo),
            "ATOM_GPU_STATS_GLOBAL_INFO" => Some(Self::AtomGpuStatsGlobalInfo),
            "ATOM_GPU_STATS_APP_INFO" => Some(Self::AtomGpuStatsAppInfo),
            "ATOM_SYSTEM_ION_HEAP_SIZE" => Some(Self::AtomSystemIonHeapSize),
            "ATOM_APPS_ON_EXTERNAL_STORAGE_INFO" => {
                Some(Self::AtomAppsOnExternalStorageInfo)
            }
            "ATOM_FACE_SETTINGS" => Some(Self::AtomFaceSettings),
            "ATOM_COOLING_DEVICE" => Some(Self::AtomCoolingDevice),
            "ATOM_APP_OPS" => Some(Self::AtomAppOps),
            "ATOM_PROCESS_SYSTEM_ION_HEAP_SIZE" => {
                Some(Self::AtomProcessSystemIonHeapSize)
            }
            "ATOM_SURFACEFLINGER_STATS_GLOBAL_INFO" => {
                Some(Self::AtomSurfaceflingerStatsGlobalInfo)
            }
            "ATOM_SURFACEFLINGER_STATS_LAYER_INFO" => {
                Some(Self::AtomSurfaceflingerStatsLayerInfo)
            }
            "ATOM_PROCESS_MEMORY_SNAPSHOT" => Some(Self::AtomProcessMemorySnapshot),
            "ATOM_VMS_CLIENT_STATS" => Some(Self::AtomVmsClientStats),
            "ATOM_NOTIFICATION_REMOTE_VIEWS" => Some(Self::AtomNotificationRemoteViews),
            "ATOM_DANGEROUS_PERMISSION_STATE_SAMPLED" => {
                Some(Self::AtomDangerousPermissionStateSampled)
            }
            "ATOM_GRAPHICS_STATS" => Some(Self::AtomGraphicsStats),
            "ATOM_RUNTIME_APP_OP_ACCESS" => Some(Self::AtomRuntimeAppOpAccess),
            "ATOM_ION_HEAP_SIZE" => Some(Self::AtomIonHeapSize),
            "ATOM_PACKAGE_NOTIFICATION_PREFERENCES" => {
                Some(Self::AtomPackageNotificationPreferences)
            }
            "ATOM_PACKAGE_NOTIFICATION_CHANNEL_PREFERENCES" => {
                Some(Self::AtomPackageNotificationChannelPreferences)
            }
            "ATOM_PACKAGE_NOTIFICATION_CHANNEL_GROUP_PREFERENCES" => {
                Some(Self::AtomPackageNotificationChannelGroupPreferences)
            }
            "ATOM_GNSS_STATS" => Some(Self::AtomGnssStats),
            "ATOM_ATTRIBUTED_APP_OPS" => Some(Self::AtomAttributedAppOps),
            "ATOM_VOICE_CALL_SESSION" => Some(Self::AtomVoiceCallSession),
            "ATOM_VOICE_CALL_RAT_USAGE" => Some(Self::AtomVoiceCallRatUsage),
            "ATOM_SIM_SLOT_STATE" => Some(Self::AtomSimSlotState),
            "ATOM_SUPPORTED_RADIO_ACCESS_FAMILY" => {
                Some(Self::AtomSupportedRadioAccessFamily)
            }
            "ATOM_SETTING_SNAPSHOT" => Some(Self::AtomSettingSnapshot),
            "ATOM_BLOB_INFO" => Some(Self::AtomBlobInfo),
            "ATOM_DATA_USAGE_BYTES_TRANSFER" => Some(Self::AtomDataUsageBytesTransfer),
            "ATOM_BYTES_TRANSFER_BY_TAG_AND_METERED" => {
                Some(Self::AtomBytesTransferByTagAndMetered)
            }
            "ATOM_DND_MODE_RULE" => Some(Self::AtomDndModeRule),
            "ATOM_GENERAL_EXTERNAL_STORAGE_ACCESS_STATS" => {
                Some(Self::AtomGeneralExternalStorageAccessStats)
            }
            "ATOM_INCOMING_SMS" => Some(Self::AtomIncomingSms),
            "ATOM_OUTGOING_SMS" => Some(Self::AtomOutgoingSms),
            "ATOM_CARRIER_ID_TABLE_VERSION" => Some(Self::AtomCarrierIdTableVersion),
            "ATOM_DATA_CALL_SESSION" => Some(Self::AtomDataCallSession),
            "ATOM_CELLULAR_SERVICE_STATE" => Some(Self::AtomCellularServiceState),
            "ATOM_CELLULAR_DATA_SERVICE_SWITCH" => {
                Some(Self::AtomCellularDataServiceSwitch)
            }
            "ATOM_SYSTEM_MEMORY" => Some(Self::AtomSystemMemory),
            "ATOM_IMS_REGISTRATION_TERMINATION" => {
                Some(Self::AtomImsRegistrationTermination)
            }
            "ATOM_IMS_REGISTRATION_STATS" => Some(Self::AtomImsRegistrationStats),
            "ATOM_CPU_TIME_PER_CLUSTER_FREQ" => Some(Self::AtomCpuTimePerClusterFreq),
            "ATOM_CPU_CYCLES_PER_UID_CLUSTER" => Some(Self::AtomCpuCyclesPerUidCluster),
            "ATOM_DEVICE_ROTATED_DATA" => Some(Self::AtomDeviceRotatedData),
            "ATOM_CPU_CYCLES_PER_THREAD_GROUP_CLUSTER" => {
                Some(Self::AtomCpuCyclesPerThreadGroupCluster)
            }
            "ATOM_MEDIA_DRM_ACTIVITY_INFO" => Some(Self::AtomMediaDrmActivityInfo),
            "ATOM_OEM_MANAGED_BYTES_TRANSFER" => Some(Self::AtomOemManagedBytesTransfer),
            "ATOM_GNSS_POWER_STATS" => Some(Self::AtomGnssPowerStats),
            "ATOM_TIME_ZONE_DETECTOR_STATE" => Some(Self::AtomTimeZoneDetectorState),
            "ATOM_KEYSTORE2_STORAGE_STATS" => Some(Self::AtomKeystore2StorageStats),
            "ATOM_RKP_POOL_STATS" => Some(Self::AtomRkpPoolStats),
            "ATOM_PROCESS_DMABUF_MEMORY" => Some(Self::AtomProcessDmabufMemory),
            "ATOM_PENDING_ALARM_INFO" => Some(Self::AtomPendingAlarmInfo),
            "ATOM_USER_LEVEL_HIBERNATED_APPS" => Some(Self::AtomUserLevelHibernatedApps),
            "ATOM_LAUNCHER_LAYOUT_SNAPSHOT" => Some(Self::AtomLauncherLayoutSnapshot),
            "ATOM_GLOBAL_HIBERNATED_APPS" => Some(Self::AtomGlobalHibernatedApps),
            "ATOM_INPUT_EVENT_LATENCY_SKETCH" => Some(Self::AtomInputEventLatencySketch),
            "ATOM_BATTERY_USAGE_STATS_BEFORE_RESET" => {
                Some(Self::AtomBatteryUsageStatsBeforeReset)
            }
            "ATOM_BATTERY_USAGE_STATS_SINCE_RESET" => {
                Some(Self::AtomBatteryUsageStatsSinceReset)
            }
            "ATOM_BATTERY_USAGE_STATS_SINCE_RESET_USING_POWER_PROFILE_MODEL" => {
                Some(Self::AtomBatteryUsageStatsSinceResetUsingPowerProfileModel)
            }
            "ATOM_INSTALLED_INCREMENTAL_PACKAGE" => {
                Some(Self::AtomInstalledIncrementalPackage)
            }
            "ATOM_TELEPHONY_NETWORK_REQUESTS" => Some(Self::AtomTelephonyNetworkRequests),
            "ATOM_APP_SEARCH_STORAGE_INFO" => Some(Self::AtomAppSearchStorageInfo),
            "ATOM_VMSTAT" => Some(Self::AtomVmstat),
            "ATOM_KEYSTORE2_KEY_CREATION_WITH_GENERAL_INFO" => {
                Some(Self::AtomKeystore2KeyCreationWithGeneralInfo)
            }
            "ATOM_KEYSTORE2_KEY_CREATION_WITH_AUTH_INFO" => {
                Some(Self::AtomKeystore2KeyCreationWithAuthInfo)
            }
            "ATOM_KEYSTORE2_KEY_CREATION_WITH_PURPOSE_AND_MODES_INFO" => {
                Some(Self::AtomKeystore2KeyCreationWithPurposeAndModesInfo)
            }
            "ATOM_KEYSTORE2_ATOM_WITH_OVERFLOW" => {
                Some(Self::AtomKeystore2AtomWithOverflow)
            }
            "ATOM_KEYSTORE2_KEY_OPERATION_WITH_PURPOSE_AND_MODES_INFO" => {
                Some(Self::AtomKeystore2KeyOperationWithPurposeAndModesInfo)
            }
            "ATOM_KEYSTORE2_KEY_OPERATION_WITH_GENERAL_INFO" => {
                Some(Self::AtomKeystore2KeyOperationWithGeneralInfo)
            }
            "ATOM_RKP_ERROR_STATS" => Some(Self::AtomRkpErrorStats),
            "ATOM_KEYSTORE2_CRASH_STATS" => Some(Self::AtomKeystore2CrashStats),
            "ATOM_VENDOR_APEX_INFO" => Some(Self::AtomVendorApexInfo),
            "ATOM_ACCESSIBILITY_SHORTCUT_STATS" => {
                Some(Self::AtomAccessibilityShortcutStats)
            }
            "ATOM_ACCESSIBILITY_FLOATING_MENU_STATS" => {
                Some(Self::AtomAccessibilityFloatingMenuStats)
            }
            "ATOM_DATA_USAGE_BYTES_TRANSFER_V2" => {
                Some(Self::AtomDataUsageBytesTransferV2)
            }
            "ATOM_MEDIA_CAPABILITIES" => Some(Self::AtomMediaCapabilities),
            "ATOM_CAR_WATCHDOG_SYSTEM_IO_USAGE_SUMMARY" => {
                Some(Self::AtomCarWatchdogSystemIoUsageSummary)
            }
            "ATOM_CAR_WATCHDOG_UID_IO_USAGE_SUMMARY" => {
                Some(Self::AtomCarWatchdogUidIoUsageSummary)
            }
            "ATOM_IMS_REGISTRATION_FEATURE_TAG_STATS" => {
                Some(Self::AtomImsRegistrationFeatureTagStats)
            }
            "ATOM_RCS_CLIENT_PROVISIONING_STATS" => {
                Some(Self::AtomRcsClientProvisioningStats)
            }
            "ATOM_RCS_ACS_PROVISIONING_STATS" => Some(Self::AtomRcsAcsProvisioningStats),
            "ATOM_SIP_DELEGATE_STATS" => Some(Self::AtomSipDelegateStats),
            "ATOM_SIP_TRANSPORT_FEATURE_TAG_STATS" => {
                Some(Self::AtomSipTransportFeatureTagStats)
            }
            "ATOM_SIP_MESSAGE_RESPONSE" => Some(Self::AtomSipMessageResponse),
            "ATOM_SIP_TRANSPORT_SESSION" => Some(Self::AtomSipTransportSession),
            "ATOM_IMS_DEDICATED_BEARER_LISTENER_EVENT" => {
                Some(Self::AtomImsDedicatedBearerListenerEvent)
            }
            "ATOM_IMS_DEDICATED_BEARER_EVENT" => Some(Self::AtomImsDedicatedBearerEvent),
            "ATOM_IMS_REGISTRATION_SERVICE_DESC_STATS" => {
                Some(Self::AtomImsRegistrationServiceDescStats)
            }
            "ATOM_UCE_EVENT_STATS" => Some(Self::AtomUceEventStats),
            "ATOM_PRESENCE_NOTIFY_EVENT" => Some(Self::AtomPresenceNotifyEvent),
            "ATOM_GBA_EVENT" => Some(Self::AtomGbaEvent),
            "ATOM_PER_SIM_STATUS" => Some(Self::AtomPerSimStatus),
            "ATOM_GPU_WORK_PER_UID" => Some(Self::AtomGpuWorkPerUid),
            "ATOM_PERSISTENT_URI_PERMISSIONS_AMOUNT_PER_PACKAGE" => {
                Some(Self::AtomPersistentUriPermissionsAmountPerPackage)
            }
            "ATOM_SIGNED_PARTITION_INFO" => Some(Self::AtomSignedPartitionInfo),
            "ATOM_PINNED_FILE_SIZES_PER_PACKAGE" => {
                Some(Self::AtomPinnedFileSizesPerPackage)
            }
            "ATOM_PENDING_INTENTS_PER_PACKAGE" => {
                Some(Self::AtomPendingIntentsPerPackage)
            }
            "ATOM_USER_INFO" => Some(Self::AtomUserInfo),
            "ATOM_TELEPHONY_NETWORK_REQUESTS_V2" => {
                Some(Self::AtomTelephonyNetworkRequestsV2)
            }
            "ATOM_DEVICE_TELEPHONY_PROPERTIES" => {
                Some(Self::AtomDeviceTelephonyProperties)
            }
            "ATOM_REMOTE_KEY_PROVISIONING_ERROR_COUNTS" => {
                Some(Self::AtomRemoteKeyProvisioningErrorCounts)
            }
            "ATOM_SAFETY_STATE" => Some(Self::AtomSafetyState),
            "ATOM_INCOMING_MMS" => Some(Self::AtomIncomingMms),
            "ATOM_OUTGOING_MMS" => Some(Self::AtomOutgoingMms),
            "ATOM_MULTI_USER_INFO" => Some(Self::AtomMultiUserInfo),
            "ATOM_NETWORK_BPF_MAP_INFO" => Some(Self::AtomNetworkBpfMapInfo),
            "ATOM_OUTGOING_SHORT_CODE_SMS" => Some(Self::AtomOutgoingShortCodeSms),
            "ATOM_CONNECTIVITY_STATE_SAMPLE" => Some(Self::AtomConnectivityStateSample),
            "ATOM_NETWORK_SELECTION_REMATCH_REASONS_INFO" => {
                Some(Self::AtomNetworkSelectionRematchReasonsInfo)
            }
            "ATOM_GAME_MODE_INFO" => Some(Self::AtomGameModeInfo),
            "ATOM_GAME_MODE_CONFIGURATION" => Some(Self::AtomGameModeConfiguration),
            "ATOM_GAME_MODE_LISTENER" => Some(Self::AtomGameModeListener),
            "ATOM_NETWORK_SLICE_REQUEST_COUNT" => {
                Some(Self::AtomNetworkSliceRequestCount)
            }
            "ATOM_WS_TILE_SNAPSHOT" => Some(Self::AtomWsTileSnapshot),
            "ATOM_WS_ACTIVE_WATCH_FACE_COMPLICATION_SET_SNAPSHOT" => {
                Some(Self::AtomWsActiveWatchFaceComplicationSetSnapshot)
            }
            "ATOM_PROCESS_STATE" => Some(Self::AtomProcessState),
            "ATOM_PROCESS_ASSOCIATION" => Some(Self::AtomProcessAssociation),
            "ATOM_ADPF_SYSTEM_COMPONENT_INFO" => Some(Self::AtomAdpfSystemComponentInfo),
            "ATOM_NOTIFICATION_MEMORY_USE" => Some(Self::AtomNotificationMemoryUse),
            "ATOM_HDR_CAPABILITIES" => Some(Self::AtomHdrCapabilities),
            "ATOM_WS_FAVOURITE_WATCH_FACE_LIST_SNAPSHOT" => {
                Some(Self::AtomWsFavouriteWatchFaceListSnapshot)
            }
            "ATOM_WIFI_AWARE_NDP_REPORTED" => Some(Self::AtomWifiAwareNdpReported),
            "ATOM_WIFI_AWARE_ATTACH_REPORTED" => Some(Self::AtomWifiAwareAttachReported),
            "ATOM_WIFI_SELF_RECOVERY_TRIGGERED" => {
                Some(Self::AtomWifiSelfRecoveryTriggered)
            }
            "ATOM_SOFT_AP_STARTED" => Some(Self::AtomSoftApStarted),
            "ATOM_SOFT_AP_STOPPED" => Some(Self::AtomSoftApStopped),
            "ATOM_WIFI_LOCK_RELEASED" => Some(Self::AtomWifiLockReleased),
            "ATOM_WIFI_LOCK_DEACTIVATED" => Some(Self::AtomWifiLockDeactivated),
            "ATOM_WIFI_CONFIG_SAVED" => Some(Self::AtomWifiConfigSaved),
            "ATOM_WIFI_AWARE_RESOURCE_USING_CHANGED" => {
                Some(Self::AtomWifiAwareResourceUsingChanged)
            }
            "ATOM_WIFI_AWARE_HAL_API_CALLED" => Some(Self::AtomWifiAwareHalApiCalled),
            "ATOM_WIFI_LOCAL_ONLY_REQUEST_RECEIVED" => {
                Some(Self::AtomWifiLocalOnlyRequestReceived)
            }
            "ATOM_WIFI_LOCAL_ONLY_REQUEST_SCAN_TRIGGERED" => {
                Some(Self::AtomWifiLocalOnlyRequestScanTriggered)
            }
            "ATOM_WIFI_THREAD_TASK_EXECUTED" => Some(Self::AtomWifiThreadTaskExecuted),
            "ATOM_WIFI_STATE_CHANGED" => Some(Self::AtomWifiStateChanged),
            "ATOM_WIFI_AWARE_CAPABILITIES" => Some(Self::AtomWifiAwareCapabilities),
            "ATOM_WIFI_MODULE_INFO" => Some(Self::AtomWifiModuleInfo),
            "ATOM_SETTINGS_SPA_REPORTED" => Some(Self::AtomSettingsSpaReported),
            "ATOM_EXPRESS_EVENT_REPORTED" => Some(Self::AtomExpressEventReported),
            "ATOM_EXPRESS_HISTOGRAM_SAMPLE_REPORTED" => {
                Some(Self::AtomExpressHistogramSampleReported)
            }
            "ATOM_EXPRESS_UID_EVENT_REPORTED" => Some(Self::AtomExpressUidEventReported),
            "ATOM_EXPRESS_UID_HISTOGRAM_SAMPLE_REPORTED" => {
                Some(Self::AtomExpressUidHistogramSampleReported)
            }
            "ATOM_PERMISSION_RATIONALE_DIALOG_VIEWED" => {
                Some(Self::AtomPermissionRationaleDialogViewed)
            }
            "ATOM_PERMISSION_RATIONALE_DIALOG_ACTION_REPORTED" => {
                Some(Self::AtomPermissionRationaleDialogActionReported)
            }
            "ATOM_APP_DATA_SHARING_UPDATES_NOTIFICATION_INTERACTION" => {
                Some(Self::AtomAppDataSharingUpdatesNotificationInteraction)
            }
            "ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_VIEWED" => {
                Some(Self::AtomAppDataSharingUpdatesFragmentViewed)
            }
            "ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_ACTION_REPORTED" => {
                Some(Self::AtomAppDataSharingUpdatesFragmentActionReported)
            }
            "ATOM_WS_INCOMING_CALL_ACTION_REPORTED" => {
                Some(Self::AtomWsIncomingCallActionReported)
            }
            "ATOM_WS_CALL_DISCONNECTION_REPORTED" => {
                Some(Self::AtomWsCallDisconnectionReported)
            }
            "ATOM_WS_CALL_DURATION_REPORTED" => Some(Self::AtomWsCallDurationReported),
            "ATOM_WS_CALL_USER_EXPERIENCE_LATENCY_REPORTED" => {
                Some(Self::AtomWsCallUserExperienceLatencyReported)
            }
            "ATOM_WS_CALL_INTERACTION_REPORTED" => {
                Some(Self::AtomWsCallInteractionReported)
            }
            "ATOM_FULL_SCREEN_INTENT_LAUNCHED" => {
                Some(Self::AtomFullScreenIntentLaunched)
            }
            "ATOM_BAL_ALLOWED" => Some(Self::AtomBalAllowed),
            "ATOM_IN_TASK_ACTIVITY_STARTED" => Some(Self::AtomInTaskActivityStarted),
            "ATOM_CACHED_APPS_HIGH_WATERMARK" => Some(Self::AtomCachedAppsHighWatermark),
            "ATOM_ODREFRESH_REPORTED" => Some(Self::AtomOdrefreshReported),
            "ATOM_ODSIGN_REPORTED" => Some(Self::AtomOdsignReported),
            "ATOM_ART_DATUM_REPORTED" => Some(Self::AtomArtDatumReported),
            "ATOM_ART_DEVICE_DATUM_REPORTED" => Some(Self::AtomArtDeviceDatumReported),
            "ATOM_ART_DATUM_DELTA_REPORTED" => Some(Self::AtomArtDatumDeltaReported),
            "ATOM_BACKGROUND_DEXOPT_JOB_ENDED" => {
                Some(Self::AtomBackgroundDexoptJobEnded)
            }
            "ATOM_WEAR_ADAPTIVE_SUSPEND_STATS_REPORTED" => {
                Some(Self::AtomWearAdaptiveSuspendStatsReported)
            }
            "ATOM_WEAR_POWER_ANOMALY_SERVICE_OPERATIONAL_STATS_REPORTED" => {
                Some(Self::AtomWearPowerAnomalyServiceOperationalStatsReported)
            }
            "ATOM_WEAR_POWER_ANOMALY_SERVICE_EVENT_STATS_REPORTED" => {
                Some(Self::AtomWearPowerAnomalyServiceEventStatsReported)
            }
            "ATOM_EMERGENCY_STATE_CHANGED" => Some(Self::AtomEmergencyStateChanged),
            "ATOM_DND_STATE_CHANGED" => Some(Self::AtomDndStateChanged),
            "ATOM_MTE_STATE" => Some(Self::AtomMteState),
            "ATOM_AD_SERVICES_BACK_COMPAT_GET_TOPICS_REPORTED" => {
                Some(Self::AtomAdServicesBackCompatGetTopicsReported)
            }
            "ATOM_AD_SERVICES_BACK_COMPAT_EPOCH_COMPUTATION_CLASSIFIER_REPORTED" => {
                Some(Self::AtomAdServicesBackCompatEpochComputationClassifierReported)
            }
            "ATOM_AD_SERVICES_MEASUREMENT_DEBUG_KEYS" => {
                Some(Self::AtomAdServicesMeasurementDebugKeys)
            }
            "ATOM_AD_SERVICES_ERROR_REPORTED" => Some(Self::AtomAdServicesErrorReported),
            "ATOM_AD_SERVICES_BACKGROUND_JOBS_EXECUTION_REPORTED" => {
                Some(Self::AtomAdServicesBackgroundJobsExecutionReported)
            }
            "ATOM_AD_SERVICES_MEASUREMENT_DELAYED_SOURCE_REGISTRATION" => {
                Some(Self::AtomAdServicesMeasurementDelayedSourceRegistration)
            }
            "ATOM_AD_SERVICES_MEASUREMENT_ATTRIBUTION" => {
                Some(Self::AtomAdServicesMeasurementAttribution)
            }
            "ATOM_AD_SERVICES_MEASUREMENT_JOBS" => {
                Some(Self::AtomAdServicesMeasurementJobs)
            }
            "ATOM_AD_SERVICES_MEASUREMENT_WIPEOUT" => {
                Some(Self::AtomAdServicesMeasurementWipeout)
            }
            "ATOM_AD_SERVICES_CONSENT_MIGRATED" => {
                Some(Self::AtomAdServicesConsentMigrated)
            }
            "ATOM_RKPD_POOL_STATS" => Some(Self::AtomRkpdPoolStats),
            "ATOM_RKPD_CLIENT_OPERATION" => Some(Self::AtomRkpdClientOperation),
            "ATOM_AUTOFILL_UI_EVENT_REPORTED" => Some(Self::AtomAutofillUiEventReported),
            "ATOM_AUTOFILL_FILL_REQUEST_REPORTED" => {
                Some(Self::AtomAutofillFillRequestReported)
            }
            "ATOM_AUTOFILL_FILL_RESPONSE_REPORTED" => {
                Some(Self::AtomAutofillFillResponseReported)
            }
            "ATOM_AUTOFILL_SAVE_EVENT_REPORTED" => {
                Some(Self::AtomAutofillSaveEventReported)
            }
            "ATOM_AUTOFILL_SESSION_COMMITTED" => Some(Self::AtomAutofillSessionCommitted),
            "ATOM_AUTOFILL_FIELD_CLASSIFICATION_EVENT_REPORTED" => {
                Some(Self::AtomAutofillFieldClassificationEventReported)
            }
            "ATOM_TEST_EXTENSION_ATOM_REPORTED" => {
                Some(Self::AtomTestExtensionAtomReported)
            }
            "ATOM_TEST_RESTRICTED_ATOM_REPORTED" => {
                Some(Self::AtomTestRestrictedAtomReported)
            }
            "ATOM_STATS_SOCKET_LOSS_REPORTED" => Some(Self::AtomStatsSocketLossReported),
            "ATOM_PLUGIN_INITIALIZED" => Some(Self::AtomPluginInitialized),
            "ATOM_TV_LOW_POWER_STANDBY_POLICY" => Some(Self::AtomTvLowPowerStandbyPolicy),
            "ATOM_LOCKSCREEN_SHORTCUT_SELECTED" => {
                Some(Self::AtomLockscreenShortcutSelected)
            }
            "ATOM_LOCKSCREEN_SHORTCUT_TRIGGERED" => {
                Some(Self::AtomLockscreenShortcutTriggered)
            }
            "ATOM_EMERGENCY_NUMBERS_INFO" => Some(Self::AtomEmergencyNumbersInfo),
            "ATOM_QUALIFIED_RAT_LIST_CHANGED" => Some(Self::AtomQualifiedRatListChanged),
            "ATOM_QNS_IMS_CALL_DROP_STATS" => Some(Self::AtomQnsImsCallDropStats),
            "ATOM_QNS_FALLBACK_RESTRICTION_CHANGED" => {
                Some(Self::AtomQnsFallbackRestrictionChanged)
            }
            "ATOM_QNS_RAT_PREFERENCE_MISMATCH_INFO" => {
                Some(Self::AtomQnsRatPreferenceMismatchInfo)
            }
            "ATOM_QNS_HANDOVER_TIME_MILLIS" => Some(Self::AtomQnsHandoverTimeMillis),
            "ATOM_QNS_HANDOVER_PINGPONG" => Some(Self::AtomQnsHandoverPingpong),
            "ATOM_SATELLITE_CONTROLLER" => Some(Self::AtomSatelliteController),
            "ATOM_SATELLITE_SESSION" => Some(Self::AtomSatelliteSession),
            "ATOM_SATELLITE_INCOMING_DATAGRAM" => {
                Some(Self::AtomSatelliteIncomingDatagram)
            }
            "ATOM_SATELLITE_OUTGOING_DATAGRAM" => {
                Some(Self::AtomSatelliteOutgoingDatagram)
            }
            "ATOM_SATELLITE_PROVISION" => Some(Self::AtomSatelliteProvision),
            "ATOM_SATELLITE_SOS_MESSAGE_RECOMMENDER" => {
                Some(Self::AtomSatelliteSosMessageRecommender)
            }
            "ATOM_IKE_SESSION_TERMINATED" => Some(Self::AtomIkeSessionTerminated),
            "ATOM_IKE_LIVENESS_CHECK_SESSION_VALIDATED" => {
                Some(Self::AtomIkeLivenessCheckSessionValidated)
            }
            "ATOM_BLUETOOTH_HASHED_DEVICE_NAME_REPORTED" => {
                Some(Self::AtomBluetoothHashedDeviceNameReported)
            }
            "ATOM_BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION" => {
                Some(Self::AtomBluetoothL2capCocClientConnection)
            }
            "ATOM_BLUETOOTH_L2CAP_COC_SERVER_CONNECTION" => {
                Some(Self::AtomBluetoothL2capCocServerConnection)
            }
            "ATOM_BLUETOOTH_LE_SESSION_CONNECTED" => {
                Some(Self::AtomBluetoothLeSessionConnected)
            }
            "ATOM_RESTRICTED_BLUETOOTH_DEVICE_NAME_REPORTED" => {
                Some(Self::AtomRestrictedBluetoothDeviceNameReported)
            }
            "ATOM_BLUETOOTH_PROFILE_CONNECTION_ATTEMPTED" => {
                Some(Self::AtomBluetoothProfileConnectionAttempted)
            }
            "ATOM_HEALTH_CONNECT_UI_IMPRESSION" => {
                Some(Self::AtomHealthConnectUiImpression)
            }
            "ATOM_HEALTH_CONNECT_UI_INTERACTION" => {
                Some(Self::AtomHealthConnectUiInteraction)
            }
            "ATOM_HEALTH_CONNECT_APP_OPENED_REPORTED" => {
                Some(Self::AtomHealthConnectAppOpenedReported)
            }
            "ATOM_HEALTH_CONNECT_API_CALLED" => Some(Self::AtomHealthConnectApiCalled),
            "ATOM_HEALTH_CONNECT_USAGE_STATS" => Some(Self::AtomHealthConnectUsageStats),
            "ATOM_HEALTH_CONNECT_STORAGE_STATS" => {
                Some(Self::AtomHealthConnectStorageStats)
            }
            "ATOM_HEALTH_CONNECT_API_INVOKED" => Some(Self::AtomHealthConnectApiInvoked),
            "ATOM_EXERCISE_ROUTE_API_CALLED" => Some(Self::AtomExerciseRouteApiCalled),
            "ATOM_ATOM_9999" => Some(Self::AtomAtom9999),
            "ATOM_ATOM_99999" => Some(Self::AtomAtom99999),
            "ATOM_THREADNETWORK_TELEMETRY_DATA_REPORTED" => {
                Some(Self::AtomThreadnetworkTelemetryDataReported)
            }
            "ATOM_THREADNETWORK_TOPO_ENTRY_REPEATED" => {
                Some(Self::AtomThreadnetworkTopoEntryRepeated)
            }
            "ATOM_THREADNETWORK_DEVICE_INFO_REPORTED" => {
                Some(Self::AtomThreadnetworkDeviceInfoReported)
            }
            "ATOM_EMERGENCY_NUMBER_DIALED" => Some(Self::AtomEmergencyNumberDialed),
            "ATOM_SANDBOX_API_CALLED" => Some(Self::AtomSandboxApiCalled),
            "ATOM_SANDBOX_ACTIVITY_EVENT_OCCURRED" => {
                Some(Self::AtomSandboxActivityEventOccurred)
            }
            "ATOM_SANDBOX_SDK_STORAGE" => Some(Self::AtomSandboxSdkStorage),
            "ATOM_CRONET_ENGINE_CREATED" => Some(Self::AtomCronetEngineCreated),
            "ATOM_CRONET_TRAFFIC_REPORTED" => Some(Self::AtomCronetTrafficReported),
            "ATOM_CRONET_ENGINE_BUILDER_INITIALIZED" => {
                Some(Self::AtomCronetEngineBuilderInitialized)
            }
            "ATOM_CRONET_HTTP_FLAGS_INITIALIZED" => {
                Some(Self::AtomCronetHttpFlagsInitialized)
            }
            "ATOM_CRONET_INITIALIZED" => Some(Self::AtomCronetInitialized),
            "ATOM_DAILY_KEEPALIVE_INFO_REPORTED" => {
                Some(Self::AtomDailyKeepaliveInfoReported)
            }
            "ATOM_IP_CLIENT_RA_INFO_REPORTED" => Some(Self::AtomIpClientRaInfoReported),
            "ATOM_APF_SESSION_INFO_REPORTED" => Some(Self::AtomApfSessionInfoReported),
            "ATOM_CREDENTIAL_MANAGER_API_CALLED" => {
                Some(Self::AtomCredentialManagerApiCalled)
            }
            "ATOM_CREDENTIAL_MANAGER_INIT_PHASE_REPORTED" => {
                Some(Self::AtomCredentialManagerInitPhaseReported)
            }
            "ATOM_CREDENTIAL_MANAGER_CANDIDATE_PHASE_REPORTED" => {
                Some(Self::AtomCredentialManagerCandidatePhaseReported)
            }
            "ATOM_CREDENTIAL_MANAGER_FINAL_PHASE_REPORTED" => {
                Some(Self::AtomCredentialManagerFinalPhaseReported)
            }
            "ATOM_CREDENTIAL_MANAGER_TOTAL_REPORTED" => {
                Some(Self::AtomCredentialManagerTotalReported)
            }
            "ATOM_CREDENTIAL_MANAGER_FINALNOUID_REPORTED" => {
                Some(Self::AtomCredentialManagerFinalnouidReported)
            }
            "ATOM_CREDENTIAL_MANAGER_GET_REPORTED" => {
                Some(Self::AtomCredentialManagerGetReported)
            }
            "ATOM_CREDENTIAL_MANAGER_AUTH_CLICK_REPORTED" => {
                Some(Self::AtomCredentialManagerAuthClickReported)
            }
            "ATOM_CREDENTIAL_MANAGER_APIV2_CALLED" => {
                Some(Self::AtomCredentialManagerApiv2Called)
            }
            "ATOM_UWB_ACTIVITY_INFO" => Some(Self::AtomUwbActivityInfo),
            "ATOM_MEDIA_ACTION_REPORTED" => Some(Self::AtomMediaActionReported),
            "ATOM_MEDIA_CONTROLS_LAUNCHED" => Some(Self::AtomMediaControlsLaunched),
            "ATOM_MEDIA_CODEC_RECLAIM_REQUEST_COMPLETED" => {
                Some(Self::AtomMediaCodecReclaimRequestCompleted)
            }
            "ATOM_MEDIA_CODEC_STARTED" => Some(Self::AtomMediaCodecStarted),
            "ATOM_MEDIA_CODEC_STOPPED" => Some(Self::AtomMediaCodecStopped),
            "ATOM_MEDIA_CODEC_RENDERED" => Some(Self::AtomMediaCodecRendered),
            _ => None,
        }
    }
}
/// This file is named 'statsd_tracing_config.proto' rather than
/// 'statsd_config.proto' (which would be more consistent with the other
/// config protos) so it doesn't show up and confuse folks looking for
/// the existing statsd_config.proto for configuring statsd itself.
/// Same for the config proto itself.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsdTracingConfig {
    /// This is for the common case of the atom id being known in the enum AtomId.
    #[prost(enumeration = "AtomId", repeated, packed = "false", tag = "1")]
    pub push_atom_id: ::prost::alloc::vec::Vec<i32>,
    /// Escape hatch for Atom IDs that are not yet in the AtomId enum
    /// (e.g. non-upstream atoms that don't exist in AOSP).
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub raw_push_atom_id: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "3")]
    pub pull_config: ::prost::alloc::vec::Vec<StatsdPullAtomConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsdPullAtomConfig {
    #[prost(enumeration = "AtomId", repeated, packed = "false", tag = "1")]
    pub pull_atom_id: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub raw_pull_atom_id: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "3")]
    pub pull_frequency_ms: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "4")]
    pub packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessStatsConfig {
    #[prost(
        enumeration = "process_stats_config::Quirks",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub quirks: ::prost::alloc::vec::Vec<i32>,
    /// If enabled all processes will be scanned and dumped when the trace starts.
    #[prost(bool, optional, tag = "2")]
    pub scan_all_processes_on_start: ::core::option::Option<bool>,
    /// If enabled thread names are also recoded (this is redundant if sched_switch
    /// is enabled).
    #[prost(bool, optional, tag = "3")]
    pub record_thread_names: ::core::option::Option<bool>,
    /// If > 0 samples counters (see process_stats.proto) from
    /// /proc/pid/status and oom_score_adj every X ms.
    /// It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
    /// This is required to be > 100ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "4")]
    pub proc_stats_poll_ms: ::core::option::Option<u32>,
    /// This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
    /// (default: |proc_stats_poll_ms|). If = 0, will be set to
    /// |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
    /// multiple.
    #[prost(uint32, optional, tag = "6")]
    pub proc_stats_cache_ttl_ms: ::core::option::Option<u32>,
    /// Niche feature: If true this will resolve file descriptors for each process
    /// so these can be mapped to their actual device or file.
    /// Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
    /// new fds opened after initially scanning a process will not be
    /// recognized.
    #[prost(bool, optional, tag = "9")]
    pub resolve_process_fds: ::core::option::Option<bool>,
    /// If true, output will include memory stats from /proc/pid/smaps_rollup.
    #[prost(bool, optional, tag = "10")]
    pub scan_smaps_rollup: ::core::option::Option<bool>,
    /// If true: process descriptions will include process age (starttime in
    /// /proc/pid/stat).
    /// Introduced in: perfetto v44.
    #[prost(bool, optional, tag = "11")]
    pub record_process_age: ::core::option::Option<bool>,
    /// If true and |proc_stats_poll_ms| is true, process stats will include time
    /// spent running in user/kernel mode (utime/stime in /proc/pid/stat).
    /// Introduced in: perfetto v44.
    #[prost(bool, optional, tag = "12")]
    pub record_process_runtime: ::core::option::Option<bool>,
}
/// Nested message and enum types in `ProcessStatsConfig`.
pub mod process_stats_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Quirks {
        Unspecified = 0,
        /// This has been deprecated and ignored as per 2018-05-01. Full scan at
        /// startup is now disabled by default and can be re-enabled using the
        /// |scan_all_processes_on_start| arg.
        DisableInitialDump = 1,
        DisableOnDemand = 2,
    }
    impl Quirks {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "QUIRKS_UNSPECIFIED",
                Self::DisableInitialDump => "DISABLE_INITIAL_DUMP",
                Self::DisableOnDemand => "DISABLE_ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "QUIRKS_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLE_INITIAL_DUMP" => Some(Self::DisableInitialDump),
                "DISABLE_ON_DEMAND" => Some(Self::DisableOnDemand),
                _ => None,
            }
        }
    }
}
/// Configuration for go/heapprofd.
/// Next id: 28
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeapprofdConfig {
    /// Sampling rate for all heaps not specified via heap_sampling_intervals.
    ///
    /// These are:
    /// * All heaps if heap_sampling_intervals is empty.
    /// * Those profiled due to all_heaps and not named in heaps if
    ///    heap_sampling_intervals is not empty.
    /// * The implicit libc.malloc heap if heaps is empty.
    ///
    /// Set to 1 for perfect accuracy.
    /// Otherwise, sample every sample_interval_bytes on average.
    ///
    /// See
    /// <https://perfetto.dev/docs/data-sources/native-heap-profiler#sampling-interval>
    /// for more details.
    ///
    /// BUGS
    /// Before Android 12, setting this to 0 would crash the target process.
    ///
    /// N.B. This must be explicitly set to a non-zero value for all heaps (with
    /// this field or with heap_sampling_intervals), otherwise the producer will
    /// not start.
    #[prost(uint64, optional, tag = "1")]
    pub sampling_interval_bytes: ::core::option::Option<u64>,
    /// If less than the given numbers of bytes are left free in the shared
    /// memory buffer, increase sampling interval by a factor of two.
    /// Adaptive sampling is disabled when set to 0.
    #[prost(uint64, optional, tag = "24")]
    pub adaptive_sampling_shmem_threshold: ::core::option::Option<u64>,
    /// Stop doubling the sampling_interval once the sampling interval has reached
    /// this value.
    #[prost(uint64, optional, tag = "25")]
    pub adaptive_sampling_max_sampling_interval_bytes: ::core::option::Option<u64>,
    /// E.g. surfaceflinger, com.android.phone
    /// This input is normalized in the following way: if it contains slashes,
    /// everything up to the last slash is discarded. If it contains "@",
    /// everything after the first @ is discared.
    /// E.g. /system/bin/surfaceflinger@1.0 normalizes to surfaceflinger.
    /// This transformation is also applied to the processes' command lines when
    /// matching.
    #[prost(string, repeated, tag = "2")]
    pub process_cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// For watermark based triggering or local debugging.
    #[prost(uint64, repeated, packed = "false", tag = "4")]
    pub pid: ::prost::alloc::vec::Vec<u64>,
    /// Only profile target if it was installed by one of the packages given.
    /// Special values are:
    /// * @system: installed on the system partition
    /// * @product: installed on the product partition
    /// * @null: sideloaded
    /// Supported on Android 12+.
    #[prost(string, repeated, tag = "26")]
    pub target_installed_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Which heaps to sample, e.g. "libc.malloc". If left empty, only samples
    /// "malloc".
    ///
    /// Introduced in Android 12.
    #[prost(string, repeated, tag = "20")]
    pub heaps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Which heaps not to sample, e.g. "libc.malloc". This is useful when used in
    /// combination with all_heaps;
    ///
    /// Introduced in Android 12.
    #[prost(string, repeated, tag = "27")]
    pub exclude_heaps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "23")]
    pub stream_allocations: ::core::option::Option<bool>,
    /// If given, needs to be the same length as heaps and gives the sampling
    /// interval for the respective entry in heaps.
    ///
    /// Otherwise, sampling_interval_bytes is used.
    ///
    /// It is recommended to set sampling_interval_bytes to a reasonable default
    /// value when using this, as a value of 0 for sampling_interval_bytes will
    /// crash the target process before Android 12.
    ///
    /// Introduced in Android 12.
    ///
    /// All values must be non-zero or the producer will not start.
    #[prost(uint64, repeated, packed = "false", tag = "22")]
    pub heap_sampling_intervals: ::prost::alloc::vec::Vec<u64>,
    /// Sample all heaps registered by target process. Introduced in Android 12.
    #[prost(bool, optional, tag = "21")]
    pub all_heaps: ::core::option::Option<bool>,
    /// Profile all processes eligible for profiling on the system.
    /// See
    /// <https://perfetto.dev/docs/data-sources/native-heap-profiler#heapprofd-targets>
    /// for which processes are eligible.
    ///
    /// On unmodified userdebug builds, this will lead to system crashes. Zygote
    /// will crash when trying to launch a new process as it will have an
    /// unexpected open socket to heapprofd.
    ///
    /// heapprofd will likely be overloaded by the amount of data for low
    /// sampling intervals.
    #[prost(bool, optional, tag = "5")]
    pub all: ::core::option::Option<bool>,
    /// Do not profile processes whose anon RSS + swap < given value.
    /// Introduced in Android 11.
    #[prost(uint32, optional, tag = "15")]
    pub min_anonymous_memory_kb: ::core::option::Option<u32>,
    /// Stop profile if heapprofd memory usage goes beyond the given value.
    /// Introduced in Android 11.
    #[prost(uint32, optional, tag = "16")]
    pub max_heapprofd_memory_kb: ::core::option::Option<u32>,
    /// Stop profile if heapprofd CPU time since start of this data-source
    /// goes beyond given value.
    /// Introduced in Android 11.
    #[prost(uint64, optional, tag = "17")]
    pub max_heapprofd_cpu_secs: ::core::option::Option<u64>,
    /// Do not emit function names for mappings starting with this prefix.
    /// E.g. /system to not emit symbols for any system libraries.
    #[prost(string, repeated, tag = "7")]
    pub skip_symbol_prefix: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Dump at a predefined interval.
    #[prost(message, optional, tag = "6")]
    pub continuous_dump_config: ::core::option::Option<
        heapprofd_config::ContinuousDumpConfig,
    >,
    /// Size of the shared memory buffer between the profiled processes and
    /// heapprofd. Defaults to 8 MiB. If larger than 500 MiB, truncated to 500
    /// MiB.
    ///
    /// Needs to be:
    /// * at least 8192,
    /// * a power of two,
    /// * a multiple of 4096.
    #[prost(uint64, optional, tag = "8")]
    pub shmem_size_bytes: ::core::option::Option<u64>,
    /// When the shmem buffer is full, block the client instead of ending the
    /// trace. Use with caution as this will significantly slow down the target
    /// process.
    #[prost(bool, optional, tag = "9")]
    pub block_client: ::core::option::Option<bool>,
    /// If set, stop the trace session after blocking the client for this
    /// timeout. Needs to be larger than 100 us, otherwise no retries are done.
    /// Introduced in Android 11.
    #[prost(uint32, optional, tag = "14")]
    pub block_client_timeout_us: ::core::option::Option<u32>,
    /// Do not profile processes from startup, only match already running
    /// processes.
    ///
    /// Can not be set at the same time as no_running.
    /// Introduced in Android 11.
    #[prost(bool, optional, tag = "10")]
    pub no_startup: ::core::option::Option<bool>,
    /// Do not profile running processes. Only match processes on startup.
    ///
    /// Can not be set at the same time as no_startup.
    /// Introduced in Android 11.
    #[prost(bool, optional, tag = "11")]
    pub no_running: ::core::option::Option<bool>,
    /// Cause heapprofd to emit a single dump at the end, showing the memory usage
    /// at the point in time when the sampled heap usage of the process was at its
    /// maximum. This causes ProfilePacket.HeapSample.self_max to be set, and
    /// self_allocated and self_freed to not be set.
    /// Introduced in Android 11.
    #[prost(bool, optional, tag = "13")]
    pub dump_at_max: ::core::option::Option<bool>,
    /// Escape hatch if the session is being torn down because of a forked child
    /// that shares memory space, but is not correctly identified as a vforked
    /// child.
    /// Introduced in Android 11.
    #[prost(bool, optional, tag = "18")]
    pub disable_fork_teardown: ::core::option::Option<bool>,
    /// We try to automatically detect when a target applicatation vforks but then
    /// does a memory allocation (or free). This auto-detection can be disabled
    /// with this.
    /// Introduced in Android 11.
    #[prost(bool, optional, tag = "19")]
    pub disable_vfork_detection: ::core::option::Option<bool>,
}
/// Nested message and enum types in `HeapprofdConfig`.
pub mod heapprofd_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ContinuousDumpConfig {
        /// ms to wait before first dump.
        #[prost(uint32, optional, tag = "5")]
        pub dump_phase_ms: ::core::option::Option<u32>,
        /// ms to wait between following dumps.
        #[prost(uint32, optional, tag = "6")]
        pub dump_interval_ms: ::core::option::Option<u32>,
    }
}
/// Configuration for managed app heap graph snapshots.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JavaHprofConfig {
    /// Command line allowlist, matched against the /proc/<pid>/cmdline (not the
    /// comm string). The semantics of this field were changed since its original
    /// introduction.
    ///
    /// On Android T+ (13+), this field can specify a single wildcard (*), and
    /// the profiler will attempt to match it in two possible ways:
    /// * if the pattern starts with a '/', then it is matched against the first
    ///    segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
    ///    "/bin/echo".
    /// * otherwise the pattern is matched against the part of argv0
    ///    corresponding to the binary name (this is unrelated to /proc/pid/exe).
    ///    For example "echo" would match "/bin/echo".
    ///
    /// On Android S (12) and below, both this pattern and /proc/pid/cmdline get
    /// normalized prior to an exact string comparison. Normalization is as
    /// follows: (1) trim everything beyond the first null or "@" byte; (2) if
    /// the string contains forward slashes, trim everything up to and including
    /// the last one.
    ///
    /// Implementation note: in either case, at most 511 characters of cmdline
    /// are considered.
    #[prost(string, repeated, tag = "1")]
    pub process_cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// For watermark based triggering or local debugging.
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub pid: ::prost::alloc::vec::Vec<u64>,
    /// Only profile target if it was installed by one of the packages given.
    /// Special values are:
    /// * @system: installed on the system partition
    /// * @product: installed on the product partition
    /// * @null: sideloaded
    /// Supported on Android 12+.
    #[prost(string, repeated, tag = "7")]
    pub target_installed_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Dump at a predefined interval.
    #[prost(message, optional, tag = "3")]
    pub continuous_dump_config: ::core::option::Option<
        java_hprof_config::ContinuousDumpConfig,
    >,
    /// Do not profile processes whose anon RSS + swap < given value.
    #[prost(uint32, optional, tag = "4")]
    pub min_anonymous_memory_kb: ::core::option::Option<u32>,
    /// Include the process' /proc/self/smaps.
    /// This only shows maps that:
    /// * start with /system
    /// * start with /vendor
    /// * start with /data/app
    /// * contain "extracted in memory from Y", where Y matches any of the above
    #[prost(bool, optional, tag = "5")]
    pub dump_smaps: ::core::option::Option<bool>,
    /// Exclude objects of the following types from the profile. This can be
    /// useful if lots of uninteresting objects, e.g. "sun.misc.Cleaner".
    #[prost(string, repeated, tag = "6")]
    pub ignored_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `JavaHprofConfig`.
pub mod java_hprof_config {
    /// If dump_interval_ms != 0, the following configuration is used.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ContinuousDumpConfig {
        /// ms to wait before first continuous dump.
        /// A dump is always created at the beginning of the trace.
        #[prost(uint32, optional, tag = "1")]
        pub dump_phase_ms: ::core::option::Option<u32>,
        /// ms to wait between following dumps.
        #[prost(uint32, optional, tag = "2")]
        pub dump_interval_ms: ::core::option::Option<u32>,
        /// If true, scans all the processes to find `process_cmdline` and filter by
        /// `min_anonymous_memory_kb` only at data source start. Default on Android
        /// S-.
        ///
        /// If false, rescans all the processes to find on every dump. Default on
        /// Android T+.
        #[prost(bool, optional, tag = "3")]
        pub scan_pids_only_on_start: ::core::option::Option<bool>,
    }
}
/// Next id: 12
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerfEvents {}
/// Nested message and enum types in `PerfEvents`.
pub mod perf_events {
    /// What event to sample on, and how often. Commented from the perspective of
    /// its use in |PerfEventConfig|.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Timebase {
        /// If set, samples will be timestamped with the given clock.
        /// If unset, the clock is chosen by the implementation.
        /// For software events, prefer PERF_CLOCK_BOOTTIME. However it cannot be
        /// used for hardware events (due to interrupt safety), for which the
        /// recommendation is to use one of the monotonic clocks.
        #[prost(enumeration = "PerfClock", optional, tag = "11")]
        pub timestamp_clock: ::core::option::Option<i32>,
        /// Optional arbitrary name for the event, to identify it in the parsed
        /// trace. Does *not* affect the profiling itself. If unset, the trace
        /// parser will choose a suitable name.
        #[prost(string, optional, tag = "10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// How often the per-cpu sampling will occur. Not guaranteed to be honored
        /// as the kernel can throttle the sampling rate if it's too high.
        /// If unset, an implementation-defined default is used.
        #[prost(oneof = "timebase::Interval", tags = "2, 1")]
        pub interval: ::core::option::Option<timebase::Interval>,
        /// Counting event to use as a timebase for the sampling.
        /// If unset, implies the CPU timer (SW_CPU_CLOCK) as the event,
        /// which is what you usually want.
        /// See common/perf_events.proto for the definitions.
        #[prost(oneof = "timebase::Event", tags = "4, 3, 5")]
        pub event: ::core::option::Option<timebase::Event>,
    }
    /// Nested message and enum types in `Timebase`.
    pub mod timebase {
        /// How often the per-cpu sampling will occur. Not guaranteed to be honored
        /// as the kernel can throttle the sampling rate if it's too high.
        /// If unset, an implementation-defined default is used.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Interval {
            /// Per-cpu sampling frequency in Hz, as requested from the kernel. Not the
            /// same as 1/period.
            /// Details: the actual sampling will still be based on a period, but the
            /// kernel will dynamically adjust it based on the observed event rate, to
            /// approximate this frequency. Works best with steady-rate events like
            /// timers.
            #[prost(uint64, tag = "2")]
            Frequency(u64),
            /// Per-cpu sampling will occur every |period| counts of |event|.
            /// Prefer |frequency| by default, as it's easier to oversample with a
            /// fixed period.
            #[prost(uint64, tag = "1")]
            Period(u64),
        }
        /// Counting event to use as a timebase for the sampling.
        /// If unset, implies the CPU timer (SW_CPU_CLOCK) as the event,
        /// which is what you usually want.
        /// See common/perf_events.proto for the definitions.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(enumeration = "super::Counter", tag = "4")]
            Counter(i32),
            #[prost(message, tag = "3")]
            Tracepoint(super::Tracepoint),
            #[prost(message, tag = "5")]
            RawEvent(super::RawEvent),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tracepoint {
        /// Group and name for the tracepoint, acceptable forms:
        /// * "sched/sched_switch"
        /// * "sched:sched_switch"
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional field-level filter for the tracepoint. Only events matching this
        /// filter will be counted (and therefore contribute to the sampling period).
        /// Example: "prev_pid >= 42 && next_pid == 0".
        /// For full syntax, see kernel documentation on "Event filtering":
        /// <https://www.kernel.org/doc/Documentation/trace/events.txt>
        #[prost(string, optional, tag = "2")]
        pub filter: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Syscall-level description of the event, propagated to the perf_event_attr
    /// struct. Primarily for local use-cases, since the event availability and
    /// encoding is hardware-specific.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RawEvent {
        #[prost(uint32, optional, tag = "1")]
        pub r#type: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "2")]
        pub config: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "3")]
        pub config1: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "4")]
        pub config2: ::core::option::Option<u64>,
    }
    /// Builtin counter names from the uapi header. Commented with their perf tool
    /// aliases.
    /// TODO(rsavitski): consider generating enums for cache events (should be
    /// finite), and generally make this list as extensive as possible. Excluding
    /// things like dynamic PMUs since those don't fit into a static enum.
    /// Next id: 21
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Counter {
        UnknownCounter = 0,
        /// cpu-clock
        SwCpuClock = 1,
        /// page-faults, faults
        SwPageFaults = 2,
        /// task-clock
        SwTaskClock = 3,
        /// context-switches, cs
        SwContextSwitches = 4,
        /// cpu-migrations, migrations
        SwCpuMigrations = 5,
        /// minor-faults
        SwPageFaultsMin = 6,
        /// major-faults
        SwPageFaultsMaj = 7,
        /// alignment-faults
        SwAlignmentFaults = 8,
        /// emulation-faults
        SwEmulationFaults = 9,
        /// dummy
        SwDummy = 20,
        /// cpu-cycles, cycles
        HwCpuCycles = 10,
        /// instructions
        HwInstructions = 11,
        /// cache-references
        HwCacheReferences = 12,
        /// cache-misses
        HwCacheMisses = 13,
        /// branch-instructions, branches
        HwBranchInstructions = 14,
        /// branch-misses
        HwBranchMisses = 15,
        /// bus-cycles
        HwBusCycles = 16,
        /// stalled-cycles-frontend, idle-cycles-frontend
        HwStalledCyclesFrontend = 17,
        /// stalled-cycles-backend, idle-cycles-backend
        HwStalledCyclesBackend = 18,
        /// ref-cycles
        HwRefCpuCycles = 19,
    }
    impl Counter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownCounter => "UNKNOWN_COUNTER",
                Self::SwCpuClock => "SW_CPU_CLOCK",
                Self::SwPageFaults => "SW_PAGE_FAULTS",
                Self::SwTaskClock => "SW_TASK_CLOCK",
                Self::SwContextSwitches => "SW_CONTEXT_SWITCHES",
                Self::SwCpuMigrations => "SW_CPU_MIGRATIONS",
                Self::SwPageFaultsMin => "SW_PAGE_FAULTS_MIN",
                Self::SwPageFaultsMaj => "SW_PAGE_FAULTS_MAJ",
                Self::SwAlignmentFaults => "SW_ALIGNMENT_FAULTS",
                Self::SwEmulationFaults => "SW_EMULATION_FAULTS",
                Self::SwDummy => "SW_DUMMY",
                Self::HwCpuCycles => "HW_CPU_CYCLES",
                Self::HwInstructions => "HW_INSTRUCTIONS",
                Self::HwCacheReferences => "HW_CACHE_REFERENCES",
                Self::HwCacheMisses => "HW_CACHE_MISSES",
                Self::HwBranchInstructions => "HW_BRANCH_INSTRUCTIONS",
                Self::HwBranchMisses => "HW_BRANCH_MISSES",
                Self::HwBusCycles => "HW_BUS_CYCLES",
                Self::HwStalledCyclesFrontend => "HW_STALLED_CYCLES_FRONTEND",
                Self::HwStalledCyclesBackend => "HW_STALLED_CYCLES_BACKEND",
                Self::HwRefCpuCycles => "HW_REF_CPU_CYCLES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_COUNTER" => Some(Self::UnknownCounter),
                "SW_CPU_CLOCK" => Some(Self::SwCpuClock),
                "SW_PAGE_FAULTS" => Some(Self::SwPageFaults),
                "SW_TASK_CLOCK" => Some(Self::SwTaskClock),
                "SW_CONTEXT_SWITCHES" => Some(Self::SwContextSwitches),
                "SW_CPU_MIGRATIONS" => Some(Self::SwCpuMigrations),
                "SW_PAGE_FAULTS_MIN" => Some(Self::SwPageFaultsMin),
                "SW_PAGE_FAULTS_MAJ" => Some(Self::SwPageFaultsMaj),
                "SW_ALIGNMENT_FAULTS" => Some(Self::SwAlignmentFaults),
                "SW_EMULATION_FAULTS" => Some(Self::SwEmulationFaults),
                "SW_DUMMY" => Some(Self::SwDummy),
                "HW_CPU_CYCLES" => Some(Self::HwCpuCycles),
                "HW_INSTRUCTIONS" => Some(Self::HwInstructions),
                "HW_CACHE_REFERENCES" => Some(Self::HwCacheReferences),
                "HW_CACHE_MISSES" => Some(Self::HwCacheMisses),
                "HW_BRANCH_INSTRUCTIONS" => Some(Self::HwBranchInstructions),
                "HW_BRANCH_MISSES" => Some(Self::HwBranchMisses),
                "HW_BUS_CYCLES" => Some(Self::HwBusCycles),
                "HW_STALLED_CYCLES_FRONTEND" => Some(Self::HwStalledCyclesFrontend),
                "HW_STALLED_CYCLES_BACKEND" => Some(Self::HwStalledCyclesBackend),
                "HW_REF_CPU_CYCLES" => Some(Self::HwRefCpuCycles),
                _ => None,
            }
        }
    }
    /// Subset of clocks that is supported by perf timestamping.
    /// CLOCK_TAI is excluded since it's not expected to be used in practice, but
    /// would require additions to the trace clock synchronisation logic.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PerfClock {
        UnknownPerfClock = 0,
        Realtime = 1,
        Monotonic = 2,
        MonotonicRaw = 3,
        Boottime = 4,
    }
    impl PerfClock {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownPerfClock => "UNKNOWN_PERF_CLOCK",
                Self::Realtime => "PERF_CLOCK_REALTIME",
                Self::Monotonic => "PERF_CLOCK_MONOTONIC",
                Self::MonotonicRaw => "PERF_CLOCK_MONOTONIC_RAW",
                Self::Boottime => "PERF_CLOCK_BOOTTIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_PERF_CLOCK" => Some(Self::UnknownPerfClock),
                "PERF_CLOCK_REALTIME" => Some(Self::Realtime),
                "PERF_CLOCK_MONOTONIC" => Some(Self::Monotonic),
                "PERF_CLOCK_MONOTONIC_RAW" => Some(Self::MonotonicRaw),
                "PERF_CLOCK_BOOTTIME" => Some(Self::Boottime),
                _ => None,
            }
        }
    }
}
/// Configuration for the traced_perf profiler.
///
/// Example config for basic cpu profiling:
///    perf_event_config {
///      timebase {
///        frequency: 80
///      }
///      callstack_sampling {
///        scope {
///          target_cmdline: "surfaceflinger"
///          target_cmdline: "system_server"
///        }
///        kernel_frames: true
///      }
///    }
///
/// Next id: 19
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerfEventConfig {
    /// What event to sample on, and how often.
    /// Defined in common/perf_events.proto.
    #[prost(message, optional, tag = "15")]
    pub timebase: ::core::option::Option<perf_events::Timebase>,
    /// If set, the profiler will sample userspace processes' callstacks at the
    /// interval specified by the |timebase|.
    /// If unset, the profiler will record only the event counts.
    #[prost(message, optional, tag = "16")]
    pub callstack_sampling: ::core::option::Option<perf_event_config::CallstackSampling>,
    /// How often the per-cpu ring buffers are read by the producer.
    /// If unset, an implementation-defined default is used.
    #[prost(uint32, optional, tag = "8")]
    pub ring_buffer_read_period_ms: ::core::option::Option<u32>,
    /// Size (in 4k pages) of each per-cpu ring buffer that is filled by the
    /// kernel. If set, must be a power of two.
    /// If unset, an implementation-defined default is used.
    #[prost(uint32, optional, tag = "3")]
    pub ring_buffer_pages: ::core::option::Option<u32>,
    /// Drop samples if the heap memory held by the samples in the unwinder queue
    /// is above the given limit. This counts the memory across all concurrent data
    /// sources (not just this one's), and there is no fairness guarantee - the
    /// whole quota might be used up by a concurrent source.
    #[prost(uint64, optional, tag = "17")]
    pub max_enqueued_footprint_kb: ::core::option::Option<u64>,
    /// Stop the data source if traced_perf's combined {RssAnon + Swap} memory
    /// footprint exceeds this value.
    #[prost(uint32, optional, tag = "13")]
    pub max_daemon_memory_kb: ::core::option::Option<u32>,
    /// Timeout for the remote /proc/<pid>/{maps,mem} file descriptors for a
    /// sampled process. This is primarily for Android, where this lookup is
    /// asynchronous. As long as the producer is waiting, the associated samples
    /// will be kept enqueued (putting pressure on the capacity of the shared
    /// unwinding queue). Once a lookup for a process expires, all associated
    /// samples are discarded. However, if the lookup still succeeds after the
    /// timeout, future samples will be handled normally.
    /// If unset, an implementation-defined default is used.
    #[prost(uint32, optional, tag = "9")]
    pub remote_descriptor_timeout_ms: ::core::option::Option<u32>,
    /// Optional period for clearing state cached by the unwinder. This is a heavy
    /// operation that is only necessary for traces that target a wide set of
    /// processes, and require the memory footprint to be reset periodically.
    /// If unset, the cached state will not be cleared.
    #[prost(uint32, optional, tag = "10")]
    pub unwind_state_clear_period_ms: ::core::option::Option<u32>,
    /// If set, only profile target if it was installed by a package with one of
    /// these names. Special values:
    /// * "@system": installed on the system partition
    /// * "@product": installed on the product partition
    /// * "@null": sideloaded
    /// Supported on Android 12+.
    #[prost(string, repeated, tag = "18")]
    pub target_installed_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Note: legacy configs had to set |all_cpus| to true to pass parsing.
    /// We rely on this to detect such configs.
    #[prost(bool, optional, tag = "1")]
    pub all_cpus: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "2")]
    pub sampling_frequency: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "12")]
    pub kernel_frames: ::core::option::Option<bool>,
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub target_pid: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "5")]
    pub target_cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub exclude_pid: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "7")]
    pub exclude_cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "11")]
    pub additional_cmdline_count: ::core::option::Option<u32>,
}
/// Nested message and enum types in `PerfEventConfig`.
pub mod perf_event_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallstackSampling {
        /// Defines a set of processes for which samples are retained/skipped. If
        /// unset, all samples are kept, but beware that it will be very heavy on the
        /// stack unwinder, which might start dropping samples due to overload.
        #[prost(message, optional, tag = "1")]
        pub scope: ::core::option::Option<Scope>,
        /// If true, callstacks will include the kernel-space frames. Such frames can
        /// be identified by a magical "kernel" string as their mapping name.
        /// Requires traced_perf to be running as root, or kptr_restrict to have been
        /// manually unrestricted. On Android, the platform should do the right thing
        /// on debug builds.
        /// This does *not* disclose KASLR, as only the function names are emitted.
        #[prost(bool, optional, tag = "2")]
        pub kernel_frames: ::core::option::Option<bool>,
        /// Whether to record and unwind userspace callstacks. If unset, defaults to
        /// including userspace (UNWIND_DWARF) both for backwards compatibility and
        /// as the most common default (this defaulting is only applicable if the
        /// outer CallstackSampling message is explicitly set).
        #[prost(enumeration = "UnwindMode", optional, tag = "3")]
        pub user_frames: ::core::option::Option<i32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Scope {
        /// Process ID (TGID) allowlist. If this list is not empty, only matching
        /// samples will be retained. If multiple allow/deny-lists are
        /// specified by the config, then all of them are evaluated for each sampled
        /// process.
        #[prost(int32, repeated, packed = "false", tag = "1")]
        pub target_pid: ::prost::alloc::vec::Vec<i32>,
        /// Command line allowlist, matched against the /proc/<pid>/cmdline (not the
        /// comm string). The semantics of this field were changed since its original
        /// introduction.
        ///
        /// On Android T+ (13+), this field can specify a single wildcard (*), and
        /// the profiler will attempt to match it in two possible ways:
        /// * if the pattern starts with a '/', then it is matched against the first
        ///    segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
        ///    "/bin/echo".
        /// * otherwise the pattern is matched against the part of argv0
        ///    corresponding to the binary name (this is unrelated to /proc/pid/exe).
        ///    For example "echo" would match "/bin/echo".
        ///
        /// On Android S (12) and below, both this pattern and /proc/pid/cmdline get
        /// normalized prior to an exact string comparison. Normalization is as
        /// follows: (1) trim everything beyond the first null or "@" byte; (2) if
        /// the string contains forward slashes, trim everything up to and including
        /// the last one.
        ///
        /// Implementation note: in either case, at most 511 characters of cmdline
        /// are considered.
        #[prost(string, repeated, tag = "2")]
        pub target_cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// List of excluded pids.
        #[prost(int32, repeated, packed = "false", tag = "3")]
        pub exclude_pid: ::prost::alloc::vec::Vec<i32>,
        /// List of excluded cmdlines. See description of |target_cmdline| for how
        /// this is handled.
        #[prost(string, repeated, tag = "4")]
        pub exclude_cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Number of additional command lines to sample. Only those which are
        /// neither explicitly included nor excluded will be considered. Processes
        /// are accepted on a first come, first served basis.
        #[prost(uint32, optional, tag = "5")]
        pub additional_cmdline_count: ::core::option::Option<u32>,
        /// If set to N, all encountered processes will be put into one of the N
        /// possible bins, and only one randomly-chosen bin will be selected for
        /// unwinding. The binning is simply "pid % N", under the assumption that
        /// low-order bits of pids are roughly uniformly distributed. Other explicit
        /// inclusions/exclusions in this |Scope| message are still respected.
        ///
        /// The profiler will report the chosen shard in PerfSampleDefaults, and the
        /// values will be queryable in trace processor under the "stats" table as
        /// "perf_process_shard_count" and "perf_chosen_process_shard".
        ///
        /// NB: all data sources in a config that set |process_shard_count| must set
        /// it to the same value. The profiler will choose one bin for all those data
        /// sources.
        #[prost(uint32, optional, tag = "6")]
        pub process_shard_count: ::core::option::Option<u32>,
    }
    /// Userspace unwinding mode. A possible future addition is kernel-unwound
    /// callchains for frame pointer based systems.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnwindMode {
        UnwindUnknown = 0,
        /// Do not unwind userspace:
        UnwindSkip = 1,
        /// Use libunwindstack (default):
        UnwindDwarf = 2,
    }
    impl UnwindMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnwindUnknown => "UNWIND_UNKNOWN",
                Self::UnwindSkip => "UNWIND_SKIP",
                Self::UnwindDwarf => "UNWIND_DWARF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNWIND_UNKNOWN" => Some(Self::UnwindUnknown),
                "UNWIND_SKIP" => Some(Self::UnwindSkip),
                "UNWIND_DWARF" => Some(Self::UnwindDwarf),
                _ => None,
            }
        }
    }
}
/// Counter definitions for Linux's /proc/meminfo.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MeminfoCounters {
    MeminfoUnspecified = 0,
    MeminfoMemTotal = 1,
    MeminfoMemFree = 2,
    MeminfoMemAvailable = 3,
    MeminfoBuffers = 4,
    MeminfoCached = 5,
    MeminfoSwapCached = 6,
    MeminfoActive = 7,
    MeminfoInactive = 8,
    MeminfoActiveAnon = 9,
    MeminfoInactiveAnon = 10,
    MeminfoActiveFile = 11,
    MeminfoInactiveFile = 12,
    MeminfoUnevictable = 13,
    MeminfoMlocked = 14,
    MeminfoSwapTotal = 15,
    MeminfoSwapFree = 16,
    MeminfoDirty = 17,
    MeminfoWriteback = 18,
    MeminfoAnonPages = 19,
    MeminfoMapped = 20,
    MeminfoShmem = 21,
    MeminfoSlab = 22,
    MeminfoSlabReclaimable = 23,
    MeminfoSlabUnreclaimable = 24,
    MeminfoKernelStack = 25,
    MeminfoPageTables = 26,
    MeminfoCommitLimit = 27,
    MeminfoCommitedAs = 28,
    MeminfoVmallocTotal = 29,
    MeminfoVmallocUsed = 30,
    MeminfoVmallocChunk = 31,
    MeminfoCmaTotal = 32,
    MeminfoCmaFree = 33,
}
impl MeminfoCounters {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MeminfoUnspecified => "MEMINFO_UNSPECIFIED",
            Self::MeminfoMemTotal => "MEMINFO_MEM_TOTAL",
            Self::MeminfoMemFree => "MEMINFO_MEM_FREE",
            Self::MeminfoMemAvailable => "MEMINFO_MEM_AVAILABLE",
            Self::MeminfoBuffers => "MEMINFO_BUFFERS",
            Self::MeminfoCached => "MEMINFO_CACHED",
            Self::MeminfoSwapCached => "MEMINFO_SWAP_CACHED",
            Self::MeminfoActive => "MEMINFO_ACTIVE",
            Self::MeminfoInactive => "MEMINFO_INACTIVE",
            Self::MeminfoActiveAnon => "MEMINFO_ACTIVE_ANON",
            Self::MeminfoInactiveAnon => "MEMINFO_INACTIVE_ANON",
            Self::MeminfoActiveFile => "MEMINFO_ACTIVE_FILE",
            Self::MeminfoInactiveFile => "MEMINFO_INACTIVE_FILE",
            Self::MeminfoUnevictable => "MEMINFO_UNEVICTABLE",
            Self::MeminfoMlocked => "MEMINFO_MLOCKED",
            Self::MeminfoSwapTotal => "MEMINFO_SWAP_TOTAL",
            Self::MeminfoSwapFree => "MEMINFO_SWAP_FREE",
            Self::MeminfoDirty => "MEMINFO_DIRTY",
            Self::MeminfoWriteback => "MEMINFO_WRITEBACK",
            Self::MeminfoAnonPages => "MEMINFO_ANON_PAGES",
            Self::MeminfoMapped => "MEMINFO_MAPPED",
            Self::MeminfoShmem => "MEMINFO_SHMEM",
            Self::MeminfoSlab => "MEMINFO_SLAB",
            Self::MeminfoSlabReclaimable => "MEMINFO_SLAB_RECLAIMABLE",
            Self::MeminfoSlabUnreclaimable => "MEMINFO_SLAB_UNRECLAIMABLE",
            Self::MeminfoKernelStack => "MEMINFO_KERNEL_STACK",
            Self::MeminfoPageTables => "MEMINFO_PAGE_TABLES",
            Self::MeminfoCommitLimit => "MEMINFO_COMMIT_LIMIT",
            Self::MeminfoCommitedAs => "MEMINFO_COMMITED_AS",
            Self::MeminfoVmallocTotal => "MEMINFO_VMALLOC_TOTAL",
            Self::MeminfoVmallocUsed => "MEMINFO_VMALLOC_USED",
            Self::MeminfoVmallocChunk => "MEMINFO_VMALLOC_CHUNK",
            Self::MeminfoCmaTotal => "MEMINFO_CMA_TOTAL",
            Self::MeminfoCmaFree => "MEMINFO_CMA_FREE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MEMINFO_UNSPECIFIED" => Some(Self::MeminfoUnspecified),
            "MEMINFO_MEM_TOTAL" => Some(Self::MeminfoMemTotal),
            "MEMINFO_MEM_FREE" => Some(Self::MeminfoMemFree),
            "MEMINFO_MEM_AVAILABLE" => Some(Self::MeminfoMemAvailable),
            "MEMINFO_BUFFERS" => Some(Self::MeminfoBuffers),
            "MEMINFO_CACHED" => Some(Self::MeminfoCached),
            "MEMINFO_SWAP_CACHED" => Some(Self::MeminfoSwapCached),
            "MEMINFO_ACTIVE" => Some(Self::MeminfoActive),
            "MEMINFO_INACTIVE" => Some(Self::MeminfoInactive),
            "MEMINFO_ACTIVE_ANON" => Some(Self::MeminfoActiveAnon),
            "MEMINFO_INACTIVE_ANON" => Some(Self::MeminfoInactiveAnon),
            "MEMINFO_ACTIVE_FILE" => Some(Self::MeminfoActiveFile),
            "MEMINFO_INACTIVE_FILE" => Some(Self::MeminfoInactiveFile),
            "MEMINFO_UNEVICTABLE" => Some(Self::MeminfoUnevictable),
            "MEMINFO_MLOCKED" => Some(Self::MeminfoMlocked),
            "MEMINFO_SWAP_TOTAL" => Some(Self::MeminfoSwapTotal),
            "MEMINFO_SWAP_FREE" => Some(Self::MeminfoSwapFree),
            "MEMINFO_DIRTY" => Some(Self::MeminfoDirty),
            "MEMINFO_WRITEBACK" => Some(Self::MeminfoWriteback),
            "MEMINFO_ANON_PAGES" => Some(Self::MeminfoAnonPages),
            "MEMINFO_MAPPED" => Some(Self::MeminfoMapped),
            "MEMINFO_SHMEM" => Some(Self::MeminfoShmem),
            "MEMINFO_SLAB" => Some(Self::MeminfoSlab),
            "MEMINFO_SLAB_RECLAIMABLE" => Some(Self::MeminfoSlabReclaimable),
            "MEMINFO_SLAB_UNRECLAIMABLE" => Some(Self::MeminfoSlabUnreclaimable),
            "MEMINFO_KERNEL_STACK" => Some(Self::MeminfoKernelStack),
            "MEMINFO_PAGE_TABLES" => Some(Self::MeminfoPageTables),
            "MEMINFO_COMMIT_LIMIT" => Some(Self::MeminfoCommitLimit),
            "MEMINFO_COMMITED_AS" => Some(Self::MeminfoCommitedAs),
            "MEMINFO_VMALLOC_TOTAL" => Some(Self::MeminfoVmallocTotal),
            "MEMINFO_VMALLOC_USED" => Some(Self::MeminfoVmallocUsed),
            "MEMINFO_VMALLOC_CHUNK" => Some(Self::MeminfoVmallocChunk),
            "MEMINFO_CMA_TOTAL" => Some(Self::MeminfoCmaTotal),
            "MEMINFO_CMA_FREE" => Some(Self::MeminfoCmaFree),
            _ => None,
        }
    }
}
/// Counter definitions for Linux's /proc/vmstat.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VmstatCounters {
    VmstatUnspecified = 0,
    VmstatNrFreePages = 1,
    VmstatNrAllocBatch = 2,
    VmstatNrInactiveAnon = 3,
    VmstatNrActiveAnon = 4,
    VmstatNrInactiveFile = 5,
    VmstatNrActiveFile = 6,
    VmstatNrUnevictable = 7,
    VmstatNrMlock = 8,
    VmstatNrAnonPages = 9,
    VmstatNrMapped = 10,
    VmstatNrFilePages = 11,
    VmstatNrDirty = 12,
    VmstatNrWriteback = 13,
    VmstatNrSlabReclaimable = 14,
    VmstatNrSlabUnreclaimable = 15,
    VmstatNrPageTablePages = 16,
    VmstatNrKernelStack = 17,
    VmstatNrOverhead = 18,
    VmstatNrUnstable = 19,
    VmstatNrBounce = 20,
    VmstatNrVmscanWrite = 21,
    VmstatNrVmscanImmediateReclaim = 22,
    VmstatNrWritebackTemp = 23,
    VmstatNrIsolatedAnon = 24,
    VmstatNrIsolatedFile = 25,
    VmstatNrShmem = 26,
    VmstatNrDirtied = 27,
    VmstatNrWritten = 28,
    VmstatNrPagesScanned = 29,
    VmstatWorkingsetRefault = 30,
    VmstatWorkingsetActivate = 31,
    VmstatWorkingsetNodereclaim = 32,
    VmstatNrAnonTransparentHugepages = 33,
    VmstatNrFreeCma = 34,
    VmstatNrSwapcache = 35,
    VmstatNrDirtyThreshold = 36,
    VmstatNrDirtyBackgroundThreshold = 37,
    VmstatPgpgin = 38,
    VmstatPgpgout = 39,
    VmstatPgpgoutclean = 40,
    VmstatPswpin = 41,
    VmstatPswpout = 42,
    VmstatPgallocDma = 43,
    VmstatPgallocNormal = 44,
    VmstatPgallocMovable = 45,
    VmstatPgfree = 46,
    VmstatPgactivate = 47,
    VmstatPgdeactivate = 48,
    VmstatPgfault = 49,
    VmstatPgmajfault = 50,
    VmstatPgrefillDma = 51,
    VmstatPgrefillNormal = 52,
    VmstatPgrefillMovable = 53,
    VmstatPgstealKswapdDma = 54,
    VmstatPgstealKswapdNormal = 55,
    VmstatPgstealKswapdMovable = 56,
    VmstatPgstealDirectDma = 57,
    VmstatPgstealDirectNormal = 58,
    VmstatPgstealDirectMovable = 59,
    VmstatPgscanKswapdDma = 60,
    VmstatPgscanKswapdNormal = 61,
    VmstatPgscanKswapdMovable = 62,
    VmstatPgscanDirectDma = 63,
    VmstatPgscanDirectNormal = 64,
    VmstatPgscanDirectMovable = 65,
    VmstatPgscanDirectThrottle = 66,
    VmstatPginodesteal = 67,
    VmstatSlabsScanned = 68,
    VmstatKswapdInodesteal = 69,
    VmstatKswapdLowWmarkHitQuickly = 70,
    VmstatKswapdHighWmarkHitQuickly = 71,
    VmstatPageoutrun = 72,
    VmstatAllocstall = 73,
    VmstatPgrotated = 74,
    VmstatDropPagecache = 75,
    VmstatDropSlab = 76,
    VmstatPgmigrateSuccess = 77,
    VmstatPgmigrateFail = 78,
    VmstatCompactMigrateScanned = 79,
    VmstatCompactFreeScanned = 80,
    VmstatCompactIsolated = 81,
    VmstatCompactStall = 82,
    VmstatCompactFail = 83,
    VmstatCompactSuccess = 84,
    VmstatCompactDaemonWake = 85,
    VmstatUnevictablePgsCulled = 86,
    VmstatUnevictablePgsScanned = 87,
    VmstatUnevictablePgsRescued = 88,
    VmstatUnevictablePgsMlocked = 89,
    VmstatUnevictablePgsMunlocked = 90,
    VmstatUnevictablePgsCleared = 91,
    VmstatUnevictablePgsStranded = 92,
    VmstatNrZspages = 93,
    VmstatNrIonHeap = 94,
    VmstatNrGpuHeap = 95,
    VmstatAllocstallDma = 96,
    VmstatAllocstallMovable = 97,
    VmstatAllocstallNormal = 98,
    VmstatCompactDaemonFreeScanned = 99,
    VmstatCompactDaemonMigrateScanned = 100,
    VmstatNrFastrpc = 101,
    VmstatNrIndirectlyReclaimable = 102,
    VmstatNrIonHeapPool = 103,
    VmstatNrKernelMiscReclaimable = 104,
    VmstatNrShadowCallStackBytes = 105,
    VmstatNrShmemHugepages = 106,
    VmstatNrShmemPmdmapped = 107,
    VmstatNrUnreclaimablePages = 108,
    VmstatNrZoneActiveAnon = 109,
    VmstatNrZoneActiveFile = 110,
    VmstatNrZoneInactiveAnon = 111,
    VmstatNrZoneInactiveFile = 112,
    VmstatNrZoneUnevictable = 113,
    VmstatNrZoneWritePending = 114,
    VmstatOomKill = 115,
    VmstatPglazyfree = 116,
    VmstatPglazyfreed = 117,
    VmstatPgrefill = 118,
    VmstatPgscanDirect = 119,
    VmstatPgscanKswapd = 120,
    VmstatPgskipDma = 121,
    VmstatPgskipMovable = 122,
    VmstatPgskipNormal = 123,
    VmstatPgstealDirect = 124,
    VmstatPgstealKswapd = 125,
    VmstatSwapRa = 126,
    VmstatSwapRaHit = 127,
    VmstatWorkingsetRestore = 128,
    VmstatAllocstallDevice = 129,
    VmstatAllocstallDma32 = 130,
    VmstatBalloonDeflate = 131,
    VmstatBalloonInflate = 132,
    VmstatBalloonMigrate = 133,
    VmstatCmaAllocFail = 134,
    VmstatCmaAllocSuccess = 135,
    VmstatNrFileHugepages = 136,
    VmstatNrFilePmdmapped = 137,
    VmstatNrFollPinAcquired = 138,
    VmstatNrFollPinReleased = 139,
    VmstatNrSecPageTablePages = 140,
    VmstatNrShadowCallStack = 141,
    VmstatNrSwapcached = 142,
    VmstatNrThrottledWritten = 143,
    VmstatPgallocDevice = 144,
    VmstatPgallocDma32 = 145,
    VmstatPgdemoteDirect = 146,
    VmstatPgdemoteKswapd = 147,
    VmstatPgreuse = 148,
    VmstatPgscanAnon = 149,
    VmstatPgscanFile = 150,
    VmstatPgskipDevice = 151,
    VmstatPgskipDma32 = 152,
    VmstatPgstealAnon = 153,
    VmstatPgstealFile = 154,
    VmstatThpCollapseAlloc = 155,
    VmstatThpCollapseAllocFailed = 156,
    VmstatThpDeferredSplitPage = 157,
    VmstatThpFaultAlloc = 158,
    VmstatThpFaultFallback = 159,
    VmstatThpFaultFallbackCharge = 160,
    VmstatThpFileAlloc = 161,
    VmstatThpFileFallback = 162,
    VmstatThpFileFallbackCharge = 163,
    VmstatThpFileMapped = 164,
    VmstatThpMigrationFail = 165,
    VmstatThpMigrationSplit = 166,
    VmstatThpMigrationSuccess = 167,
    VmstatThpScanExceedNonePte = 168,
    VmstatThpScanExceedSharePte = 169,
    VmstatThpScanExceedSwapPte = 170,
    VmstatThpSplitPage = 171,
    VmstatThpSplitPageFailed = 172,
    VmstatThpSplitPmd = 173,
    VmstatThpSwpout = 174,
    VmstatThpSwpoutFallback = 175,
    VmstatThpZeroPageAlloc = 176,
    VmstatThpZeroPageAllocFailed = 177,
    VmstatVmaLockAbort = 178,
    VmstatVmaLockMiss = 179,
    VmstatVmaLockRetry = 180,
    VmstatVmaLockSuccess = 181,
    VmstatWorkingsetActivateAnon = 182,
    VmstatWorkingsetActivateFile = 183,
    VmstatWorkingsetNodes = 184,
    VmstatWorkingsetRefaultAnon = 185,
    VmstatWorkingsetRefaultFile = 186,
    VmstatWorkingsetRestoreAnon = 187,
    VmstatWorkingsetRestoreFile = 188,
}
impl VmstatCounters {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VmstatUnspecified => "VMSTAT_UNSPECIFIED",
            Self::VmstatNrFreePages => "VMSTAT_NR_FREE_PAGES",
            Self::VmstatNrAllocBatch => "VMSTAT_NR_ALLOC_BATCH",
            Self::VmstatNrInactiveAnon => "VMSTAT_NR_INACTIVE_ANON",
            Self::VmstatNrActiveAnon => "VMSTAT_NR_ACTIVE_ANON",
            Self::VmstatNrInactiveFile => "VMSTAT_NR_INACTIVE_FILE",
            Self::VmstatNrActiveFile => "VMSTAT_NR_ACTIVE_FILE",
            Self::VmstatNrUnevictable => "VMSTAT_NR_UNEVICTABLE",
            Self::VmstatNrMlock => "VMSTAT_NR_MLOCK",
            Self::VmstatNrAnonPages => "VMSTAT_NR_ANON_PAGES",
            Self::VmstatNrMapped => "VMSTAT_NR_MAPPED",
            Self::VmstatNrFilePages => "VMSTAT_NR_FILE_PAGES",
            Self::VmstatNrDirty => "VMSTAT_NR_DIRTY",
            Self::VmstatNrWriteback => "VMSTAT_NR_WRITEBACK",
            Self::VmstatNrSlabReclaimable => "VMSTAT_NR_SLAB_RECLAIMABLE",
            Self::VmstatNrSlabUnreclaimable => "VMSTAT_NR_SLAB_UNRECLAIMABLE",
            Self::VmstatNrPageTablePages => "VMSTAT_NR_PAGE_TABLE_PAGES",
            Self::VmstatNrKernelStack => "VMSTAT_NR_KERNEL_STACK",
            Self::VmstatNrOverhead => "VMSTAT_NR_OVERHEAD",
            Self::VmstatNrUnstable => "VMSTAT_NR_UNSTABLE",
            Self::VmstatNrBounce => "VMSTAT_NR_BOUNCE",
            Self::VmstatNrVmscanWrite => "VMSTAT_NR_VMSCAN_WRITE",
            Self::VmstatNrVmscanImmediateReclaim => "VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM",
            Self::VmstatNrWritebackTemp => "VMSTAT_NR_WRITEBACK_TEMP",
            Self::VmstatNrIsolatedAnon => "VMSTAT_NR_ISOLATED_ANON",
            Self::VmstatNrIsolatedFile => "VMSTAT_NR_ISOLATED_FILE",
            Self::VmstatNrShmem => "VMSTAT_NR_SHMEM",
            Self::VmstatNrDirtied => "VMSTAT_NR_DIRTIED",
            Self::VmstatNrWritten => "VMSTAT_NR_WRITTEN",
            Self::VmstatNrPagesScanned => "VMSTAT_NR_PAGES_SCANNED",
            Self::VmstatWorkingsetRefault => "VMSTAT_WORKINGSET_REFAULT",
            Self::VmstatWorkingsetActivate => "VMSTAT_WORKINGSET_ACTIVATE",
            Self::VmstatWorkingsetNodereclaim => "VMSTAT_WORKINGSET_NODERECLAIM",
            Self::VmstatNrAnonTransparentHugepages => {
                "VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES"
            }
            Self::VmstatNrFreeCma => "VMSTAT_NR_FREE_CMA",
            Self::VmstatNrSwapcache => "VMSTAT_NR_SWAPCACHE",
            Self::VmstatNrDirtyThreshold => "VMSTAT_NR_DIRTY_THRESHOLD",
            Self::VmstatNrDirtyBackgroundThreshold => {
                "VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD"
            }
            Self::VmstatPgpgin => "VMSTAT_PGPGIN",
            Self::VmstatPgpgout => "VMSTAT_PGPGOUT",
            Self::VmstatPgpgoutclean => "VMSTAT_PGPGOUTCLEAN",
            Self::VmstatPswpin => "VMSTAT_PSWPIN",
            Self::VmstatPswpout => "VMSTAT_PSWPOUT",
            Self::VmstatPgallocDma => "VMSTAT_PGALLOC_DMA",
            Self::VmstatPgallocNormal => "VMSTAT_PGALLOC_NORMAL",
            Self::VmstatPgallocMovable => "VMSTAT_PGALLOC_MOVABLE",
            Self::VmstatPgfree => "VMSTAT_PGFREE",
            Self::VmstatPgactivate => "VMSTAT_PGACTIVATE",
            Self::VmstatPgdeactivate => "VMSTAT_PGDEACTIVATE",
            Self::VmstatPgfault => "VMSTAT_PGFAULT",
            Self::VmstatPgmajfault => "VMSTAT_PGMAJFAULT",
            Self::VmstatPgrefillDma => "VMSTAT_PGREFILL_DMA",
            Self::VmstatPgrefillNormal => "VMSTAT_PGREFILL_NORMAL",
            Self::VmstatPgrefillMovable => "VMSTAT_PGREFILL_MOVABLE",
            Self::VmstatPgstealKswapdDma => "VMSTAT_PGSTEAL_KSWAPD_DMA",
            Self::VmstatPgstealKswapdNormal => "VMSTAT_PGSTEAL_KSWAPD_NORMAL",
            Self::VmstatPgstealKswapdMovable => "VMSTAT_PGSTEAL_KSWAPD_MOVABLE",
            Self::VmstatPgstealDirectDma => "VMSTAT_PGSTEAL_DIRECT_DMA",
            Self::VmstatPgstealDirectNormal => "VMSTAT_PGSTEAL_DIRECT_NORMAL",
            Self::VmstatPgstealDirectMovable => "VMSTAT_PGSTEAL_DIRECT_MOVABLE",
            Self::VmstatPgscanKswapdDma => "VMSTAT_PGSCAN_KSWAPD_DMA",
            Self::VmstatPgscanKswapdNormal => "VMSTAT_PGSCAN_KSWAPD_NORMAL",
            Self::VmstatPgscanKswapdMovable => "VMSTAT_PGSCAN_KSWAPD_MOVABLE",
            Self::VmstatPgscanDirectDma => "VMSTAT_PGSCAN_DIRECT_DMA",
            Self::VmstatPgscanDirectNormal => "VMSTAT_PGSCAN_DIRECT_NORMAL",
            Self::VmstatPgscanDirectMovable => "VMSTAT_PGSCAN_DIRECT_MOVABLE",
            Self::VmstatPgscanDirectThrottle => "VMSTAT_PGSCAN_DIRECT_THROTTLE",
            Self::VmstatPginodesteal => "VMSTAT_PGINODESTEAL",
            Self::VmstatSlabsScanned => "VMSTAT_SLABS_SCANNED",
            Self::VmstatKswapdInodesteal => "VMSTAT_KSWAPD_INODESTEAL",
            Self::VmstatKswapdLowWmarkHitQuickly => "VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY",
            Self::VmstatKswapdHighWmarkHitQuickly => {
                "VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY"
            }
            Self::VmstatPageoutrun => "VMSTAT_PAGEOUTRUN",
            Self::VmstatAllocstall => "VMSTAT_ALLOCSTALL",
            Self::VmstatPgrotated => "VMSTAT_PGROTATED",
            Self::VmstatDropPagecache => "VMSTAT_DROP_PAGECACHE",
            Self::VmstatDropSlab => "VMSTAT_DROP_SLAB",
            Self::VmstatPgmigrateSuccess => "VMSTAT_PGMIGRATE_SUCCESS",
            Self::VmstatPgmigrateFail => "VMSTAT_PGMIGRATE_FAIL",
            Self::VmstatCompactMigrateScanned => "VMSTAT_COMPACT_MIGRATE_SCANNED",
            Self::VmstatCompactFreeScanned => "VMSTAT_COMPACT_FREE_SCANNED",
            Self::VmstatCompactIsolated => "VMSTAT_COMPACT_ISOLATED",
            Self::VmstatCompactStall => "VMSTAT_COMPACT_STALL",
            Self::VmstatCompactFail => "VMSTAT_COMPACT_FAIL",
            Self::VmstatCompactSuccess => "VMSTAT_COMPACT_SUCCESS",
            Self::VmstatCompactDaemonWake => "VMSTAT_COMPACT_DAEMON_WAKE",
            Self::VmstatUnevictablePgsCulled => "VMSTAT_UNEVICTABLE_PGS_CULLED",
            Self::VmstatUnevictablePgsScanned => "VMSTAT_UNEVICTABLE_PGS_SCANNED",
            Self::VmstatUnevictablePgsRescued => "VMSTAT_UNEVICTABLE_PGS_RESCUED",
            Self::VmstatUnevictablePgsMlocked => "VMSTAT_UNEVICTABLE_PGS_MLOCKED",
            Self::VmstatUnevictablePgsMunlocked => "VMSTAT_UNEVICTABLE_PGS_MUNLOCKED",
            Self::VmstatUnevictablePgsCleared => "VMSTAT_UNEVICTABLE_PGS_CLEARED",
            Self::VmstatUnevictablePgsStranded => "VMSTAT_UNEVICTABLE_PGS_STRANDED",
            Self::VmstatNrZspages => "VMSTAT_NR_ZSPAGES",
            Self::VmstatNrIonHeap => "VMSTAT_NR_ION_HEAP",
            Self::VmstatNrGpuHeap => "VMSTAT_NR_GPU_HEAP",
            Self::VmstatAllocstallDma => "VMSTAT_ALLOCSTALL_DMA",
            Self::VmstatAllocstallMovable => "VMSTAT_ALLOCSTALL_MOVABLE",
            Self::VmstatAllocstallNormal => "VMSTAT_ALLOCSTALL_NORMAL",
            Self::VmstatCompactDaemonFreeScanned => "VMSTAT_COMPACT_DAEMON_FREE_SCANNED",
            Self::VmstatCompactDaemonMigrateScanned => {
                "VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED"
            }
            Self::VmstatNrFastrpc => "VMSTAT_NR_FASTRPC",
            Self::VmstatNrIndirectlyReclaimable => "VMSTAT_NR_INDIRECTLY_RECLAIMABLE",
            Self::VmstatNrIonHeapPool => "VMSTAT_NR_ION_HEAP_POOL",
            Self::VmstatNrKernelMiscReclaimable => "VMSTAT_NR_KERNEL_MISC_RECLAIMABLE",
            Self::VmstatNrShadowCallStackBytes => "VMSTAT_NR_SHADOW_CALL_STACK_BYTES",
            Self::VmstatNrShmemHugepages => "VMSTAT_NR_SHMEM_HUGEPAGES",
            Self::VmstatNrShmemPmdmapped => "VMSTAT_NR_SHMEM_PMDMAPPED",
            Self::VmstatNrUnreclaimablePages => "VMSTAT_NR_UNRECLAIMABLE_PAGES",
            Self::VmstatNrZoneActiveAnon => "VMSTAT_NR_ZONE_ACTIVE_ANON",
            Self::VmstatNrZoneActiveFile => "VMSTAT_NR_ZONE_ACTIVE_FILE",
            Self::VmstatNrZoneInactiveAnon => "VMSTAT_NR_ZONE_INACTIVE_ANON",
            Self::VmstatNrZoneInactiveFile => "VMSTAT_NR_ZONE_INACTIVE_FILE",
            Self::VmstatNrZoneUnevictable => "VMSTAT_NR_ZONE_UNEVICTABLE",
            Self::VmstatNrZoneWritePending => "VMSTAT_NR_ZONE_WRITE_PENDING",
            Self::VmstatOomKill => "VMSTAT_OOM_KILL",
            Self::VmstatPglazyfree => "VMSTAT_PGLAZYFREE",
            Self::VmstatPglazyfreed => "VMSTAT_PGLAZYFREED",
            Self::VmstatPgrefill => "VMSTAT_PGREFILL",
            Self::VmstatPgscanDirect => "VMSTAT_PGSCAN_DIRECT",
            Self::VmstatPgscanKswapd => "VMSTAT_PGSCAN_KSWAPD",
            Self::VmstatPgskipDma => "VMSTAT_PGSKIP_DMA",
            Self::VmstatPgskipMovable => "VMSTAT_PGSKIP_MOVABLE",
            Self::VmstatPgskipNormal => "VMSTAT_PGSKIP_NORMAL",
            Self::VmstatPgstealDirect => "VMSTAT_PGSTEAL_DIRECT",
            Self::VmstatPgstealKswapd => "VMSTAT_PGSTEAL_KSWAPD",
            Self::VmstatSwapRa => "VMSTAT_SWAP_RA",
            Self::VmstatSwapRaHit => "VMSTAT_SWAP_RA_HIT",
            Self::VmstatWorkingsetRestore => "VMSTAT_WORKINGSET_RESTORE",
            Self::VmstatAllocstallDevice => "VMSTAT_ALLOCSTALL_DEVICE",
            Self::VmstatAllocstallDma32 => "VMSTAT_ALLOCSTALL_DMA32",
            Self::VmstatBalloonDeflate => "VMSTAT_BALLOON_DEFLATE",
            Self::VmstatBalloonInflate => "VMSTAT_BALLOON_INFLATE",
            Self::VmstatBalloonMigrate => "VMSTAT_BALLOON_MIGRATE",
            Self::VmstatCmaAllocFail => "VMSTAT_CMA_ALLOC_FAIL",
            Self::VmstatCmaAllocSuccess => "VMSTAT_CMA_ALLOC_SUCCESS",
            Self::VmstatNrFileHugepages => "VMSTAT_NR_FILE_HUGEPAGES",
            Self::VmstatNrFilePmdmapped => "VMSTAT_NR_FILE_PMDMAPPED",
            Self::VmstatNrFollPinAcquired => "VMSTAT_NR_FOLL_PIN_ACQUIRED",
            Self::VmstatNrFollPinReleased => "VMSTAT_NR_FOLL_PIN_RELEASED",
            Self::VmstatNrSecPageTablePages => "VMSTAT_NR_SEC_PAGE_TABLE_PAGES",
            Self::VmstatNrShadowCallStack => "VMSTAT_NR_SHADOW_CALL_STACK",
            Self::VmstatNrSwapcached => "VMSTAT_NR_SWAPCACHED",
            Self::VmstatNrThrottledWritten => "VMSTAT_NR_THROTTLED_WRITTEN",
            Self::VmstatPgallocDevice => "VMSTAT_PGALLOC_DEVICE",
            Self::VmstatPgallocDma32 => "VMSTAT_PGALLOC_DMA32",
            Self::VmstatPgdemoteDirect => "VMSTAT_PGDEMOTE_DIRECT",
            Self::VmstatPgdemoteKswapd => "VMSTAT_PGDEMOTE_KSWAPD",
            Self::VmstatPgreuse => "VMSTAT_PGREUSE",
            Self::VmstatPgscanAnon => "VMSTAT_PGSCAN_ANON",
            Self::VmstatPgscanFile => "VMSTAT_PGSCAN_FILE",
            Self::VmstatPgskipDevice => "VMSTAT_PGSKIP_DEVICE",
            Self::VmstatPgskipDma32 => "VMSTAT_PGSKIP_DMA32",
            Self::VmstatPgstealAnon => "VMSTAT_PGSTEAL_ANON",
            Self::VmstatPgstealFile => "VMSTAT_PGSTEAL_FILE",
            Self::VmstatThpCollapseAlloc => "VMSTAT_THP_COLLAPSE_ALLOC",
            Self::VmstatThpCollapseAllocFailed => "VMSTAT_THP_COLLAPSE_ALLOC_FAILED",
            Self::VmstatThpDeferredSplitPage => "VMSTAT_THP_DEFERRED_SPLIT_PAGE",
            Self::VmstatThpFaultAlloc => "VMSTAT_THP_FAULT_ALLOC",
            Self::VmstatThpFaultFallback => "VMSTAT_THP_FAULT_FALLBACK",
            Self::VmstatThpFaultFallbackCharge => "VMSTAT_THP_FAULT_FALLBACK_CHARGE",
            Self::VmstatThpFileAlloc => "VMSTAT_THP_FILE_ALLOC",
            Self::VmstatThpFileFallback => "VMSTAT_THP_FILE_FALLBACK",
            Self::VmstatThpFileFallbackCharge => "VMSTAT_THP_FILE_FALLBACK_CHARGE",
            Self::VmstatThpFileMapped => "VMSTAT_THP_FILE_MAPPED",
            Self::VmstatThpMigrationFail => "VMSTAT_THP_MIGRATION_FAIL",
            Self::VmstatThpMigrationSplit => "VMSTAT_THP_MIGRATION_SPLIT",
            Self::VmstatThpMigrationSuccess => "VMSTAT_THP_MIGRATION_SUCCESS",
            Self::VmstatThpScanExceedNonePte => "VMSTAT_THP_SCAN_EXCEED_NONE_PTE",
            Self::VmstatThpScanExceedSharePte => "VMSTAT_THP_SCAN_EXCEED_SHARE_PTE",
            Self::VmstatThpScanExceedSwapPte => "VMSTAT_THP_SCAN_EXCEED_SWAP_PTE",
            Self::VmstatThpSplitPage => "VMSTAT_THP_SPLIT_PAGE",
            Self::VmstatThpSplitPageFailed => "VMSTAT_THP_SPLIT_PAGE_FAILED",
            Self::VmstatThpSplitPmd => "VMSTAT_THP_SPLIT_PMD",
            Self::VmstatThpSwpout => "VMSTAT_THP_SWPOUT",
            Self::VmstatThpSwpoutFallback => "VMSTAT_THP_SWPOUT_FALLBACK",
            Self::VmstatThpZeroPageAlloc => "VMSTAT_THP_ZERO_PAGE_ALLOC",
            Self::VmstatThpZeroPageAllocFailed => "VMSTAT_THP_ZERO_PAGE_ALLOC_FAILED",
            Self::VmstatVmaLockAbort => "VMSTAT_VMA_LOCK_ABORT",
            Self::VmstatVmaLockMiss => "VMSTAT_VMA_LOCK_MISS",
            Self::VmstatVmaLockRetry => "VMSTAT_VMA_LOCK_RETRY",
            Self::VmstatVmaLockSuccess => "VMSTAT_VMA_LOCK_SUCCESS",
            Self::VmstatWorkingsetActivateAnon => "VMSTAT_WORKINGSET_ACTIVATE_ANON",
            Self::VmstatWorkingsetActivateFile => "VMSTAT_WORKINGSET_ACTIVATE_FILE",
            Self::VmstatWorkingsetNodes => "VMSTAT_WORKINGSET_NODES",
            Self::VmstatWorkingsetRefaultAnon => "VMSTAT_WORKINGSET_REFAULT_ANON",
            Self::VmstatWorkingsetRefaultFile => "VMSTAT_WORKINGSET_REFAULT_FILE",
            Self::VmstatWorkingsetRestoreAnon => "VMSTAT_WORKINGSET_RESTORE_ANON",
            Self::VmstatWorkingsetRestoreFile => "VMSTAT_WORKINGSET_RESTORE_FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VMSTAT_UNSPECIFIED" => Some(Self::VmstatUnspecified),
            "VMSTAT_NR_FREE_PAGES" => Some(Self::VmstatNrFreePages),
            "VMSTAT_NR_ALLOC_BATCH" => Some(Self::VmstatNrAllocBatch),
            "VMSTAT_NR_INACTIVE_ANON" => Some(Self::VmstatNrInactiveAnon),
            "VMSTAT_NR_ACTIVE_ANON" => Some(Self::VmstatNrActiveAnon),
            "VMSTAT_NR_INACTIVE_FILE" => Some(Self::VmstatNrInactiveFile),
            "VMSTAT_NR_ACTIVE_FILE" => Some(Self::VmstatNrActiveFile),
            "VMSTAT_NR_UNEVICTABLE" => Some(Self::VmstatNrUnevictable),
            "VMSTAT_NR_MLOCK" => Some(Self::VmstatNrMlock),
            "VMSTAT_NR_ANON_PAGES" => Some(Self::VmstatNrAnonPages),
            "VMSTAT_NR_MAPPED" => Some(Self::VmstatNrMapped),
            "VMSTAT_NR_FILE_PAGES" => Some(Self::VmstatNrFilePages),
            "VMSTAT_NR_DIRTY" => Some(Self::VmstatNrDirty),
            "VMSTAT_NR_WRITEBACK" => Some(Self::VmstatNrWriteback),
            "VMSTAT_NR_SLAB_RECLAIMABLE" => Some(Self::VmstatNrSlabReclaimable),
            "VMSTAT_NR_SLAB_UNRECLAIMABLE" => Some(Self::VmstatNrSlabUnreclaimable),
            "VMSTAT_NR_PAGE_TABLE_PAGES" => Some(Self::VmstatNrPageTablePages),
            "VMSTAT_NR_KERNEL_STACK" => Some(Self::VmstatNrKernelStack),
            "VMSTAT_NR_OVERHEAD" => Some(Self::VmstatNrOverhead),
            "VMSTAT_NR_UNSTABLE" => Some(Self::VmstatNrUnstable),
            "VMSTAT_NR_BOUNCE" => Some(Self::VmstatNrBounce),
            "VMSTAT_NR_VMSCAN_WRITE" => Some(Self::VmstatNrVmscanWrite),
            "VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM" => {
                Some(Self::VmstatNrVmscanImmediateReclaim)
            }
            "VMSTAT_NR_WRITEBACK_TEMP" => Some(Self::VmstatNrWritebackTemp),
            "VMSTAT_NR_ISOLATED_ANON" => Some(Self::VmstatNrIsolatedAnon),
            "VMSTAT_NR_ISOLATED_FILE" => Some(Self::VmstatNrIsolatedFile),
            "VMSTAT_NR_SHMEM" => Some(Self::VmstatNrShmem),
            "VMSTAT_NR_DIRTIED" => Some(Self::VmstatNrDirtied),
            "VMSTAT_NR_WRITTEN" => Some(Self::VmstatNrWritten),
            "VMSTAT_NR_PAGES_SCANNED" => Some(Self::VmstatNrPagesScanned),
            "VMSTAT_WORKINGSET_REFAULT" => Some(Self::VmstatWorkingsetRefault),
            "VMSTAT_WORKINGSET_ACTIVATE" => Some(Self::VmstatWorkingsetActivate),
            "VMSTAT_WORKINGSET_NODERECLAIM" => Some(Self::VmstatWorkingsetNodereclaim),
            "VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES" => {
                Some(Self::VmstatNrAnonTransparentHugepages)
            }
            "VMSTAT_NR_FREE_CMA" => Some(Self::VmstatNrFreeCma),
            "VMSTAT_NR_SWAPCACHE" => Some(Self::VmstatNrSwapcache),
            "VMSTAT_NR_DIRTY_THRESHOLD" => Some(Self::VmstatNrDirtyThreshold),
            "VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD" => {
                Some(Self::VmstatNrDirtyBackgroundThreshold)
            }
            "VMSTAT_PGPGIN" => Some(Self::VmstatPgpgin),
            "VMSTAT_PGPGOUT" => Some(Self::VmstatPgpgout),
            "VMSTAT_PGPGOUTCLEAN" => Some(Self::VmstatPgpgoutclean),
            "VMSTAT_PSWPIN" => Some(Self::VmstatPswpin),
            "VMSTAT_PSWPOUT" => Some(Self::VmstatPswpout),
            "VMSTAT_PGALLOC_DMA" => Some(Self::VmstatPgallocDma),
            "VMSTAT_PGALLOC_NORMAL" => Some(Self::VmstatPgallocNormal),
            "VMSTAT_PGALLOC_MOVABLE" => Some(Self::VmstatPgallocMovable),
            "VMSTAT_PGFREE" => Some(Self::VmstatPgfree),
            "VMSTAT_PGACTIVATE" => Some(Self::VmstatPgactivate),
            "VMSTAT_PGDEACTIVATE" => Some(Self::VmstatPgdeactivate),
            "VMSTAT_PGFAULT" => Some(Self::VmstatPgfault),
            "VMSTAT_PGMAJFAULT" => Some(Self::VmstatPgmajfault),
            "VMSTAT_PGREFILL_DMA" => Some(Self::VmstatPgrefillDma),
            "VMSTAT_PGREFILL_NORMAL" => Some(Self::VmstatPgrefillNormal),
            "VMSTAT_PGREFILL_MOVABLE" => Some(Self::VmstatPgrefillMovable),
            "VMSTAT_PGSTEAL_KSWAPD_DMA" => Some(Self::VmstatPgstealKswapdDma),
            "VMSTAT_PGSTEAL_KSWAPD_NORMAL" => Some(Self::VmstatPgstealKswapdNormal),
            "VMSTAT_PGSTEAL_KSWAPD_MOVABLE" => Some(Self::VmstatPgstealKswapdMovable),
            "VMSTAT_PGSTEAL_DIRECT_DMA" => Some(Self::VmstatPgstealDirectDma),
            "VMSTAT_PGSTEAL_DIRECT_NORMAL" => Some(Self::VmstatPgstealDirectNormal),
            "VMSTAT_PGSTEAL_DIRECT_MOVABLE" => Some(Self::VmstatPgstealDirectMovable),
            "VMSTAT_PGSCAN_KSWAPD_DMA" => Some(Self::VmstatPgscanKswapdDma),
            "VMSTAT_PGSCAN_KSWAPD_NORMAL" => Some(Self::VmstatPgscanKswapdNormal),
            "VMSTAT_PGSCAN_KSWAPD_MOVABLE" => Some(Self::VmstatPgscanKswapdMovable),
            "VMSTAT_PGSCAN_DIRECT_DMA" => Some(Self::VmstatPgscanDirectDma),
            "VMSTAT_PGSCAN_DIRECT_NORMAL" => Some(Self::VmstatPgscanDirectNormal),
            "VMSTAT_PGSCAN_DIRECT_MOVABLE" => Some(Self::VmstatPgscanDirectMovable),
            "VMSTAT_PGSCAN_DIRECT_THROTTLE" => Some(Self::VmstatPgscanDirectThrottle),
            "VMSTAT_PGINODESTEAL" => Some(Self::VmstatPginodesteal),
            "VMSTAT_SLABS_SCANNED" => Some(Self::VmstatSlabsScanned),
            "VMSTAT_KSWAPD_INODESTEAL" => Some(Self::VmstatKswapdInodesteal),
            "VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY" => {
                Some(Self::VmstatKswapdLowWmarkHitQuickly)
            }
            "VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY" => {
                Some(Self::VmstatKswapdHighWmarkHitQuickly)
            }
            "VMSTAT_PAGEOUTRUN" => Some(Self::VmstatPageoutrun),
            "VMSTAT_ALLOCSTALL" => Some(Self::VmstatAllocstall),
            "VMSTAT_PGROTATED" => Some(Self::VmstatPgrotated),
            "VMSTAT_DROP_PAGECACHE" => Some(Self::VmstatDropPagecache),
            "VMSTAT_DROP_SLAB" => Some(Self::VmstatDropSlab),
            "VMSTAT_PGMIGRATE_SUCCESS" => Some(Self::VmstatPgmigrateSuccess),
            "VMSTAT_PGMIGRATE_FAIL" => Some(Self::VmstatPgmigrateFail),
            "VMSTAT_COMPACT_MIGRATE_SCANNED" => Some(Self::VmstatCompactMigrateScanned),
            "VMSTAT_COMPACT_FREE_SCANNED" => Some(Self::VmstatCompactFreeScanned),
            "VMSTAT_COMPACT_ISOLATED" => Some(Self::VmstatCompactIsolated),
            "VMSTAT_COMPACT_STALL" => Some(Self::VmstatCompactStall),
            "VMSTAT_COMPACT_FAIL" => Some(Self::VmstatCompactFail),
            "VMSTAT_COMPACT_SUCCESS" => Some(Self::VmstatCompactSuccess),
            "VMSTAT_COMPACT_DAEMON_WAKE" => Some(Self::VmstatCompactDaemonWake),
            "VMSTAT_UNEVICTABLE_PGS_CULLED" => Some(Self::VmstatUnevictablePgsCulled),
            "VMSTAT_UNEVICTABLE_PGS_SCANNED" => Some(Self::VmstatUnevictablePgsScanned),
            "VMSTAT_UNEVICTABLE_PGS_RESCUED" => Some(Self::VmstatUnevictablePgsRescued),
            "VMSTAT_UNEVICTABLE_PGS_MLOCKED" => Some(Self::VmstatUnevictablePgsMlocked),
            "VMSTAT_UNEVICTABLE_PGS_MUNLOCKED" => {
                Some(Self::VmstatUnevictablePgsMunlocked)
            }
            "VMSTAT_UNEVICTABLE_PGS_CLEARED" => Some(Self::VmstatUnevictablePgsCleared),
            "VMSTAT_UNEVICTABLE_PGS_STRANDED" => Some(Self::VmstatUnevictablePgsStranded),
            "VMSTAT_NR_ZSPAGES" => Some(Self::VmstatNrZspages),
            "VMSTAT_NR_ION_HEAP" => Some(Self::VmstatNrIonHeap),
            "VMSTAT_NR_GPU_HEAP" => Some(Self::VmstatNrGpuHeap),
            "VMSTAT_ALLOCSTALL_DMA" => Some(Self::VmstatAllocstallDma),
            "VMSTAT_ALLOCSTALL_MOVABLE" => Some(Self::VmstatAllocstallMovable),
            "VMSTAT_ALLOCSTALL_NORMAL" => Some(Self::VmstatAllocstallNormal),
            "VMSTAT_COMPACT_DAEMON_FREE_SCANNED" => {
                Some(Self::VmstatCompactDaemonFreeScanned)
            }
            "VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED" => {
                Some(Self::VmstatCompactDaemonMigrateScanned)
            }
            "VMSTAT_NR_FASTRPC" => Some(Self::VmstatNrFastrpc),
            "VMSTAT_NR_INDIRECTLY_RECLAIMABLE" => {
                Some(Self::VmstatNrIndirectlyReclaimable)
            }
            "VMSTAT_NR_ION_HEAP_POOL" => Some(Self::VmstatNrIonHeapPool),
            "VMSTAT_NR_KERNEL_MISC_RECLAIMABLE" => {
                Some(Self::VmstatNrKernelMiscReclaimable)
            }
            "VMSTAT_NR_SHADOW_CALL_STACK_BYTES" => {
                Some(Self::VmstatNrShadowCallStackBytes)
            }
            "VMSTAT_NR_SHMEM_HUGEPAGES" => Some(Self::VmstatNrShmemHugepages),
            "VMSTAT_NR_SHMEM_PMDMAPPED" => Some(Self::VmstatNrShmemPmdmapped),
            "VMSTAT_NR_UNRECLAIMABLE_PAGES" => Some(Self::VmstatNrUnreclaimablePages),
            "VMSTAT_NR_ZONE_ACTIVE_ANON" => Some(Self::VmstatNrZoneActiveAnon),
            "VMSTAT_NR_ZONE_ACTIVE_FILE" => Some(Self::VmstatNrZoneActiveFile),
            "VMSTAT_NR_ZONE_INACTIVE_ANON" => Some(Self::VmstatNrZoneInactiveAnon),
            "VMSTAT_NR_ZONE_INACTIVE_FILE" => Some(Self::VmstatNrZoneInactiveFile),
            "VMSTAT_NR_ZONE_UNEVICTABLE" => Some(Self::VmstatNrZoneUnevictable),
            "VMSTAT_NR_ZONE_WRITE_PENDING" => Some(Self::VmstatNrZoneWritePending),
            "VMSTAT_OOM_KILL" => Some(Self::VmstatOomKill),
            "VMSTAT_PGLAZYFREE" => Some(Self::VmstatPglazyfree),
            "VMSTAT_PGLAZYFREED" => Some(Self::VmstatPglazyfreed),
            "VMSTAT_PGREFILL" => Some(Self::VmstatPgrefill),
            "VMSTAT_PGSCAN_DIRECT" => Some(Self::VmstatPgscanDirect),
            "VMSTAT_PGSCAN_KSWAPD" => Some(Self::VmstatPgscanKswapd),
            "VMSTAT_PGSKIP_DMA" => Some(Self::VmstatPgskipDma),
            "VMSTAT_PGSKIP_MOVABLE" => Some(Self::VmstatPgskipMovable),
            "VMSTAT_PGSKIP_NORMAL" => Some(Self::VmstatPgskipNormal),
            "VMSTAT_PGSTEAL_DIRECT" => Some(Self::VmstatPgstealDirect),
            "VMSTAT_PGSTEAL_KSWAPD" => Some(Self::VmstatPgstealKswapd),
            "VMSTAT_SWAP_RA" => Some(Self::VmstatSwapRa),
            "VMSTAT_SWAP_RA_HIT" => Some(Self::VmstatSwapRaHit),
            "VMSTAT_WORKINGSET_RESTORE" => Some(Self::VmstatWorkingsetRestore),
            "VMSTAT_ALLOCSTALL_DEVICE" => Some(Self::VmstatAllocstallDevice),
            "VMSTAT_ALLOCSTALL_DMA32" => Some(Self::VmstatAllocstallDma32),
            "VMSTAT_BALLOON_DEFLATE" => Some(Self::VmstatBalloonDeflate),
            "VMSTAT_BALLOON_INFLATE" => Some(Self::VmstatBalloonInflate),
            "VMSTAT_BALLOON_MIGRATE" => Some(Self::VmstatBalloonMigrate),
            "VMSTAT_CMA_ALLOC_FAIL" => Some(Self::VmstatCmaAllocFail),
            "VMSTAT_CMA_ALLOC_SUCCESS" => Some(Self::VmstatCmaAllocSuccess),
            "VMSTAT_NR_FILE_HUGEPAGES" => Some(Self::VmstatNrFileHugepages),
            "VMSTAT_NR_FILE_PMDMAPPED" => Some(Self::VmstatNrFilePmdmapped),
            "VMSTAT_NR_FOLL_PIN_ACQUIRED" => Some(Self::VmstatNrFollPinAcquired),
            "VMSTAT_NR_FOLL_PIN_RELEASED" => Some(Self::VmstatNrFollPinReleased),
            "VMSTAT_NR_SEC_PAGE_TABLE_PAGES" => Some(Self::VmstatNrSecPageTablePages),
            "VMSTAT_NR_SHADOW_CALL_STACK" => Some(Self::VmstatNrShadowCallStack),
            "VMSTAT_NR_SWAPCACHED" => Some(Self::VmstatNrSwapcached),
            "VMSTAT_NR_THROTTLED_WRITTEN" => Some(Self::VmstatNrThrottledWritten),
            "VMSTAT_PGALLOC_DEVICE" => Some(Self::VmstatPgallocDevice),
            "VMSTAT_PGALLOC_DMA32" => Some(Self::VmstatPgallocDma32),
            "VMSTAT_PGDEMOTE_DIRECT" => Some(Self::VmstatPgdemoteDirect),
            "VMSTAT_PGDEMOTE_KSWAPD" => Some(Self::VmstatPgdemoteKswapd),
            "VMSTAT_PGREUSE" => Some(Self::VmstatPgreuse),
            "VMSTAT_PGSCAN_ANON" => Some(Self::VmstatPgscanAnon),
            "VMSTAT_PGSCAN_FILE" => Some(Self::VmstatPgscanFile),
            "VMSTAT_PGSKIP_DEVICE" => Some(Self::VmstatPgskipDevice),
            "VMSTAT_PGSKIP_DMA32" => Some(Self::VmstatPgskipDma32),
            "VMSTAT_PGSTEAL_ANON" => Some(Self::VmstatPgstealAnon),
            "VMSTAT_PGSTEAL_FILE" => Some(Self::VmstatPgstealFile),
            "VMSTAT_THP_COLLAPSE_ALLOC" => Some(Self::VmstatThpCollapseAlloc),
            "VMSTAT_THP_COLLAPSE_ALLOC_FAILED" => {
                Some(Self::VmstatThpCollapseAllocFailed)
            }
            "VMSTAT_THP_DEFERRED_SPLIT_PAGE" => Some(Self::VmstatThpDeferredSplitPage),
            "VMSTAT_THP_FAULT_ALLOC" => Some(Self::VmstatThpFaultAlloc),
            "VMSTAT_THP_FAULT_FALLBACK" => Some(Self::VmstatThpFaultFallback),
            "VMSTAT_THP_FAULT_FALLBACK_CHARGE" => {
                Some(Self::VmstatThpFaultFallbackCharge)
            }
            "VMSTAT_THP_FILE_ALLOC" => Some(Self::VmstatThpFileAlloc),
            "VMSTAT_THP_FILE_FALLBACK" => Some(Self::VmstatThpFileFallback),
            "VMSTAT_THP_FILE_FALLBACK_CHARGE" => Some(Self::VmstatThpFileFallbackCharge),
            "VMSTAT_THP_FILE_MAPPED" => Some(Self::VmstatThpFileMapped),
            "VMSTAT_THP_MIGRATION_FAIL" => Some(Self::VmstatThpMigrationFail),
            "VMSTAT_THP_MIGRATION_SPLIT" => Some(Self::VmstatThpMigrationSplit),
            "VMSTAT_THP_MIGRATION_SUCCESS" => Some(Self::VmstatThpMigrationSuccess),
            "VMSTAT_THP_SCAN_EXCEED_NONE_PTE" => Some(Self::VmstatThpScanExceedNonePte),
            "VMSTAT_THP_SCAN_EXCEED_SHARE_PTE" => Some(Self::VmstatThpScanExceedSharePte),
            "VMSTAT_THP_SCAN_EXCEED_SWAP_PTE" => Some(Self::VmstatThpScanExceedSwapPte),
            "VMSTAT_THP_SPLIT_PAGE" => Some(Self::VmstatThpSplitPage),
            "VMSTAT_THP_SPLIT_PAGE_FAILED" => Some(Self::VmstatThpSplitPageFailed),
            "VMSTAT_THP_SPLIT_PMD" => Some(Self::VmstatThpSplitPmd),
            "VMSTAT_THP_SWPOUT" => Some(Self::VmstatThpSwpout),
            "VMSTAT_THP_SWPOUT_FALLBACK" => Some(Self::VmstatThpSwpoutFallback),
            "VMSTAT_THP_ZERO_PAGE_ALLOC" => Some(Self::VmstatThpZeroPageAlloc),
            "VMSTAT_THP_ZERO_PAGE_ALLOC_FAILED" => {
                Some(Self::VmstatThpZeroPageAllocFailed)
            }
            "VMSTAT_VMA_LOCK_ABORT" => Some(Self::VmstatVmaLockAbort),
            "VMSTAT_VMA_LOCK_MISS" => Some(Self::VmstatVmaLockMiss),
            "VMSTAT_VMA_LOCK_RETRY" => Some(Self::VmstatVmaLockRetry),
            "VMSTAT_VMA_LOCK_SUCCESS" => Some(Self::VmstatVmaLockSuccess),
            "VMSTAT_WORKINGSET_ACTIVATE_ANON" => Some(Self::VmstatWorkingsetActivateAnon),
            "VMSTAT_WORKINGSET_ACTIVATE_FILE" => Some(Self::VmstatWorkingsetActivateFile),
            "VMSTAT_WORKINGSET_NODES" => Some(Self::VmstatWorkingsetNodes),
            "VMSTAT_WORKINGSET_REFAULT_ANON" => Some(Self::VmstatWorkingsetRefaultAnon),
            "VMSTAT_WORKINGSET_REFAULT_FILE" => Some(Self::VmstatWorkingsetRefaultFile),
            "VMSTAT_WORKINGSET_RESTORE_ANON" => Some(Self::VmstatWorkingsetRestoreAnon),
            "VMSTAT_WORKINGSET_RESTORE_FILE" => Some(Self::VmstatWorkingsetRestoreFile),
            _ => None,
        }
    }
}
/// This file defines the configuration for the Linux /proc poller data source,
/// which injects counters in the trace.
/// Counters that are needed in the trace must be explicitly listed in the
/// *_counters fields. This is to avoid spamming the trace with all counters
/// at all times.
/// The sampling rate is configurable. All polling rates (*_period_ms) need
/// to be integer multiples of each other.
/// OK:     \[10ms, 10ms, 10ms\],  \[10ms, 20ms, 10ms\],  \[10ms, 20ms, 60ms\]
/// Not OK: \[10ms, 10ms, 11ms\],  \[10ms, 15ms, 20ms\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SysStatsConfig {
    /// Polls /proc/meminfo every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    /// Cost: 0.3 ms \[read\] + 0.07 ms \[parse + trace injection\]
    #[prost(uint32, optional, tag = "1")]
    pub meminfo_period_ms: ::core::option::Option<u32>,
    /// If empty all known counters are reported. Otherwise, only the counters
    /// specified below are reported.
    #[prost(enumeration = "MeminfoCounters", repeated, packed = "false", tag = "2")]
    pub meminfo_counters: ::prost::alloc::vec::Vec<i32>,
    /// Polls /proc/vmstat every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    /// Cost: 0.2 ms \[read\] + 0.3 ms \[parse + trace injection\]
    #[prost(uint32, optional, tag = "3")]
    pub vmstat_period_ms: ::core::option::Option<u32>,
    #[prost(enumeration = "VmstatCounters", repeated, packed = "false", tag = "4")]
    pub vmstat_counters: ::prost::alloc::vec::Vec<i32>,
    /// Pols /proc/stat every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    /// Cost: 4.1 ms \[read\] + 1.9 ms \[parse + trace injection\]
    #[prost(uint32, optional, tag = "5")]
    pub stat_period_ms: ::core::option::Option<u32>,
    #[prost(
        enumeration = "sys_stats_config::StatCounters",
        repeated,
        packed = "false",
        tag = "6"
    )]
    pub stat_counters: ::prost::alloc::vec::Vec<i32>,
    /// Polls /sys/devfreq/*/curfreq every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    /// This option can be used to record unchanging values.
    /// Updates from frequency changes can come from ftrace/set_clock_rate.
    #[prost(uint32, optional, tag = "7")]
    pub devfreq_period_ms: ::core::option::Option<u32>,
    /// Polls /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq every X ms.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "8")]
    pub cpufreq_period_ms: ::core::option::Option<u32>,
    /// Polls /proc/buddyinfo every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "9")]
    pub buddyinfo_period_ms: ::core::option::Option<u32>,
    /// Polls /proc/diskstats every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "10")]
    pub diskstat_period_ms: ::core::option::Option<u32>,
    /// Polls /proc/pressure/* every X ms, if non-zero.
    /// This is required to be > 10ms to avoid excessive CPU usage.
    #[prost(uint32, optional, tag = "11")]
    pub psi_period_ms: ::core::option::Option<u32>,
}
/// Nested message and enum types in `SysStatsConfig`.
pub mod sys_stats_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StatCounters {
        StatUnspecified = 0,
        StatCpuTimes = 1,
        StatIrqCounts = 2,
        StatSoftirqCounts = 3,
        StatForkCount = 4,
    }
    impl StatCounters {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StatUnspecified => "STAT_UNSPECIFIED",
                Self::StatCpuTimes => "STAT_CPU_TIMES",
                Self::StatIrqCounts => "STAT_IRQ_COUNTS",
                Self::StatSoftirqCounts => "STAT_SOFTIRQ_COUNTS",
                Self::StatForkCount => "STAT_FORK_COUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STAT_UNSPECIFIED" => Some(Self::StatUnspecified),
                "STAT_CPU_TIMES" => Some(Self::StatCpuTimes),
                "STAT_IRQ_COUNTS" => Some(Self::StatIrqCounts),
                "STAT_SOFTIRQ_COUNTS" => Some(Self::StatSoftirqCounts),
                "STAT_FORK_COUNT" => Some(Self::StatForkCount),
                _ => None,
            }
        }
    }
}
/// The configuration for a fake producer used in tests.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestConfig {
    /// The number of messages the fake producer should send.
    #[prost(uint32, optional, tag = "1")]
    pub message_count: ::core::option::Option<u32>,
    /// The maximum number of messages which should be sent each second.
    /// The actual obserced speed may be lower if the producer is unable to
    /// work fast enough.
    /// If this is zero or unset, the producer will send as fast as possible.
    #[prost(uint32, optional, tag = "2")]
    pub max_messages_per_second: ::core::option::Option<u32>,
    /// The seed value for a simple multiplicative congruential pseudo-random
    /// number sequence.
    #[prost(uint32, optional, tag = "3")]
    pub seed: ::core::option::Option<u32>,
    /// The size of each message in bytes. Should be greater than or equal 5 to
    /// account for the number of bytes needed to encode the random number and a
    /// null byte for the string.
    #[prost(uint32, optional, tag = "4")]
    pub message_size: ::core::option::Option<u32>,
    /// Whether the producer should send a event batch when the data source is
    /// is initially registered.
    #[prost(bool, optional, tag = "5")]
    pub send_batch_on_register: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "6")]
    pub dummy_fields: ::core::option::Option<test_config::DummyFields>,
}
/// Nested message and enum types in `TestConfig`.
pub mod test_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DummyFields {
        #[prost(uint32, optional, tag = "1")]
        pub field_uint32: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "2")]
        pub field_int32: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "3")]
        pub field_uint64: ::core::option::Option<u64>,
        #[prost(int64, optional, tag = "4")]
        pub field_int64: ::core::option::Option<i64>,
        #[prost(fixed64, optional, tag = "5")]
        pub field_fixed64: ::core::option::Option<u64>,
        #[prost(sfixed64, optional, tag = "6")]
        pub field_sfixed64: ::core::option::Option<i64>,
        #[prost(fixed32, optional, tag = "7")]
        pub field_fixed32: ::core::option::Option<u32>,
        #[prost(sfixed32, optional, tag = "8")]
        pub field_sfixed32: ::core::option::Option<i32>,
        #[prost(double, optional, tag = "9")]
        pub field_double: ::core::option::Option<f64>,
        #[prost(float, optional, tag = "10")]
        pub field_float: ::core::option::Option<f32>,
        #[prost(sint64, optional, tag = "11")]
        pub field_sint64: ::core::option::Option<i64>,
        #[prost(sint32, optional, tag = "12")]
        pub field_sint32: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "13")]
        pub field_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "14")]
        pub field_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
/// The following fields define the set of enabled trace categories. Each list
/// item is a glob.
///
/// To determine if category is enabled, it is checked against the filters in
/// the following order:
///
///    1. Exact matches in enabled categories.
///    2. Exact matches in enabled tags.
///    3. Exact matches in disabled categories.
///    4. Exact matches in disabled tags.
///    5. Pattern matches in enabled categories.
///    6. Pattern matches in enabled tags.
///    7. Pattern matches in disabled categories.
///    8. Pattern matches in disabled tags.
///
/// If none of the steps produced a match:
///   - In the C++ SDK (`perfetto::Category`), categories are enabled by
///   default.
///   - In the C SDK (`PerfettoTeCategory`), categories are disabled by default.
///
/// Examples:
///
///   - To enable all non-slow/debug categories:
///
///        enabled_categories: "*"
///
///   - To enable specific categories:
///
///        disabled_categories: "*"
///        enabled_categories: "my_category"
///        enabled_categories: "my_category2"
///
///   - To enable only categories with a specific tag:
///
///        disabled_tags: "*"
///        enabled_tags: "my_tag"
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackEventConfig {
    /// Default: \[\]
    #[prost(string, repeated, tag = "1")]
    pub disabled_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default: \[\]
    #[prost(string, repeated, tag = "2")]
    pub enabled_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default: \["slow", "debug"\]
    #[prost(string, repeated, tag = "3")]
    pub disabled_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default: \[\]
    #[prost(string, repeated, tag = "4")]
    pub enabled_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default: false (i.e. enabled by default)
    #[prost(bool, optional, tag = "5")]
    pub disable_incremental_timestamps: ::core::option::Option<bool>,
    /// Allows to specify a custom unit different than the default (ns).
    /// Also affects thread timestamps if enable_thread_time_sampling = true.
    /// A multiplier of 1000 means that a timestamp = 3 should be interpreted as
    /// 3000 ns = 3 us.
    /// Default: 1 (if unset, it should be read as 1).
    #[prost(uint64, optional, tag = "6")]
    pub timestamp_unit_multiplier: ::core::option::Option<u64>,
    /// Default: false (i.e. debug_annotations is NOT filtered out by default)
    /// When true, any debug annotations provided as arguments to the
    /// TRACE_EVENT macros are not written into the trace. Typed arguments will
    /// still be emitted even if set to true.
    #[prost(bool, optional, tag = "7")]
    pub filter_debug_annotations: ::core::option::Option<bool>,
    /// Default : false (i.e. disabled)
    /// When true, the SDK samples and emits the current thread time counter value
    /// for each event on the current thread's track. This value represents the
    /// total CPU time consumed by that thread since its creation. Note that if a
    /// thread is not scheduled by OS for some duration, that time won't be
    /// included in thread_time.
    /// Learn more : "CLOCK_THREAD_CPUTIME_ID" flag at
    /// <https://linux.die.net/man/3/clock_gettime>
    #[prost(bool, optional, tag = "8")]
    pub enable_thread_time_sampling: ::core::option::Option<bool>,
    /// Default: false (i.e. dynamic event names are NOT filtered out by default)
    /// When true, event_names wrapped in perfetto::DynamicString will be filtered
    /// out.
    #[prost(bool, optional, tag = "9")]
    pub filter_dynamic_event_names: ::core::option::Option<bool>,
}
/// This data-source does a one-off recording of system information when
/// the trace starts.
/// Currently this includes:
/// - Values of
/// /sys/devices/system/cpu/cpu*/cpufreq/scaling_available_frequencies This
/// datasource has no configuration options at present.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemInfoConfig {}
/// The configuration that is passed to each data source when starting tracing.
/// Next id: 130
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSourceConfig {
    /// Data source unique name, e.g., "linux.ftrace". This must match
    /// the name passed by the data source when it registers (see
    /// RegisterDataSource()).
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The index of the logging buffer where TracePacket(s) will be stored.
    /// This field doesn't make a major difference for the Producer(s). The final
    /// logging buffers, in fact, are completely owned by the Service. We just ask
    /// the Producer to copy this number into the chunk headers it emits, so that
    /// the Service can quickly identify the buffer where to move the chunks into
    /// without expensive lookups on its fastpath.
    #[prost(uint32, optional, tag = "2")]
    pub target_buffer: ::core::option::Option<u32>,
    /// Set by the service to indicate the duration of the trace.
    /// DO NOT SET in consumer as this will be overridden by the service.
    #[prost(uint32, optional, tag = "3")]
    pub trace_duration_ms: ::core::option::Option<u32>,
    /// If true, |trace_duration_ms| should count also time in suspend. This
    /// is propagated from TraceConfig.prefer_suspend_clock_for_duration.
    #[prost(bool, optional, tag = "122")]
    pub prefer_suspend_clock_for_duration: ::core::option::Option<bool>,
    /// Set by the service to indicate how long it waits after StopDataSource.
    /// DO NOT SET in consumer as this will be overridden by the service.
    #[prost(uint32, optional, tag = "7")]
    pub stop_timeout_ms: ::core::option::Option<u32>,
    /// Set by the service to indicate whether this tracing session has extra
    /// guardrails.
    /// DO NOT SET in consumer as this will be overridden by the service.
    #[prost(bool, optional, tag = "6")]
    pub enable_extra_guardrails: ::core::option::Option<bool>,
    /// Set by the service to indicate which user initiated this trace.
    /// DO NOT SET in consumer as this will be overridden by the service.
    #[prost(enumeration = "data_source_config::SessionInitiator", optional, tag = "8")]
    pub session_initiator: ::core::option::Option<i32>,
    /// Set by the service to indicate which tracing session the data source
    /// belongs to. The intended use case for this is checking if two data sources,
    /// one of which produces metadata for the other one, belong to the same trace
    /// session and hence should be linked together.
    /// This field was introduced in Aug 2018 after Android P.
    /// DO NOT SET in consumer as this will be overridden by the service.
    #[prost(uint64, optional, tag = "4")]
    pub tracing_session_id: ::core::option::Option<u64>,
    /// Data source name: linux.ftrace
    #[prost(message, optional, tag = "100")]
    pub ftrace_config: ::core::option::Option<FtraceConfig>,
    /// Data source name: linux.inode_file_map
    #[prost(message, optional, tag = "102")]
    pub inode_file_config: ::core::option::Option<InodeFileConfig>,
    /// Data source name: linux.process_stats
    #[prost(message, optional, tag = "103")]
    pub process_stats_config: ::core::option::Option<ProcessStatsConfig>,
    /// Data source name: linux.sys_stats
    #[prost(message, optional, tag = "104")]
    pub sys_stats_config: ::core::option::Option<SysStatsConfig>,
    /// Data source name: android.heapprofd
    /// Introduced in Android 10.
    #[prost(message, optional, tag = "105")]
    pub heapprofd_config: ::core::option::Option<HeapprofdConfig>,
    /// Data source name: android.java_hprof
    /// Introduced in Android 11.
    #[prost(message, optional, tag = "110")]
    pub java_hprof_config: ::core::option::Option<JavaHprofConfig>,
    /// Data source name: android.power
    #[prost(message, optional, tag = "106")]
    pub android_power_config: ::core::option::Option<AndroidPowerConfig>,
    /// Data source name: android.log
    #[prost(message, optional, tag = "107")]
    pub android_log_config: ::core::option::Option<AndroidLogConfig>,
    /// TODO(fmayer): Add data source name for this.
    #[prost(message, optional, tag = "108")]
    pub gpu_counter_config: ::core::option::Option<GpuCounterConfig>,
    /// Data source name: android.game_interventions
    #[prost(message, optional, tag = "116")]
    pub android_game_intervention_list_config: ::core::option::Option<
        AndroidGameInterventionListConfig,
    >,
    /// Data source name: android.packages_list
    #[prost(message, optional, tag = "109")]
    pub packages_list_config: ::core::option::Option<PackagesListConfig>,
    /// Data source name: linux.perf
    #[prost(message, optional, tag = "111")]
    pub perf_event_config: ::core::option::Option<PerfEventConfig>,
    /// Data source name: vulkan.memory_tracker
    #[prost(message, optional, tag = "112")]
    pub vulkan_memory_config: ::core::option::Option<VulkanMemoryConfig>,
    /// Data source name: track_event
    #[prost(message, optional, tag = "113")]
    pub track_event_config: ::core::option::Option<TrackEventConfig>,
    /// Data source name: android.polled_state
    #[prost(message, optional, tag = "114")]
    pub android_polled_state_config: ::core::option::Option<AndroidPolledStateConfig>,
    /// Data source name: android.system_property
    #[prost(message, optional, tag = "118")]
    pub android_system_property_config: ::core::option::Option<
        AndroidSystemPropertyConfig,
    >,
    /// Data source name: android.statsd
    #[prost(message, optional, tag = "117")]
    pub statsd_tracing_config: ::core::option::Option<StatsdTracingConfig>,
    /// Data source name: linux.system_info
    #[prost(message, optional, tag = "119")]
    pub system_info_config: ::core::option::Option<SystemInfoConfig>,
    /// Chrome is special as it doesn't use the perfetto IPC layer. We want to
    /// avoid proto serialization and de-serialization there because that would
    /// just add extra hops on top of the Mojo ser/des. Instead we auto-generate a
    /// C++ class for it so it can pass around plain C++ objets.
    #[prost(message, optional, tag = "101")]
    pub chrome_config: ::core::option::Option<ChromeConfig>,
    /// Data source name: code.v8.dev
    #[prost(message, optional, tag = "127")]
    pub v8_config: ::core::option::Option<V8Config>,
    /// If an interceptor is specified here, packets for this data source will be
    /// rerouted to the interceptor instead of the main trace buffer. This can be
    /// used, for example, to write trace data into ETW or for logging trace points
    /// to the console.
    ///
    /// Note that interceptors are only supported by data sources registered
    /// through the Perfetto SDK API. Data sources that don't use that API (e.g.,
    /// traced_probes) may not support interception.
    #[prost(message, optional, tag = "115")]
    pub interceptor_config: ::core::option::Option<InterceptorConfig>,
    /// Data source name: android.network_packets.
    /// Introduced in Android 14 (U).
    #[prost(message, optional, tag = "120")]
    pub network_packet_trace_config: ::core::option::Option<NetworkPacketTraceConfig>,
    /// Data source name: android.surfaceflinger.layers
    #[prost(message, optional, tag = "121")]
    pub surfaceflinger_layers_config: ::core::option::Option<SurfaceFlingerLayersConfig>,
    /// Data source name: android.surfaceflinger.transactions
    #[prost(message, optional, tag = "123")]
    pub surfaceflinger_transactions_config: ::core::option::Option<
        SurfaceFlingerTransactionsConfig,
    >,
    /// Data source name: android.sdk_sysprop_guard
    /// Introduced in Android 14 (U) QPR1.
    #[prost(message, optional, tag = "124")]
    pub android_sdk_sysprop_guard_config: ::core::option::Option<
        AndroidSdkSyspropGuardConfig,
    >,
    /// Data source name: windows.etw
    #[prost(message, optional, tag = "125")]
    pub etw_config: ::core::option::Option<EtwConfig>,
    /// Data source name: android.protolog
    #[prost(message, optional, tag = "126")]
    pub protolog_config: ::core::option::Option<ProtoLogConfig>,
    /// Data source name: android.input.inputevent
    #[prost(message, optional, tag = "128")]
    pub android_input_event_config: ::core::option::Option<AndroidInputEventConfig>,
    /// Data source name: android.pixel.modem
    #[prost(message, optional, tag = "129")]
    pub pixel_modem_config: ::core::option::Option<PixelModemConfig>,
    /// This is a fallback mechanism to send a free-form text config to the
    /// producer. In theory this should never be needed. All the code that
    /// is part of the platform (i.e. traced service) is supposed to *not* truncate
    /// the trace config proto and propagate unknown fields. However, if anything
    /// in the pipeline (client or backend) ends up breaking this forward compat
    /// plan, this field will become the escape hatch to allow future data sources
    /// to get some meaningful configuration.
    #[prost(string, optional, tag = "1000")]
    pub legacy_config: ::core::option::Option<::prost::alloc::string::String>,
    /// This field is only used for testing.
    #[prost(message, optional, tag = "1001")]
    pub for_testing: ::core::option::Option<TestConfig>,
}
/// Nested message and enum types in `DataSourceConfig`.
pub mod data_source_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionInitiator {
        Unspecified = 0,
        /// This trace was initiated from a trusted system app has DUMP and
        /// USAGE_STATS permission. This system app is expected to not expose the
        /// trace to the user of the device.
        /// This is determined by checking the UID initiating the trace.
        TrustedSystem = 1,
    }
    impl SessionInitiator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SESSION_INITIATOR_UNSPECIFIED",
                Self::TrustedSystem => "SESSION_INITIATOR_TRUSTED_SYSTEM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SESSION_INITIATOR_UNSPECIFIED" => Some(Self::Unspecified),
                "SESSION_INITIATOR_TRUSTED_SYSTEM" => Some(Self::TrustedSystem),
                _ => None,
            }
        }
    }
}
/// The overall config that is used when starting a new tracing session through
/// ProducerPort::StartTracing().
/// It contains the general config for the logging buffer(s) and the configs for
/// all the data source being enabled.
///
/// Next id: 40.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceConfig {
    #[prost(message, repeated, tag = "1")]
    pub buffers: ::prost::alloc::vec::Vec<trace_config::BufferConfig>,
    #[prost(message, repeated, tag = "2")]
    pub data_sources: ::prost::alloc::vec::Vec<trace_config::DataSource>,
    #[prost(message, optional, tag = "20")]
    pub builtin_data_sources: ::core::option::Option<trace_config::BuiltinDataSource>,
    /// If specified, the trace will be stopped |duration_ms| after starting.
    /// This does *not* count the time the system is suspended, so we will run
    /// for duration_ms of system activity, not wall time.
    ///
    /// However in case of traces with triggers, see
    /// TriggerConfig.trigger_timeout_ms instead.
    #[prost(uint32, optional, tag = "3")]
    pub duration_ms: ::core::option::Option<u32>,
    /// If true, tries to use CLOCK_BOOTTIME for duration_ms rather than
    /// CLOCK_MONOTONIC (which doesn't count time in suspend). Supported only on
    /// Linux/Android, no-op on other platforms. This is used when dealing with
    /// long (e.g. 24h) traces, where suspend can inflate them to weeks of
    /// wall-time, making them more likely to hit device reboots (and hence loss).
    /// This option also changes consistently the semantic of
    /// TriggerConfig.stop_delay_ms.
    #[prost(bool, optional, tag = "36")]
    pub prefer_suspend_clock_for_duration: ::core::option::Option<bool>,
    /// This is set when --dropbox is passed to the Perfetto command line client
    /// and enables guardrails that limit resource usage for traces requested
    /// by statsd.
    #[prost(bool, optional, tag = "4")]
    pub enable_extra_guardrails: ::core::option::Option<bool>,
    /// Reject producers that are not running under the same UID as the tracing
    /// service.
    #[prost(enumeration = "trace_config::LockdownModeOperation", optional, tag = "5")]
    pub lockdown_mode: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "6")]
    pub producers: ::prost::alloc::vec::Vec<trace_config::ProducerConfig>,
    /// Statsd-specific metadata.
    #[prost(message, optional, tag = "7")]
    pub statsd_metadata: ::core::option::Option<trace_config::StatsdMetadata>,
    /// When true && |output_path| is empty, the EnableTracing() request must
    /// provide a file descriptor. The service will then periodically read packets
    /// out of the trace buffer and store it into the passed file.
    /// If |output_path| is not empty no fd should be passed, the service
    /// will create a new file and write into that (see comment below).
    #[prost(bool, optional, tag = "8")]
    pub write_into_file: ::core::option::Option<bool>,
    /// This must point to a non-existing file. If the file exists the service
    /// will NOT overwrite and will fail instead as a security precaution.
    /// On Android, when this is used with the system traced, the path must be
    /// within /data/misc/perfetto-traces/ or the trace will fail.
    /// This option has been introduced in Android R. Before R write_into_file
    /// can be used only with the "pass a file descriptor over IPC" mode.
    #[prost(string, optional, tag = "29")]
    pub output_path: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. If non-zero tunes the write period. A min value of 100ms is
    /// enforced (i.e. smaller values are ignored).
    #[prost(uint32, optional, tag = "9")]
    pub file_write_period_ms: ::core::option::Option<u32>,
    /// Optional. When non zero the periodic write stops once at most X bytes
    /// have been written into the file. Tracing is disabled when this limit is
    /// reached, even if |duration_ms| has not been reached yet.
    #[prost(uint64, optional, tag = "10")]
    pub max_file_size_bytes: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "11")]
    pub guardrail_overrides: ::core::option::Option<trace_config::GuardrailOverrides>,
    /// When true, data sources are not started until an explicit call to
    /// StartTracing() on the consumer port. This is to support early
    /// initialization and fast trace triggering. This can be used only when the
    /// Consumer explicitly triggers the StartTracing() method.
    /// This should not be used in a remote trace config via statsd, doing so will
    /// result in a hung trace session.
    #[prost(bool, optional, tag = "12")]
    pub deferred_start: ::core::option::Option<bool>,
    /// When set, it periodically issues a Flush() to all data source, forcing them
    /// to commit their data into the tracing service. This can be used for
    /// quasi-real-time streaming mode and to guarantee some partial ordering of
    /// events in the trace in windows of X ms.
    #[prost(uint32, optional, tag = "13")]
    pub flush_period_ms: ::core::option::Option<u32>,
    /// Wait for this long for producers to acknowledge flush requests.
    /// Default 5s.
    #[prost(uint32, optional, tag = "14")]
    pub flush_timeout_ms: ::core::option::Option<u32>,
    /// Wait for this long for producers to acknowledge stop requests.
    /// Default 5s.
    #[prost(uint32, optional, tag = "23")]
    pub data_source_stop_timeout_ms: ::core::option::Option<u32>,
    /// Android-only. If set, sends an intent to the Traceur system app when the
    /// trace ends to notify it about the trace readiness.
    #[prost(bool, optional, tag = "16")]
    pub notify_traceur: ::core::option::Option<bool>,
    /// This field was introduced in Android S.
    /// Android-only. If set to a value > 0, marks the trace session as a candidate
    /// for being attached to a bugreport. This field effectively acts as a z-index
    /// for bugreports. When Android's dumpstate runs perfetto
    /// --save-for-bugreport, traced will pick the tracing session with the highest
    /// score (score <= 0 is ignored) and:
    /// On Android S, T:  will steal its contents, save the trace into
    ///      a known path and stop prematurely.
    /// On Android U+: will create a read-only snapshot and save that into a known
    ///      path, without stoppin the original tracing session.
    /// When this field is set the tracing session becomes eligible to be cloned
    /// by other UIDs.
    #[prost(int32, optional, tag = "30")]
    pub bugreport_score: ::core::option::Option<i32>,
    /// When set, defines name of the file that will be saved under
    /// /data/misc/perfetto-traces/bugreport/ when using --save-all-for-bugreport.
    /// If omitted, traces will be named systrace.pftrace, systrace_1.pftrace, etc,
    /// starting from the highest `bugreport_score`.
    /// Introduced in v42 / Android V.
    #[prost(string, optional, tag = "38")]
    pub bugreport_filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "17")]
    pub trigger_config: ::core::option::Option<trace_config::TriggerConfig>,
    /// When this is non-empty the perfetto command line tool will ignore the rest
    /// of this TraceConfig and instead connect to the perfetto service as a
    /// producer and send these triggers, potentially stopping or starting traces
    /// that were previous configured to use a TriggerConfig.
    #[prost(string, repeated, tag = "18")]
    pub activate_triggers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "21")]
    pub incremental_state_config: ::core::option::Option<
        trace_config::IncrementalStateConfig,
    >,
    /// Additional guardrail used by the Perfetto command line client.
    /// On user builds when --dropbox is set perfetto will refuse to trace unless
    /// this is also set.
    /// Added in Q.
    #[prost(bool, optional, tag = "19")]
    pub allow_user_build_tracing: ::core::option::Option<bool>,
    /// If set the tracing service will ensure there is at most one tracing session
    /// with this key.
    #[prost(string, optional, tag = "22")]
    pub unique_session_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "trace_config::CompressionType", optional, tag = "24")]
    pub compression_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "25")]
    pub incident_report_config: ::core::option::Option<
        trace_config::IncidentReportConfig,
    >,
    /// Android-only. Not for general use. If specified, sets the logging to statsd
    /// of guardrails and checkpoints in the tracing service. perfetto_cmd sets
    /// this to enabled (if not explicitly set in the config) when specifying
    /// --upload.
    #[prost(enumeration = "trace_config::StatsdLogging", optional, tag = "31")]
    pub statsd_logging: ::core::option::Option<i32>,
    /// An identifier clients can use to tie this trace to other logging.
    /// DEPRECATED as per v32. See TracePacket.trace_uuid for the authoritative
    /// Trace UUID. If this field is set, the tracing service will respect the
    /// requested UUID (i.e. TracePacket.trace_uuid == this field) but only if
    /// gap-less snapshotting is not used.
    #[deprecated]
    #[prost(int64, optional, tag = "27")]
    pub trace_uuid_msb: ::core::option::Option<i64>,
    #[deprecated]
    #[prost(int64, optional, tag = "28")]
    pub trace_uuid_lsb: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "33")]
    pub trace_filter: ::core::option::Option<trace_config::TraceFilter>,
    #[prost(message, optional, tag = "34")]
    pub android_report_config: ::core::option::Option<trace_config::AndroidReportConfig>,
    #[prost(message, optional, tag = "35")]
    pub cmd_trace_start_delay: ::core::option::Option<trace_config::CmdTraceStartDelay>,
    #[prost(message, repeated, tag = "39")]
    pub session_semaphores: ::prost::alloc::vec::Vec<trace_config::SessionSemaphore>,
}
/// Nested message and enum types in `TraceConfig`.
pub mod trace_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BufferConfig {
        #[prost(uint32, optional, tag = "1")]
        pub size_kb: ::core::option::Option<u32>,
        #[prost(enumeration = "buffer_config::FillPolicy", optional, tag = "4")]
        pub fill_policy: ::core::option::Option<i32>,
        /// When true the buffer is moved (rather than copied) onto the cloned
        /// session, and an empty buffer of the same size is allocated in the source
        /// tracing session. This feature will likely get deprecated in the future.
        /// It been introduced mainly to support the surfaceflinger snapshot dump
        /// for bugreports, where SF can dumps O(400MB) into the bugreport trace. In
        /// that case we don't want to retain another in-memory copy of the buffer.
        #[prost(bool, optional, tag = "5")]
        pub transfer_on_clone: ::core::option::Option<bool>,
        /// Used in conjuction with transfer_on_clone. When true the buffer is
        /// cleared before issuing the Flush(reason=kTraceClone). This is to ensure
        /// that if the data source took too long to write the data in a previous
        /// clone-related flush, we don't end up with a mixture of leftovers from
        /// the previous write and new data.
        #[prost(bool, optional, tag = "6")]
        pub clear_before_clone: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `BufferConfig`.
    pub mod buffer_config {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FillPolicy {
            Unspecified = 0,
            /// Default behavior. The buffer operates as a conventional ring buffer.
            /// If the writer is faster than the reader (or if the reader reads only
            /// after tracing is stopped) newly written packets will overwrite old
            /// packets.
            RingBuffer = 1,
            /// Behaves like RING_BUFFER as long as there is space in the buffer or
            /// the reader catches up with the writer. As soon as the writer hits
            /// an unread chunk, it stops accepting new data in the buffer.
            Discard = 2,
        }
        impl FillPolicy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::RingBuffer => "RING_BUFFER",
                    Self::Discard => "DISCARD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "RING_BUFFER" => Some(Self::RingBuffer),
                    "DISCARD" => Some(Self::Discard),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataSource {
        /// Filters and data-source specific config. It contains also the unique name
        /// of the data source, the one passed in the  DataSourceDescriptor when they
        /// register on the service.
        #[prost(message, optional, tag = "1")]
        pub config: ::core::option::Option<super::DataSourceConfig>,
        /// Optional. If multiple producers (~processes) expose the same data source
        /// and either |producer_name_filter| or |producer_name_regex_filter| is set,
        /// the data source is enabled only for producers whose names match any of
        /// the filters.
        /// |producer_name_filter| has to be an exact match, while
        /// |producer_name_regex_filter| is a regular expression.
        /// This allows to enable a data source only for specific processes.
        /// The "repeated" fields have OR semantics: specifying a filter ["foo",
        /// "bar"] will enable data sources on both "foo" and "bar" (if they exist).
        #[prost(string, repeated, tag = "2")]
        pub producer_name_filter: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(string, repeated, tag = "3")]
        pub producer_name_regex_filter: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Config for disabling builtin data sources in the tracing service.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BuiltinDataSource {
        /// Disable emitting clock timestamps into the trace.
        #[prost(bool, optional, tag = "1")]
        pub disable_clock_snapshotting: ::core::option::Option<bool>,
        /// Disable echoing the original trace config in the trace.
        #[prost(bool, optional, tag = "2")]
        pub disable_trace_config: ::core::option::Option<bool>,
        /// Disable emitting system info (build fingerprint, cpuinfo, etc).
        #[prost(bool, optional, tag = "3")]
        pub disable_system_info: ::core::option::Option<bool>,
        /// Disable emitting events for data-source state changes (e.g. the marker
        /// for all data sources having ACKed the start of the trace).
        #[prost(bool, optional, tag = "4")]
        pub disable_service_events: ::core::option::Option<bool>,
        /// The authoritative clock domain for the trace. Defaults to BOOTTIME. See
        /// also ClockSnapshot's primary_trace_clock. The configured value is written
        /// into the trace as part of the ClockSnapshots emitted by the service.
        /// Trace processor will attempt to translate packet/event timestamps from
        /// various data sources (and their chosen clock domains) to this domain
        /// during import. Added in Android R.
        #[prost(enumeration = "super::BuiltinClock", optional, tag = "5")]
        pub primary_trace_clock: ::core::option::Option<i32>,
        /// Time interval in between snapshotting of sync markers, clock snapshots,
        /// stats, and other periodic service-emitted events. Note that the service
        /// only keeps track of the first and the most recent snapshot until
        /// ReadBuffers() is called.
        #[prost(uint32, optional, tag = "6")]
        pub snapshot_interval_ms: ::core::option::Option<u32>,
        /// Hints to the service that a suspend-aware (i.e. counting time in suspend)
        /// clock should be used for periodic snapshots of service-emitted events.
        /// This means, if a snapshot *should* have happened during suspend, it will
        /// happen immediately after the device resumes.
        ///
        /// Choosing a clock like this is done on best-effort basis; not all
        /// platforms (e.g. Windows) expose a clock which can be used for periodic
        /// tasks counting suspend. If such a clock is not available, the service
        /// falls back to the best-available alternative.
        ///
        /// Introduced in Android S.
        /// TODO(lalitm): deprecate this in T and make this the default if nothing
        /// crashes in S.
        #[prost(bool, optional, tag = "7")]
        pub prefer_suspend_clock_for_snapshot: ::core::option::Option<bool>,
        /// Disables the reporting of per-trace-writer histograms in TraceStats.
        #[prost(bool, optional, tag = "8")]
        pub disable_chunk_usage_histograms: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProducerConfig {
        /// Identifies the producer for which this config is for.
        #[prost(string, optional, tag = "1")]
        pub producer_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Specifies the preferred size of the shared memory buffer. If the size is
        /// larger than the max size, the max will be used. If it is smaller than
        /// the page size or doesn't fit pages evenly into it, it will fall back to
        /// the size specified by the producer or finally the default shared memory
        /// size.
        #[prost(uint32, optional, tag = "2")]
        pub shm_size_kb: ::core::option::Option<u32>,
        /// Specifies the preferred size of each page in the shared memory buffer.
        /// Must be an integer multiple of 4K.
        #[prost(uint32, optional, tag = "3")]
        pub page_size_kb: ::core::option::Option<u32>,
    }
    /// Contains statsd-specific metadata about an alert associated with the trace.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StatsdMetadata {
        /// The identifier of the alert which triggered this trace.
        #[prost(int64, optional, tag = "1")]
        pub triggering_alert_id: ::core::option::Option<i64>,
        /// The uid which registered the triggering configuration with statsd.
        #[prost(int32, optional, tag = "2")]
        pub triggering_config_uid: ::core::option::Option<i32>,
        /// The identifier of the config which triggered the alert.
        #[prost(int64, optional, tag = "3")]
        pub triggering_config_id: ::core::option::Option<i64>,
        /// The identifier of the subscription which triggered this trace.
        #[prost(int64, optional, tag = "4")]
        pub triggering_subscription_id: ::core::option::Option<i64>,
    }
    /// Contains flags which override the default values of the guardrails inside
    /// Perfetto.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GuardrailOverrides {
        /// Override the default limit (in bytes) for uploading data to server within
        /// a 24 hour period.
        /// On R-, this override only affected userdebug builds. Since S, it also
        /// affects user builds.
        /// In 24Q3+ (V+), this override is a noop because upload guardrail logic
        /// was removed from Perfetto.
        #[deprecated]
        #[prost(uint64, optional, tag = "1")]
        pub max_upload_per_day_bytes: ::core::option::Option<u64>,
        /// Overrides the guardrail for maximum trace buffer size.
        /// Available on U+
        #[prost(uint32, optional, tag = "2")]
        pub max_tracing_buffer_size_kb: ::core::option::Option<u32>,
    }
    /// Triggers allow producers to start or stop the tracing session when an event
    /// occurs.
    ///
    /// For example if we are tracing probabilistically, most traces will be
    /// uninteresting. Triggers allow us to keep only the interesting ones such as
    /// those traces during which the device temperature reached a certain
    /// threshold. In this case the producer can activate a trigger to keep
    /// (STOP_TRACING) the trace, otherwise it can also begin a trace
    /// (START_TRACING) because it knows something is about to happen.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TriggerConfig {
        #[prost(enumeration = "trigger_config::TriggerMode", optional, tag = "1")]
        pub trigger_mode: ::core::option::Option<i32>,
        /// This flag is really a workaround for b/274931668. This is needed only
        /// when deploying configs to different versions of the tracing service.
        /// When this is set to true this has the same effect of setting trigger_mode
        /// to CLONE_SNAPSHOT on newer versions of the service. This boolean has been
        /// introduced to allow to have configs that use CLONE_SNAPSHOT on newer
        /// versions of Android and fall back to STOP_TRACING on older versions where
        /// CLONE_SNAPSHOT did not exist.
        /// When using this flag, trigger_mode must be set to STOP_TRACING.
        #[prost(bool, optional, tag = "5")]
        pub use_clone_snapshot_if_available: ::core::option::Option<bool>,
        /// A list of triggers which are related to this configuration. If ANY
        /// trigger is seen then an action will be performed based on |trigger_mode|.
        #[prost(message, repeated, tag = "2")]
        pub triggers: ::prost::alloc::vec::Vec<trigger_config::Trigger>,
        /// Required and must be positive if a TriggerConfig is specified. This is
        /// how long this TraceConfig should wait for a trigger to arrive. After this
        /// period of time if no trigger is seen the TracingSession will be cleaned
        /// up.
        #[prost(uint32, optional, tag = "3")]
        pub trigger_timeout_ms: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `TriggerConfig`.
    pub mod trigger_config {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Trigger {
            /// The producer must specify this name to activate the trigger.
            #[prost(string, optional, tag = "1")]
            pub name: ::core::option::Option<::prost::alloc::string::String>,
            /// An std::regex that will match the producer that can activate this
            /// trigger. This is optional. If unset any producers can activate this
            /// trigger.
            #[prost(string, optional, tag = "2")]
            pub producer_name_regex: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
            /// After a trigger is received either in START_TRACING or STOP_TRACING
            /// mode then the trace will end |stop_delay_ms| after triggering.
            /// In CLONE_SNAPSHOT mode, this is the delay between the trigger and the
            /// snapshot.
            /// If |prefer_suspend_clock_for_duration| is set, the duration will be
            /// based on wall-clock, counting also time in suspend.
            #[prost(uint32, optional, tag = "3")]
            pub stop_delay_ms: ::core::option::Option<u32>,
            /// Limits the number of traces this trigger can start/stop in a rolling
            /// 24 hour window. If this field is unset or zero, no limit is applied and
            /// activiation of this trigger *always* starts/stops the trace.
            #[prost(uint32, optional, tag = "4")]
            pub max_per_24_h: ::core::option::Option<u32>,
            /// A value between 0 and 1 which encodes the probability of skipping a
            /// trigger with this name. This is useful for reducing the probability
            /// of high-frequency triggers from dominating trace finaization. If this
            /// field is unset or zero, the trigger will *never* be skipped. If this
            /// field is greater than or equal to 1, this trigger will *always* be
            /// skipped i.e. it will be as if this trigger was never included in the
            /// first place.
            /// This probability check is applied *before* any other limits. For
            /// example, if |max_per_24_h| is also set, first we will check if the
            /// probability bar is met and only then will we check the |max_per_24_h|
            /// limit.
            #[prost(double, optional, tag = "5")]
            pub skip_probability: ::core::option::Option<f64>,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TriggerMode {
            Unspecified = 0,
            /// When this mode is chosen, data sources are not started until one of the
            /// |triggers| are received. This supports early initialization and fast
            /// starting of the tracing system. On triggering, the session will then
            /// record for |stop_delay_ms|. However if no trigger is seen
            /// after |trigger_timeout_ms| the session will be stopped and no data will
            /// be returned.
            StartTracing = 1,
            /// When this mode is chosen, the session will be started via the normal
            /// EnableTracing() & StartTracing(). If no trigger is ever seen
            /// the session will be stopped after |trigger_timeout_ms| and no data will
            /// be returned. However if triggered the trace will stop after
            /// |stop_delay_ms| and any data in the buffer will be returned to the
            /// consumer.
            StopTracing = 2,
            /// When this mode is chosen, this causes a snapshot of the current tracing
            /// session to be created after |stop_delay_ms| while the current tracing
            /// session continues undisturbed (% an extra flush). This mode can be
            /// used only when the tracing session is handled by the "perfetto" cmdline
            /// client (which is true in 90% of cases). Part of the business logic
            /// necessary for this behavior, and ensuing file handling, lives in
            /// perfetto_cmd.cc . On other consumers, this causes only a notification
            /// of the trigger through a CloneTriggerHit ObservableEvent. The custom
            /// consumer is supposed to call CloneSession() itself after the event.
            /// Use use_clone_snapshot_if_available=true when targeting older versions
            /// of perfetto.
            CloneSnapshot = 4,
        }
        impl TriggerMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::StartTracing => "START_TRACING",
                    Self::StopTracing => "STOP_TRACING",
                    Self::CloneSnapshot => "CLONE_SNAPSHOT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "START_TRACING" => Some(Self::StartTracing),
                    "STOP_TRACING" => Some(Self::StopTracing),
                    "CLONE_SNAPSHOT" => Some(Self::CloneSnapshot),
                    _ => None,
                }
            }
        }
    }
    /// Configuration for trace contents that reference earlier trace data. For
    /// example, a data source might intern strings, and emit packets containing
    /// {interned id : string} pairs. Future packets from that data source can then
    /// use the interned ids instead of duplicating the raw string contents. The
    /// trace parser will then need to use that interning table to fully interpret
    /// the rest of the trace.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IncrementalStateConfig {
        /// If nonzero, notify eligible data sources to clear their incremental state
        /// periodically, with the given period. The notification is sent only to
        /// data sources that have |handles_incremental_state_clear| set in their
        /// DataSourceDescriptor. The notification requests that the data source
        /// stops referring to past trace contents. This is particularly useful when
        /// tracing in ring buffer mode, where it is not exceptional to overwrite old
        /// trace data.
        ///
        /// Warning: this time-based global clearing is likely to be removed in the
        /// future, to be replaced with a smarter way of sending the notifications
        /// only when necessary.
        #[prost(uint32, optional, tag = "1")]
        pub clear_period_ms: ::core::option::Option<u32>,
    }
    /// Android-only. Not for general use. If set, saves the trace into an
    /// incident. This field is read by perfetto_cmd, rather than the tracing
    /// service. This field must be set when passing the --upload flag to
    /// perfetto_cmd.
    ///
    /// In this message, either:
    ///   * all of |destination_package|, |destination_class| and |privacy_level|
    ///     must be set.
    ///   * |skip_incidentd| must be explicitly set to true.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IncidentReportConfig {
        #[prost(string, optional, tag = "1")]
        pub destination_package: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub destination_class: ::core::option::Option<::prost::alloc::string::String>,
        /// Level of filtering in the requested incident. See |Destination| in
        /// frameworks/base/core/proto/android/privacy.proto.
        #[prost(int32, optional, tag = "3")]
        pub privacy_level: ::core::option::Option<i32>,
        /// If true, then skips saving the trace to incidentd.
        ///
        /// This flag is useful in testing (e.g. Perfetto-statsd integration tests)
        /// or when we explicitly don't want traces to go to incidentd even when they
        /// usually would (e.g. configs deployed using statsd but only used for
        /// inclusion in bugreports using |bugreport_score|).
        ///
        /// The motivation for having this flag, instead of just not setting
        /// |incident_report_config|, is prevent accidents where
        /// |incident_report_config| is omitted by mistake.
        #[prost(bool, optional, tag = "5")]
        pub skip_incidentd: ::core::option::Option<bool>,
        /// If true, do not write the trace into dropbox (i.e. incident only).
        /// Otherwise, write to both dropbox and incident.
        /// TODO(lalitm): remove this field as we no longer use Dropbox.
        #[deprecated]
        #[prost(bool, optional, tag = "4")]
        pub skip_dropbox: ::core::option::Option<bool>,
    }
    /// When set applies a post-filter to the trace contents using the filter
    /// provided. The filter is applied at ReadBuffers() time and works both in the
    /// case of IPC readback and write_into_file. This filter can be generated
    /// using `tools/proto_filter -s schema.proto -F filter_out.bytes` or
    /// `-T filter_out.escaped_string` (for .pbtx). See go/trace-filtering for
    /// design.
    ///
    /// Introduced in Android S, but it was broken (b/195065199). Reintroduced in
    /// Android T with a different field number. Updated in Android U with a new
    /// bytecode version which supports string filtering.
    ///
    /// =========================
    /// Filter bytecode.
    /// =========================
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TraceFilter {
        /// The bytecode as implemented in Android T.
        #[prost(bytes = "vec", optional, tag = "1")]
        pub bytecode: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// The bytecode as implemented in Android U. Adds support for string
        /// filtering.
        #[prost(bytes = "vec", optional, tag = "2")]
        pub bytecode_v2: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(message, optional, tag = "3")]
        pub string_filter_chain: ::core::option::Option<trace_filter::StringFilterChain>,
    }
    /// Nested message and enum types in `TraceFilter`.
    pub mod trace_filter {
        /// A rule specifies how strings should be filtered.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct StringFilterRule {
            /// The policy (i.e. algorithm) dictating how strings matching this rule
            /// should be handled.
            #[prost(enumeration = "StringFilterPolicy", optional, tag = "1")]
            pub policy: ::core::option::Option<i32>,
            /// The regex pattern used to match against each string.
            #[prost(string, optional, tag = "2")]
            pub regex_pattern: ::core::option::Option<::prost::alloc::string::String>,
            /// The string which should appear after the tgid in atrace tracepoint
            /// strings.
            #[prost(string, optional, tag = "3")]
            pub atrace_payload_starts_with: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
        }
        /// A chain is a list of rules which string will be sequentially checked
        /// against.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct StringFilterChain {
            #[prost(message, repeated, tag = "1")]
            pub rules: ::prost::alloc::vec::Vec<StringFilterRule>,
        }
        /// A policy specifies which algorithm should be used for filtering the
        /// string.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum StringFilterPolicy {
            SfpUnspecified = 0,
            /// Tries to match the string field against |regex_pattern|. If it
            /// matches, all matching groups are "redacted" (i.e. replaced with a
            /// constant string) and filtering is terminated (i.e. no further rules are
            /// checked). If it doesn't match, the string is left unchanged and the
            /// next rule in chain is considered.
            SfpMatchRedactGroups = 1,
            /// Like |SFP_MATCH_REDACT_GROUPS| but tries to do some pre-work before
            /// checking the regex. Specifically, it tries to parse the string field as
            /// an atrace tracepoint and checks if the post-tgid field starts with
            /// |atrace_post_tgid_starts_with|. The regex matching is only performed if
            /// this check succeeds.
            SfpAtraceMatchRedactGroups = 2,
            /// Tries to match the string field against |regex_pattern|. If it
            /// matches, filtering is terminated (i.e. no further rules are checked).
            /// If it doesn't match, the string is left unchanged and the next rule in
            /// chain is considered.
            SfpMatchBreak = 3,
            /// Like |SFP_MATCH_BREAK| but tries to do some pre-work before checking
            /// the regex. Specifically, it tries to parse the string field as an
            /// atrace tracepoint and checks if the post-tgid field starts with
            /// |atrace_post_tgid_starts_with|. The regex matching is only performed if
            /// this check succeeds.
            SfpAtraceMatchBreak = 4,
            /// Tries to repeatedly search (i.e. find substrings of) the string field
            /// with |regex_pattern|. For each match, redacts any matching groups (i.e.
            /// replaced with a constant string). Once there are no further matches,
            /// filtering is terminated (i.e. no further rules are checked).
            ///
            /// Note that this is policy is a "search" policy not a "match" policy
            /// unlike the above policies:
            ///   * Match policies require matching the full string i.e. there is an
            ///     implicit leading `^` and trailing `$`.
            ///   * Search policies perform repeated partial matching of the string
            ///     e.g.
            ///       - String: `foo=aaa,bar=123,foo=bbb,baz=456`
            ///       - Pattern: `foo=(\d+)`
            ///       - Output: `foo=P6O,bar=123,foo=P6O,baz=456`
            ///     where P6O is the redaction string
            ///
            /// All of this is only performed after some pre-work where we try to parse
            /// the string field as an atrace tracepoint and check if the post-tgid
            /// field starts with |atrace_post_tgid_starts_with|.
            ///
            /// If there are no partial matches, the string is left unchanged and the
            /// next rule in chain is considered.
            SfpAtraceRepeatedSearchRedactGroups = 5,
        }
        impl StringFilterPolicy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::SfpUnspecified => "SFP_UNSPECIFIED",
                    Self::SfpMatchRedactGroups => "SFP_MATCH_REDACT_GROUPS",
                    Self::SfpAtraceMatchRedactGroups => "SFP_ATRACE_MATCH_REDACT_GROUPS",
                    Self::SfpMatchBreak => "SFP_MATCH_BREAK",
                    Self::SfpAtraceMatchBreak => "SFP_ATRACE_MATCH_BREAK",
                    Self::SfpAtraceRepeatedSearchRedactGroups => {
                        "SFP_ATRACE_REPEATED_SEARCH_REDACT_GROUPS"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SFP_UNSPECIFIED" => Some(Self::SfpUnspecified),
                    "SFP_MATCH_REDACT_GROUPS" => Some(Self::SfpMatchRedactGroups),
                    "SFP_ATRACE_MATCH_REDACT_GROUPS" => {
                        Some(Self::SfpAtraceMatchRedactGroups)
                    }
                    "SFP_MATCH_BREAK" => Some(Self::SfpMatchBreak),
                    "SFP_ATRACE_MATCH_BREAK" => Some(Self::SfpAtraceMatchBreak),
                    "SFP_ATRACE_REPEATED_SEARCH_REDACT_GROUPS" => {
                        Some(Self::SfpAtraceRepeatedSearchRedactGroups)
                    }
                    _ => None,
                }
            }
        }
    }
    /// Android-only. Not for general use. If set, reports the trace to the
    /// Android framework. This field is read by perfetto_cmd, rather than the
    /// tracing service. This field must be set when passing the --upload flag to
    /// perfetto_cmd.
    ///
    /// In this message, either:
    ///   * |reporter_service_package| and |reporter_service_class| must be set.
    ///   * |skip_reporting| must be explicitly set to true.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AndroidReportConfig {
        #[prost(string, optional, tag = "1")]
        pub reporter_service_package: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(string, optional, tag = "2")]
        pub reporter_service_class: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        /// If true, then skips reporting the trace to Android framework.
        ///
        /// This flag is useful in testing (e.g. Perfetto-statsd integration tests)
        /// or when we explicitly don't want to report traces to the framework even
        /// when they usually would (e.g. configs deployed using statsd but only
        /// used for inclusion in bugreports using |bugreport_score|).
        ///
        /// The motivation for having this flag, instead of just not setting
        /// |framework_report_config|, is prevent accidents where
        /// |framework_report_config| is omitted by mistake.
        #[prost(bool, optional, tag = "3")]
        pub skip_report: ::core::option::Option<bool>,
        /// If true, will direct the Android framework to read the data in trace
        /// file and pass it to the reporter class over a pipe instead of passing
        /// the file descriptor directly.
        ///
        /// This flag is needed because the Android test framework does not
        /// currently support priv-app helper apps (in terms of SELinux) and we
        /// really don't want to add an allow rule for untrusted_app to receive
        /// trace fds.
        ///
        /// Because of this, we instead will direct the framework to create a new
        /// pipe and pass this to the reporter process instead. As the pipe is
        /// created by the framework, we won't have any problems with SELinux
        /// (system_server is already allowed to pass pipe fds, even
        /// to untrusted apps).
        ///
        /// As the name suggests this option *MUST* only be used for testing.
        /// Note that the framework will reject (and drop) files which are too
        /// large both for simplicity and to be minimize the amount of data we
        /// pass to a non-priv app (note that the framework will still check
        /// manifest permissions even though SELinux permissions are worked around).
        #[prost(bool, optional, tag = "4")]
        pub use_pipe_in_framework_for_testing: ::core::option::Option<bool>,
    }
    /// If set, delays the start of tracing by a random duration. The duration is
    /// chosen from a uniform distribution between the specified minimum and
    /// maximum.
    /// Note: this delay is implemented by perfetto_cmd *not* by traced so will
    /// not work if you communicate with traced directly over the consumer API.
    /// Introduced in Android T.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CmdTraceStartDelay {
        #[prost(uint32, optional, tag = "1")]
        pub min_delay_ms: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub max_delay_ms: ::core::option::Option<u32>,
    }
    /// When non-empty, ensures that for a each semaphore named `name at most
    /// `max_other_session_count`` *other* sessions (whose value is taken of the
    /// minimum of all values specified by this config or any already-running
    /// session) can be be running.
    ///
    /// If a semaphore "acquisition" fails, EnableTracing will return an error
    /// and the tracing session will not be started (or elgible to start in
    /// the case of deferred sessions).
    ///
    /// This is easiest to explain with an example. Suppose the tracing service has
    /// the following active tracing sessions:
    ///    S1 = [{name=foo, max_other_session_count=2},
    ///          {name=bar, max_other_session_count=0}]
    ///    S2 = [{name=foo, max_other_session_count=1},
    ///          {name=baz, max_other_session_count=1}]
    ///
    /// Then, for a new session, the following would be the expected behaviour of
    /// EnableSession given the state of `session_semaphores`.
    ///    Q: session_semaphores = \[\]
    ///    A: Allowed because it does not specify any semaphores. Will be allowed
    ///       no matter the state of any other tracing session.
    ///    Q: session_semaphores = \[{name=baz, max_other_session_count=1}\]
    ///    A: Allowed because both S2 and this config specify
    ///       max_other_session_count=1 for baz.
    ///    Q: session_semaphores = \[{name=foo, max_other_session_count=3}\]
    ///    A: Denied because S2 specified max_other_session_count=1 for foo and S1
    ///       takes that slot.
    ///    Q: session_semaphores = \[{name=bar, max_other_session_count=0}\]
    ///    A: Denied because S1 takes the the slot specified by both S1 and
    ///       this config.
    ///
    /// Introduced in 24Q3 (Android V).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionSemaphore {
        /// The name of the semaphore. Acts as a unique identifier across all
        /// tracing sessions (including the one being started).
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// The maximum number of *other* sesssions which specify the same semaphore
        /// which can be active. The minimum of this value across all tracing
        /// sessions and the value specified by the config is used when deciding
        /// whether the tracing session can be started.
        #[prost(uint64, optional, tag = "2")]
        pub max_other_session_count: ::core::option::Option<u64>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LockdownModeOperation {
        LockdownUnchanged = 0,
        LockdownClear = 1,
        LockdownSet = 2,
    }
    impl LockdownModeOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LockdownUnchanged => "LOCKDOWN_UNCHANGED",
                Self::LockdownClear => "LOCKDOWN_CLEAR",
                Self::LockdownSet => "LOCKDOWN_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCKDOWN_UNCHANGED" => Some(Self::LockdownUnchanged),
                "LOCKDOWN_CLEAR" => Some(Self::LockdownClear),
                "LOCKDOWN_SET" => Some(Self::LockdownSet),
                _ => None,
            }
        }
    }
    /// Compress trace with the given method. Best effort.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompressionType {
        Unspecified = 0,
        Deflate = 1,
    }
    impl CompressionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPRESSION_TYPE_UNSPECIFIED",
                Self::Deflate => "COMPRESSION_TYPE_DEFLATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPRESSION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPRESSION_TYPE_DEFLATE" => Some(Self::Deflate),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StatsdLogging {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
    }
    impl StatsdLogging {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATSD_LOGGING_UNSPECIFIED",
                Self::Enabled => "STATSD_LOGGING_ENABLED",
                Self::Disabled => "STATSD_LOGGING_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATSD_LOGGING_UNSPECIFIED" => Some(Self::Unspecified),
                "STATSD_LOGGING_ENABLED" => Some(Self::Enabled),
                "STATSD_LOGGING_DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// The protocol compiler can output a FileDescriptorSet containing the .proto
/// files it parses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDescriptorSet {
    #[prost(message, repeated, tag = "1")]
    pub file: ::prost::alloc::vec::Vec<FileDescriptorProto>,
}
/// Describes a complete .proto file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDescriptorProto {
    /// file name, relative to root of source tree
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// e.g. "foo", "foo.bar", etc.
    #[prost(string, optional, tag = "2")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// Names of files imported by this file.
    #[prost(string, repeated, tag = "3")]
    pub dependency: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indexes of the public imported files in the dependency list above.
    #[prost(int32, repeated, packed = "false", tag = "10")]
    pub public_dependency: ::prost::alloc::vec::Vec<i32>,
    /// Indexes of the weak imported files in the dependency list.
    /// For Google-internal migration only. Do not use.
    #[prost(int32, repeated, packed = "false", tag = "11")]
    pub weak_dependency: ::prost::alloc::vec::Vec<i32>,
    /// All top-level definitions in this file.
    #[prost(message, repeated, tag = "4")]
    pub message_type: ::prost::alloc::vec::Vec<DescriptorProto>,
    #[prost(message, repeated, tag = "5")]
    pub enum_type: ::prost::alloc::vec::Vec<EnumDescriptorProto>,
    #[prost(message, repeated, tag = "7")]
    pub extension: ::prost::alloc::vec::Vec<FieldDescriptorProto>,
}
/// Describes a message type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub field: ::prost::alloc::vec::Vec<FieldDescriptorProto>,
    #[prost(message, repeated, tag = "6")]
    pub extension: ::prost::alloc::vec::Vec<FieldDescriptorProto>,
    #[prost(message, repeated, tag = "3")]
    pub nested_type: ::prost::alloc::vec::Vec<DescriptorProto>,
    #[prost(message, repeated, tag = "4")]
    pub enum_type: ::prost::alloc::vec::Vec<EnumDescriptorProto>,
    #[prost(message, repeated, tag = "8")]
    pub oneof_decl: ::prost::alloc::vec::Vec<OneofDescriptorProto>,
    #[prost(message, repeated, tag = "9")]
    pub reserved_range: ::prost::alloc::vec::Vec<descriptor_proto::ReservedRange>,
    /// Reserved field names, which may not be used by fields in the same message.
    /// A given name may only be reserved once.
    #[prost(string, repeated, tag = "10")]
    pub reserved_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DescriptorProto`.
pub mod descriptor_proto {
    /// Range of reserved tag numbers. Reserved tag numbers may not be used by
    /// fields or extension ranges in the same message. Reserved ranges may
    /// not overlap.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReservedRange {
        /// Inclusive.
        #[prost(int32, optional, tag = "1")]
        pub start: ::core::option::Option<i32>,
        /// Exclusive.
        #[prost(int32, optional, tag = "2")]
        pub end: ::core::option::Option<i32>,
    }
}
/// A message representing a option the parser does not recognize. This only
/// appears in options protos created by the compiler::Parser class.
/// DescriptorPool resolves these when building Descriptor objects. Therefore,
/// options protos in descriptor objects (e.g. returned by Descriptor::options(),
/// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
/// in them.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UninterpretedOption {
    #[prost(message, repeated, tag = "2")]
    pub name: ::prost::alloc::vec::Vec<uninterpreted_option::NamePart>,
    /// The value of the uninterpreted option, in whatever type the tokenizer
    /// identified it as during parsing. Exactly one of these should be set.
    #[prost(string, optional, tag = "3")]
    pub identifier_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub positive_int_value: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "5")]
    pub negative_int_value: ::core::option::Option<i64>,
    #[prost(double, optional, tag = "6")]
    pub double_value: ::core::option::Option<f64>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub string_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "8")]
    pub aggregate_value: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UninterpretedOption`.
pub mod uninterpreted_option {
    /// The name of the uninterpreted option.  Each string represents a segment in
    /// a dot-separated name.  is_extension is true iff a segment represents an
    /// extension (denoted with parentheses in options specs in .proto files).
    /// E.g.,{ \["foo", false\], \["bar.baz", true\], \["moo", false\] } represents
    /// "foo.(bar.baz).moo".
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NamePart {
        #[prost(string, optional, tag = "1")]
        pub name_part: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "2")]
        pub is_extension: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldOptions {
    /// The packed option can be enabled for repeated primitive fields to enable
    /// a more efficient representation on the wire. Rather than repeatedly
    /// writing the tag and type for each element, the entire array is encoded as
    /// a single length-delimited blob. In proto3, only explicit setting it to
    /// false will avoid using packed encoding.
    #[prost(bool, optional, tag = "2")]
    pub packed: ::core::option::Option<bool>,
    /// The parser stores options it doesn't recognize here. See above.
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
/// Describes a field within a message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub number: ::core::option::Option<i32>,
    #[prost(enumeration = "field_descriptor_proto::Label", optional, tag = "4")]
    pub label: ::core::option::Option<i32>,
    /// If type_name is set, this need not be set.  If both this and type_name
    /// are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
    #[prost(enumeration = "field_descriptor_proto::Type", optional, tag = "5")]
    pub r#type: ::core::option::Option<i32>,
    /// For message and enum types, this is the name of the type.  If the name
    /// starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    /// rules are used to find the type (i.e. first the nested types within this
    /// message are searched, then within the parent, on up to the root
    /// namespace).
    #[prost(string, optional, tag = "6")]
    pub type_name: ::core::option::Option<::prost::alloc::string::String>,
    /// For extensions, this is the name of the type being extended.  It is
    /// resolved in the same manner as type_name.
    #[prost(string, optional, tag = "2")]
    pub extendee: ::core::option::Option<::prost::alloc::string::String>,
    /// For numeric types, contains the original text representation of the value.
    /// For booleans, "true" or "false".
    /// For strings, contains the default text contents (not escaped in any way).
    /// For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    /// TODO(kenton):  Base-64 encode?
    #[prost(string, optional, tag = "7")]
    pub default_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub options: ::core::option::Option<FieldOptions>,
    /// If set, gives the index of a oneof in the containing type's oneof_decl
    /// list.  This field is a member of that oneof.
    #[prost(int32, optional, tag = "9")]
    pub oneof_index: ::core::option::Option<i32>,
}
/// Nested message and enum types in `FieldDescriptorProto`.
pub mod field_descriptor_proto {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// 0 is reserved for errors.
        /// Order is weird for historical reasons.
        Double = 1,
        Float = 2,
        /// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
        /// negative values are likely.
        Int64 = 3,
        Uint64 = 4,
        /// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
        /// negative values are likely.
        Int32 = 5,
        Fixed64 = 6,
        Fixed32 = 7,
        Bool = 8,
        String = 9,
        /// Tag-delimited aggregate.
        /// Group type is deprecated and not supported in proto3. However, Proto3
        /// implementations should still be able to parse the group wire format and
        /// treat group fields as unknown fields.
        Group = 10,
        /// Length-delimited aggregate.
        Message = 11,
        /// New in version 2.
        Bytes = 12,
        Uint32 = 13,
        Enum = 14,
        Sfixed32 = 15,
        Sfixed64 = 16,
        /// Uses ZigZag encoding.
        Sint32 = 17,
        /// Uses ZigZag encoding.
        Sint64 = 18,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Double => "TYPE_DOUBLE",
                Self::Float => "TYPE_FLOAT",
                Self::Int64 => "TYPE_INT64",
                Self::Uint64 => "TYPE_UINT64",
                Self::Int32 => "TYPE_INT32",
                Self::Fixed64 => "TYPE_FIXED64",
                Self::Fixed32 => "TYPE_FIXED32",
                Self::Bool => "TYPE_BOOL",
                Self::String => "TYPE_STRING",
                Self::Group => "TYPE_GROUP",
                Self::Message => "TYPE_MESSAGE",
                Self::Bytes => "TYPE_BYTES",
                Self::Uint32 => "TYPE_UINT32",
                Self::Enum => "TYPE_ENUM",
                Self::Sfixed32 => "TYPE_SFIXED32",
                Self::Sfixed64 => "TYPE_SFIXED64",
                Self::Sint32 => "TYPE_SINT32",
                Self::Sint64 => "TYPE_SINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_DOUBLE" => Some(Self::Double),
                "TYPE_FLOAT" => Some(Self::Float),
                "TYPE_INT64" => Some(Self::Int64),
                "TYPE_UINT64" => Some(Self::Uint64),
                "TYPE_INT32" => Some(Self::Int32),
                "TYPE_FIXED64" => Some(Self::Fixed64),
                "TYPE_FIXED32" => Some(Self::Fixed32),
                "TYPE_BOOL" => Some(Self::Bool),
                "TYPE_STRING" => Some(Self::String),
                "TYPE_GROUP" => Some(Self::Group),
                "TYPE_MESSAGE" => Some(Self::Message),
                "TYPE_BYTES" => Some(Self::Bytes),
                "TYPE_UINT32" => Some(Self::Uint32),
                "TYPE_ENUM" => Some(Self::Enum),
                "TYPE_SFIXED32" => Some(Self::Sfixed32),
                "TYPE_SFIXED64" => Some(Self::Sfixed64),
                "TYPE_SINT32" => Some(Self::Sint32),
                "TYPE_SINT64" => Some(Self::Sint64),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Label {
        /// 0 is reserved for errors
        Optional = 1,
        Required = 2,
        Repeated = 3,
    }
    impl Label {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Optional => "LABEL_OPTIONAL",
                Self::Required => "LABEL_REQUIRED",
                Self::Repeated => "LABEL_REPEATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LABEL_OPTIONAL" => Some(Self::Optional),
                "LABEL_REQUIRED" => Some(Self::Required),
                "LABEL_REPEATED" => Some(Self::Repeated),
                _ => None,
            }
        }
    }
}
/// Describes a oneof.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneofDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<OneofOptions>,
}
/// Describes an enum type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<EnumValueDescriptorProto>,
    /// Reserved enum value names, which may not be reused. A given name may only
    /// be reserved once.
    #[prost(string, repeated, tag = "5")]
    pub reserved_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Describes a value within an enum.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValueDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub number: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OneofOptions {}
/// This message contains descriptors used to parse extension fields of
/// TrackEvent.
///
/// See docs/design-docs/extensions.md for more details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtensionDescriptor {
    #[prost(message, optional, tag = "1")]
    pub extension_set: ::core::option::Option<FileDescriptorSet>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidGameInterventionList {
    #[prost(message, repeated, tag = "1")]
    pub game_packages: ::prost::alloc::vec::Vec<
        android_game_intervention_list::GamePackageInfo,
    >,
    /// True when at least one error occurred when parsing
    /// game_mode_intervention.list
    #[prost(bool, optional, tag = "2")]
    pub parse_error: ::core::option::Option<bool>,
    /// Failed to open / read game_mode_intervention.list
    #[prost(bool, optional, tag = "3")]
    pub read_error: ::core::option::Option<bool>,
}
/// Nested message and enum types in `AndroidGameInterventionList`.
pub mod android_game_intervention_list {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GameModeInfo {
        #[prost(uint32, optional, tag = "1")]
        pub mode: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "2")]
        pub use_angle: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "3")]
        pub resolution_downscale: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4")]
        pub fps: ::core::option::Option<f32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GamePackageInfo {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag = "2")]
        pub uid: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "3")]
        pub current_mode: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "4")]
        pub game_mode_info: ::prost::alloc::vec::Vec<GameModeInfo>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidLogPacket {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<android_log_packet::LogEvent>,
    #[prost(message, optional, tag = "2")]
    pub stats: ::core::option::Option<android_log_packet::Stats>,
}
/// Nested message and enum types in `AndroidLogPacket`.
pub mod android_log_packet {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LogEvent {
        /// The log buffer (e.g. MAIN, SYSTEM, RADIO) the event comes from.
        #[prost(enumeration = "super::AndroidLogId", optional, tag = "1")]
        pub log_id: ::core::option::Option<i32>,
        /// PID (TGID), TID and UID of the task that emitted the event.
        #[prost(int32, optional, tag = "2")]
        pub pid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub tid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub uid: ::core::option::Option<i32>,
        /// Timestamp \[ns\]. The clock source is CLOCK_REALTIME, unlike many other
        /// Perfetto trace events that instead use CLOCK_BOOTTIME. The trace
        /// processor will take care of realigning clocks using the ClockSnapshot(s).
        #[prost(uint64, optional, tag = "5")]
        pub timestamp: ::core::option::Option<u64>,
        /// When log_id == LID_EVENTS, |tag| corresponds to the event name defined in
        /// the second column of /system/etc/event-log-tags. For all other events,
        /// |tag| is the app-specified argument passed to __android_log_write().
        #[prost(string, optional, tag = "6")]
        pub tag: ::core::option::Option<::prost::alloc::string::String>,
        /// Empty when log_id == LID_EVENTS.
        #[prost(enumeration = "super::AndroidLogPriority", optional, tag = "7")]
        pub prio: ::core::option::Option<i32>,
        /// Empty when log_id == LID_EVENTS.
        #[prost(string, optional, tag = "8")]
        pub message: ::core::option::Option<::prost::alloc::string::String>,
        /// Only populated when log_id == LID_EVENTS.
        #[prost(message, repeated, tag = "9")]
        pub args: ::prost::alloc::vec::Vec<log_event::Arg>,
    }
    /// Nested message and enum types in `LogEvent`.
    pub mod log_event {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Arg {
            #[prost(string, optional, tag = "1")]
            pub name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(oneof = "arg::Value", tags = "2, 3, 4")]
            pub value: ::core::option::Option<arg::Value>,
        }
        /// Nested message and enum types in `Arg`.
        pub mod arg {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Value {
                #[prost(int64, tag = "2")]
                IntValue(i64),
                #[prost(float, tag = "3")]
                FloatValue(f32),
                #[prost(string, tag = "4")]
                StringValue(::prost::alloc::string::String),
            }
        }
    }
    /// Stats are emitted only upon Flush() and are monotonic (i.e. they are
    /// absolute counters since the beginning of the lifetime of the tracing
    /// session and NOT relative to the previous Stats snapshot).
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Stats {
        /// Total number of log events seen, including errors and skipped entries
        /// (num of events stored in the trace = total - failed - skipped).
        #[prost(uint64, optional, tag = "1")]
        pub num_total: ::core::option::Option<u64>,
        /// Parser failures.
        #[prost(uint64, optional, tag = "2")]
        pub num_failed: ::core::option::Option<u64>,
        /// Messages skipped due to filters.
        #[prost(uint64, optional, tag = "3")]
        pub num_skipped: ::core::option::Option<u64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidSystemProperty {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<android_system_property::PropertyValue>,
}
/// Nested message and enum types in `AndroidSystemProperty`.
pub mod android_system_property {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyValue {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
/// A profiling event corresponding to a single camera frame. This message
/// collects important details and timestamps involved in producing a single
/// camera frame.
/// Next ID: 17
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidCameraFrameEvent {
    /// Identifier for the CameraCaptureSession this frame originates from. See:
    /// <https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession>
    #[prost(uint64, optional, tag = "1")]
    pub session_id: ::core::option::Option<u64>,
    /// Identifier for the camera sensor that is the source of this frame. This may
    /// be either a physical or logical camera (up to vendor interpretation).
    #[prost(uint32, optional, tag = "2")]
    pub camera_id: ::core::option::Option<u32>,
    /// The frame number identifying this frame on this camera.
    #[prost(int64, optional, tag = "3")]
    pub frame_number: ::core::option::Option<i64>,
    /// Identifier for the CaptureRequest. See:
    /// <https://developer.android.com/reference/android/hardware/camera2/CaptureRequest>
    ///
    /// If multiple cameras are streaming simultaneously, the request_id may be
    /// used to identify which frames were captured in service of the same request.
    #[prost(int64, optional, tag = "4")]
    pub request_id: ::core::option::Option<i64>,
    /// The CLOCK_BOOTTIME timestamp at which the camera framework request is
    /// received by the camera HAL pipeline. Note that this request may wait for
    /// some time before processing actually begins. See also
    /// request_processing_started_ns.
    #[prost(int64, optional, tag = "5")]
    pub request_received_ns: ::core::option::Option<i64>,
    /// The CLOCK_BOOTTIME timestamp at which the framework request is accepted for
    /// processing by the camera HAL pipeline. This is the time at which the
    /// pipeline actually begins to work on the request.
    #[prost(int64, optional, tag = "6")]
    pub request_processing_started_ns: ::core::option::Option<i64>,
    /// The CLOCK_BOOTTIME timestamp at which the sensor begins its exposure.
    #[prost(int64, optional, tag = "7")]
    pub start_of_exposure_ns: ::core::option::Option<i64>,
    /// The CLOCK_BOOTTIME timestamp corresponding to the sensor start of frame
    /// event.
    #[prost(int64, optional, tag = "8")]
    pub start_of_frame_ns: ::core::option::Option<i64>,
    /// The CLOCK_BOOTTIME timestamp at which the camera HAL has sent all responses
    /// for the frame.
    #[prost(int64, optional, tag = "9")]
    pub responses_all_sent_ns: ::core::option::Option<i64>,
    #[prost(
        enumeration = "android_camera_frame_event::CaptureResultStatus",
        optional,
        tag = "10"
    )]
    pub capture_result_status: ::core::option::Option<i32>,
    /// The number of sensor frames that were skipped between this frame and the
    /// previous frame. Under normal operation, this should be zero. Any number
    /// greater than zero indicates dropped sensor frames.
    #[prost(int32, optional, tag = "11")]
    pub skipped_sensor_frames: ::core::option::Option<i32>,
    /// The value of CONTROL_CAPTURE_INTENT. See:
    /// <https://developer.android.com/reference/android/hardware/camera2/CaptureRequest#CONTROL_CAPTURE_INTENT>
    #[prost(int32, optional, tag = "12")]
    pub capture_intent: ::core::option::Option<i32>,
    /// The number of streams in the capture request.
    #[prost(int32, optional, tag = "13")]
    pub num_streams: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "14")]
    pub node_processing_details: ::prost::alloc::vec::Vec<
        android_camera_frame_event::CameraNodeProcessingDetails,
    >,
    /// These fields capture vendor-specific additions to this proto message. In
    /// practice `vendor_data` typically contains a serialized message of the
    /// vendor's design, and `vendor_data_version` is incremented each time there
    /// is a backwards incompatible change made to the message.
    #[prost(int32, optional, tag = "15")]
    pub vendor_data_version: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "16")]
    pub vendor_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `AndroidCameraFrameEvent`.
pub mod android_camera_frame_event {
    /// A profiling event corresponding to a single node processing within the camera
    /// pipeline. Intuitively this corresponds to a single stage of processing to
    /// produce a camera frame.
    /// Next ID: 6
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CameraNodeProcessingDetails {
        #[prost(int64, optional, tag = "1")]
        pub node_id: ::core::option::Option<i64>,
        /// The timestamp at which node processing begins to run.
        #[prost(int64, optional, tag = "2")]
        pub start_processing_ns: ::core::option::Option<i64>,
        /// The timestamp at which node processing finishes running.
        #[prost(int64, optional, tag = "3")]
        pub end_processing_ns: ::core::option::Option<i64>,
        /// The delay between inputs becoming ready and the node actually beginning to
        /// run.
        #[prost(int64, optional, tag = "4")]
        pub scheduling_latency_ns: ::core::option::Option<i64>,
    }
    /// The error status, if any, reported to the camera framework. Any status
    /// other than STATUS_OK indicates a dropped frame.
    /// Next Enum: 6
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CaptureResultStatus {
        StatusUnspecified = 0,
        StatusOk = 1,
        /// Early metadata was returned to the camera framework with an error.
        StatusEarlyMetadataError = 2,
        /// Final metadata was returned to the camera framework with an error.
        StatusFinalMetadataError = 3,
        /// One or more buffers were returned to the camera framework with an error.
        StatusBufferError = 4,
        /// The frame was dropped as a result of a flush operation.
        StatusFlushError = 5,
    }
    impl CaptureResultStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StatusUnspecified => "STATUS_UNSPECIFIED",
                Self::StatusOk => "STATUS_OK",
                Self::StatusEarlyMetadataError => "STATUS_EARLY_METADATA_ERROR",
                Self::StatusFinalMetadataError => "STATUS_FINAL_METADATA_ERROR",
                Self::StatusBufferError => "STATUS_BUFFER_ERROR",
                Self::StatusFlushError => "STATUS_FLUSH_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::StatusUnspecified),
                "STATUS_OK" => Some(Self::StatusOk),
                "STATUS_EARLY_METADATA_ERROR" => Some(Self::StatusEarlyMetadataError),
                "STATUS_FINAL_METADATA_ERROR" => Some(Self::StatusFinalMetadataError),
                "STATUS_BUFFER_ERROR" => Some(Self::StatusBufferError),
                "STATUS_FLUSH_ERROR" => Some(Self::StatusFlushError),
                _ => None,
            }
        }
    }
}
/// A profiling event that may be emitted periodically (i.e., at a slower rate
/// than `AndroidCameraFrameEvent`s) to record fixed and aggregated camera
/// session-specific values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidCameraSessionStats {
    /// Identifier for the CameraCaptureSession this frame originates from. See:
    /// <https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession>
    #[prost(uint64, optional, tag = "1")]
    pub session_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub graph: ::core::option::Option<android_camera_session_stats::CameraGraph>,
}
/// Nested message and enum types in `AndroidCameraSessionStats`.
pub mod android_camera_session_stats {
    /// Although vendor implementations may vary, camera pipeline processing is
    /// typically arranged into a directed graph-like structure. This message is
    /// used to record that graph.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CameraGraph {
        #[prost(message, repeated, tag = "1")]
        pub nodes: ::prost::alloc::vec::Vec<camera_graph::CameraNode>,
        #[prost(message, repeated, tag = "2")]
        pub edges: ::prost::alloc::vec::Vec<camera_graph::CameraEdge>,
    }
    /// Nested message and enum types in `CameraGraph`.
    pub mod camera_graph {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CameraNode {
            #[prost(int64, optional, tag = "1")]
            pub node_id: ::core::option::Option<i64>,
            /// A list of inputs consumed by this node.
            #[prost(int64, repeated, packed = "false", tag = "2")]
            pub input_ids: ::prost::alloc::vec::Vec<i64>,
            /// A list of outputs produced by this node.
            #[prost(int64, repeated, packed = "false", tag = "3")]
            pub output_ids: ::prost::alloc::vec::Vec<i64>,
            /// These fields capture vendor-specific additions to this proto message. In
            /// practice `vendor_data` typically contains a serialized message of the
            /// vendor's design, and `vendor_data_version` is incremented each time there
            /// is a backwards incompatible change made to the message.
            #[prost(int32, optional, tag = "4")]
            pub vendor_data_version: ::core::option::Option<i32>,
            #[prost(bytes = "vec", optional, tag = "5")]
            pub vendor_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
        /// An adjacency list describing connections between CameraNodes, mapping
        /// nodes and their outputs to other nodes that consume them as inputs.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CameraEdge {
            /// The pair of IDs identifying the node and output connected by this edge.
            #[prost(int64, optional, tag = "1")]
            pub output_node_id: ::core::option::Option<i64>,
            #[prost(int64, optional, tag = "2")]
            pub output_id: ::core::option::Option<i64>,
            /// The pair of IDs identifying the node and input connected by this edge.
            #[prost(int64, optional, tag = "3")]
            pub input_node_id: ::core::option::Option<i64>,
            #[prost(int64, optional, tag = "4")]
            pub input_id: ::core::option::Option<i64>,
            /// These fields capture vendor-specific additions to this proto message. In
            /// practice `vendor_data` typically contains a serialized message of the
            /// vendor's design, and `vendor_data_version` is incremented each time there
            /// is a backwards incompatible change made to the message.
            #[prost(int32, optional, tag = "5")]
            pub vendor_data_version: ::core::option::Option<i32>,
            #[prost(bytes = "vec", optional, tag = "6")]
            pub vendor_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        }
    }
}
/// Generated by SurfaceFlinger's FrameTimeline (go/adaptive-scheduling-fr).
/// Used in comparing the expected timeline of a frame to the actual timeline.
/// Key terms:
///     1) DisplayFrame - represents SurfaceFlinger's work on a frame(composited)
///     2) SurfaceFrame - represents App's work on its frame
///     3) Timeline = start to end of a component's(app/SF) work on a frame.
/// SurfaceFlinger composites frames from many apps together, so
///     One DisplayFrame can map to N SurfaceFrame(s)
/// This relationship can be reconstructed by using
///     DisplayFrame.token = SurfaceFrame.display_frame_token
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameTimelineEvent {
    #[prost(oneof = "frame_timeline_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<frame_timeline_event::Event>,
}
/// Nested message and enum types in `FrameTimelineEvent`.
pub mod frame_timeline_event {
    /// Indicates the start of expected timeline slice for SurfaceFrames.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExpectedSurfaceFrameStart {
        /// Cookie used to correlate between the start and end messages of the same
        /// frame. Since all values except the ts are same for start and end, cookie
        /// helps in preventing redundant data transmission.
        /// The same cookie is used only by start and end messages of a single frame
        /// and is otherwise unique.
        #[prost(int64, optional, tag = "1")]
        pub cookie: ::core::option::Option<i64>,
        /// Token received by the app for its work. Can be shared between multiple
        /// layers of the same app (example: pip mode).
        #[prost(int64, optional, tag = "2")]
        pub token: ::core::option::Option<i64>,
        /// The corresponding DisplayFrame token is required to link the App's work
        /// with SurfaceFlinger's work. Many SurfaceFrames can be mapped to a single
        /// DisplayFrame.
        /// this.display_frame_token = DisplayFrame.token
        #[prost(int64, optional, tag = "3")]
        pub display_frame_token: ::core::option::Option<i64>,
        /// Pid of the app. Used in creating the timeline tracks (and slices) inside
        /// the respective process track group.
        #[prost(int32, optional, tag = "4")]
        pub pid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "5")]
        pub layer_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Indicates the start of actual timeline slice for SurfaceFrames. Also
    /// includes the jank information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActualSurfaceFrameStart {
        /// Cookie used to correlate between the start and end messages of the same
        /// frame. Since all values except the ts are same for start and end, cookie
        /// helps in preventing redundant data transmission.
        /// The same cookie is used only by start and end messages of a single frame
        /// and is otherwise unique.
        #[prost(int64, optional, tag = "1")]
        pub cookie: ::core::option::Option<i64>,
        /// Token received by the app for its work. Can be shared between multiple
        /// layers of the same app (example: pip mode).
        #[prost(int64, optional, tag = "2")]
        pub token: ::core::option::Option<i64>,
        /// The corresponding DisplayFrame token is required to link the App's work
        /// with SurfaceFlinger's work. Many SurfaceFrames can be mapped to a single
        /// DisplayFrame.
        /// this.display_frame_token = DisplayFrame.token
        #[prost(int64, optional, tag = "3")]
        pub display_frame_token: ::core::option::Option<i64>,
        /// Pid of the app. Used in creating the timeline tracks (and slices) inside
        /// the respective process track group.
        #[prost(int32, optional, tag = "4")]
        pub pid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "5")]
        pub layer_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration = "PresentType", optional, tag = "6")]
        pub present_type: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub on_time_finish: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "8")]
        pub gpu_composition: ::core::option::Option<bool>,
        /// A bitmask of JankType. More than one reason can be attributed to a janky
        /// frame.
        #[prost(int32, optional, tag = "9")]
        pub jank_type: ::core::option::Option<i32>,
        #[prost(enumeration = "PredictionType", optional, tag = "10")]
        pub prediction_type: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "11")]
        pub is_buffer: ::core::option::Option<bool>,
        #[prost(enumeration = "JankSeverityType", optional, tag = "12")]
        pub jank_severity_type: ::core::option::Option<i32>,
    }
    /// Indicates the start of expected timeline slice for DisplayFrames.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExpectedDisplayFrameStart {
        /// Cookie used to correlate between the start and end messages of the same
        /// frame. Since all values except the ts are same for start and end, cookie
        /// helps in preventing redundant data transmission.
        /// The same cookie is used only by start and end messages of a single frame
        /// and is otherwise unique.
        #[prost(int64, optional, tag = "1")]
        pub cookie: ::core::option::Option<i64>,
        /// Token received by SurfaceFlinger for its work
        /// this.token = SurfaceFrame.display_frame_token
        #[prost(int64, optional, tag = "2")]
        pub token: ::core::option::Option<i64>,
        /// Pid of SurfaceFlinger. Used in creating the timeline tracks (and slices)
        /// inside the SurfaceFlinger process group.
        #[prost(int32, optional, tag = "3")]
        pub pid: ::core::option::Option<i32>,
    }
    /// Indicates the start of actual timeline slice for DisplayFrames. Also
    /// includes the jank information.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ActualDisplayFrameStart {
        /// Cookie used to correlate between the start and end messages of the same
        /// frame. Since all values except the ts are same for start and end, cookie
        /// helps in preventing redundant data transmission.
        /// The same cookie is used only by start and end messages of a single frame
        /// and is otherwise unique.
        #[prost(int64, optional, tag = "1")]
        pub cookie: ::core::option::Option<i64>,
        /// Token received by SurfaceFlinger for its work
        /// this.token = SurfaceFrame.display_frame_token
        #[prost(int64, optional, tag = "2")]
        pub token: ::core::option::Option<i64>,
        /// Pid of SurfaceFlinger. Used in creating the timeline tracks (and slices)
        /// inside the SurfaceFlinger process group.
        #[prost(int32, optional, tag = "3")]
        pub pid: ::core::option::Option<i32>,
        #[prost(enumeration = "PresentType", optional, tag = "4")]
        pub present_type: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "5")]
        pub on_time_finish: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "6")]
        pub gpu_composition: ::core::option::Option<bool>,
        /// A bitmask of JankType. More than one reason can be attributed to a janky
        /// frame.
        #[prost(int32, optional, tag = "7")]
        pub jank_type: ::core::option::Option<i32>,
        #[prost(enumeration = "PredictionType", optional, tag = "8")]
        pub prediction_type: ::core::option::Option<i32>,
        #[prost(enumeration = "JankSeverityType", optional, tag = "9")]
        pub jank_severity_type: ::core::option::Option<i32>,
    }
    /// FrameEnd just sends the cookie to indicate that the corresponding
    /// <display/surface>frame slice's end.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FrameEnd {
        #[prost(int64, optional, tag = "1")]
        pub cookie: ::core::option::Option<i64>,
    }
    /// Specifies the reason(s) most likely to have caused the jank.
    /// Used as a bitmask.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JankType {
        JankUnspecified = 0,
        JankNone = 1,
        JankSfScheduling = 2,
        JankPredictionError = 4,
        JankDisplayHal = 8,
        JankSfCpuDeadlineMissed = 16,
        JankSfGpuDeadlineMissed = 32,
        JankAppDeadlineMissed = 64,
        JankBufferStuffing = 128,
        JankUnknown = 256,
        JankSfStuffing = 512,
        JankDropped = 1024,
    }
    impl JankType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::JankUnspecified => "JANK_UNSPECIFIED",
                Self::JankNone => "JANK_NONE",
                Self::JankSfScheduling => "JANK_SF_SCHEDULING",
                Self::JankPredictionError => "JANK_PREDICTION_ERROR",
                Self::JankDisplayHal => "JANK_DISPLAY_HAL",
                Self::JankSfCpuDeadlineMissed => "JANK_SF_CPU_DEADLINE_MISSED",
                Self::JankSfGpuDeadlineMissed => "JANK_SF_GPU_DEADLINE_MISSED",
                Self::JankAppDeadlineMissed => "JANK_APP_DEADLINE_MISSED",
                Self::JankBufferStuffing => "JANK_BUFFER_STUFFING",
                Self::JankUnknown => "JANK_UNKNOWN",
                Self::JankSfStuffing => "JANK_SF_STUFFING",
                Self::JankDropped => "JANK_DROPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JANK_UNSPECIFIED" => Some(Self::JankUnspecified),
                "JANK_NONE" => Some(Self::JankNone),
                "JANK_SF_SCHEDULING" => Some(Self::JankSfScheduling),
                "JANK_PREDICTION_ERROR" => Some(Self::JankPredictionError),
                "JANK_DISPLAY_HAL" => Some(Self::JankDisplayHal),
                "JANK_SF_CPU_DEADLINE_MISSED" => Some(Self::JankSfCpuDeadlineMissed),
                "JANK_SF_GPU_DEADLINE_MISSED" => Some(Self::JankSfGpuDeadlineMissed),
                "JANK_APP_DEADLINE_MISSED" => Some(Self::JankAppDeadlineMissed),
                "JANK_BUFFER_STUFFING" => Some(Self::JankBufferStuffing),
                "JANK_UNKNOWN" => Some(Self::JankUnknown),
                "JANK_SF_STUFFING" => Some(Self::JankSfStuffing),
                "JANK_DROPPED" => Some(Self::JankDropped),
                _ => None,
            }
        }
    }
    /// Specifies the severity of a jank.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JankSeverityType {
        SeverityUnknown = 0,
        SeverityNone = 1,
        SeverityPartial = 2,
        SeverityFull = 3,
    }
    impl JankSeverityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SeverityUnknown => "SEVERITY_UNKNOWN",
                Self::SeverityNone => "SEVERITY_NONE",
                Self::SeverityPartial => "SEVERITY_PARTIAL",
                Self::SeverityFull => "SEVERITY_FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNKNOWN" => Some(Self::SeverityUnknown),
                "SEVERITY_NONE" => Some(Self::SeverityNone),
                "SEVERITY_PARTIAL" => Some(Self::SeverityPartial),
                "SEVERITY_FULL" => Some(Self::SeverityFull),
                _ => None,
            }
        }
    }
    /// Specifies how a frame was presented on screen w.r.t. timing.
    /// Can be different for SurfaceFrame and DisplayFrame.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PresentType {
        PresentUnspecified = 0,
        PresentOnTime = 1,
        PresentLate = 2,
        PresentEarly = 3,
        PresentDropped = 4,
        PresentUnknown = 5,
    }
    impl PresentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PresentUnspecified => "PRESENT_UNSPECIFIED",
                Self::PresentOnTime => "PRESENT_ON_TIME",
                Self::PresentLate => "PRESENT_LATE",
                Self::PresentEarly => "PRESENT_EARLY",
                Self::PresentDropped => "PRESENT_DROPPED",
                Self::PresentUnknown => "PRESENT_UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRESENT_UNSPECIFIED" => Some(Self::PresentUnspecified),
                "PRESENT_ON_TIME" => Some(Self::PresentOnTime),
                "PRESENT_LATE" => Some(Self::PresentLate),
                "PRESENT_EARLY" => Some(Self::PresentEarly),
                "PRESENT_DROPPED" => Some(Self::PresentDropped),
                "PRESENT_UNKNOWN" => Some(Self::PresentUnknown),
                _ => None,
            }
        }
    }
    /// Specifies if the predictions for the frame are still valid, expired or
    /// unknown.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PredictionType {
        PredictionUnspecified = 0,
        PredictionValid = 1,
        PredictionExpired = 2,
        PredictionUnknown = 3,
    }
    impl PredictionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PredictionUnspecified => "PREDICTION_UNSPECIFIED",
                Self::PredictionValid => "PREDICTION_VALID",
                Self::PredictionExpired => "PREDICTION_EXPIRED",
                Self::PredictionUnknown => "PREDICTION_UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREDICTION_UNSPECIFIED" => Some(Self::PredictionUnspecified),
                "PREDICTION_VALID" => Some(Self::PredictionValid),
                "PREDICTION_EXPIRED" => Some(Self::PredictionExpired),
                "PREDICTION_UNKNOWN" => Some(Self::PredictionUnknown),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        ExpectedDisplayFrameStart(ExpectedDisplayFrameStart),
        #[prost(message, tag = "2")]
        ActualDisplayFrameStart(ActualDisplayFrameStart),
        #[prost(message, tag = "3")]
        ExpectedSurfaceFrameStart(ExpectedSurfaceFrameStart),
        #[prost(message, tag = "4")]
        ActualSurfaceFrameStart(ActualSurfaceFrameStart),
        #[prost(message, tag = "5")]
        FrameEnd(FrameEnd),
    }
}
/// Generated by Android's GpuService.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpuMemTotalEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gpu_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
}
/// Generated by Android's SurfaceFlinger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicsFrameEvent {
    #[prost(message, optional, tag = "1")]
    pub buffer_event: ::core::option::Option<graphics_frame_event::BufferEvent>,
}
/// Nested message and enum types in `GraphicsFrameEvent`.
pub mod graphics_frame_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BufferEvent {
        #[prost(uint32, optional, tag = "1")]
        pub frame_number: ::core::option::Option<u32>,
        #[prost(enumeration = "BufferEventType", optional, tag = "2")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "3")]
        pub layer_name: ::core::option::Option<::prost::alloc::string::String>,
        /// If no duration is set, the event is an instant event.
        #[prost(uint64, optional, tag = "4")]
        pub duration_ns: ::core::option::Option<u64>,
        /// Unique buffer identifier.
        #[prost(uint32, optional, tag = "5")]
        pub buffer_id: ::core::option::Option<u32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BufferEventType {
        Unspecified = 0,
        Dequeue = 1,
        Queue = 2,
        Post = 3,
        AcquireFence = 4,
        Latch = 5,
        /// HWC will compose this buffer
        HwcCompositionQueued = 6,
        /// renderEngine composition
        FallbackComposition = 7,
        PresentFence = 8,
        ReleaseFence = 9,
        Modify = 10,
        Detach = 11,
        Attach = 12,
        Cancel = 13,
    }
    impl BufferEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Dequeue => "DEQUEUE",
                Self::Queue => "QUEUE",
                Self::Post => "POST",
                Self::AcquireFence => "ACQUIRE_FENCE",
                Self::Latch => "LATCH",
                Self::HwcCompositionQueued => "HWC_COMPOSITION_QUEUED",
                Self::FallbackComposition => "FALLBACK_COMPOSITION",
                Self::PresentFence => "PRESENT_FENCE",
                Self::ReleaseFence => "RELEASE_FENCE",
                Self::Modify => "MODIFY",
                Self::Detach => "DETACH",
                Self::Attach => "ATTACH",
                Self::Cancel => "CANCEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "DEQUEUE" => Some(Self::Dequeue),
                "QUEUE" => Some(Self::Queue),
                "POST" => Some(Self::Post),
                "ACQUIRE_FENCE" => Some(Self::AcquireFence),
                "LATCH" => Some(Self::Latch),
                "HWC_COMPOSITION_QUEUED" => Some(Self::HwcCompositionQueued),
                "FALLBACK_COMPOSITION" => Some(Self::FallbackComposition),
                "PRESENT_FENCE" => Some(Self::PresentFence),
                "RELEASE_FENCE" => Some(Self::ReleaseFence),
                "MODIFY" => Some(Self::Modify),
                "DETACH" => Some(Self::Detach),
                "ATTACH" => Some(Self::Attach),
                "CANCEL" => Some(Self::Cancel),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InitialDisplayState {
    /// Same values as android.view.Display.STATE_*
    #[prost(int32, optional, tag = "1")]
    pub display_state: ::core::option::Option<i32>,
    #[prost(double, optional, tag = "2")]
    pub brightness: ::core::option::Option<f64>,
}
/// NetworkPacketEvent records the details of a single packet sent or received
/// on the network (in Linux kernel terminology, one sk_buff struct).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPacketEvent {
    /// The direction traffic is flowing for this event.
    #[prost(enumeration = "TrafficDirection", optional, tag = "1")]
    pub direction: ::core::option::Option<i32>,
    /// The name of the interface if available (e.g. 'rmnet0').
    #[prost(string, optional, tag = "2")]
    pub interface: ::core::option::Option<::prost::alloc::string::String>,
    /// The length of the packet in bytes (wire_size - L2_header_size). Ignored
    /// when using NetworkPacketEvent as the ctx in either NetworkPacketBundle or
    /// NetworkPacketContext.
    #[prost(uint32, optional, tag = "3")]
    pub length: ::core::option::Option<u32>,
    /// The Linux user id associated with the packet's socket.
    #[prost(uint32, optional, tag = "4")]
    pub uid: ::core::option::Option<u32>,
    /// The Android network tag associated with the packet's socket.
    #[prost(uint32, optional, tag = "5")]
    pub tag: ::core::option::Option<u32>,
    /// The packet's IP protocol (TCP=6, UDP=17, etc).
    #[prost(uint32, optional, tag = "6")]
    pub ip_proto: ::core::option::Option<u32>,
    /// The packet's TCP flags as a bitmask (FIN=0x1, SYN=0x2, RST=0x4, etc).
    #[prost(uint32, optional, tag = "7")]
    pub tcp_flags: ::core::option::Option<u32>,
    /// The local udp/tcp port of the packet.
    #[prost(uint32, optional, tag = "8")]
    pub local_port: ::core::option::Option<u32>,
    /// The remote udp/tcp port of the packet.
    #[prost(uint32, optional, tag = "9")]
    pub remote_port: ::core::option::Option<u32>,
    /// The 1-byte ICMP type identifier.
    #[prost(uint32, optional, tag = "10")]
    pub icmp_type: ::core::option::Option<u32>,
    /// The 1-byte ICMP code identifier.
    #[prost(uint32, optional, tag = "11")]
    pub icmp_code: ::core::option::Option<u32>,
}
/// NetworkPacketBundle bundles one or more packets sharing the same attributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPacketBundle {
    /// The timestamp of the i-th packet encoded as the nanoseconds since the
    /// enclosing TracePacket's timestamp.
    #[prost(uint64, repeated, tag = "3")]
    pub packet_timestamps: ::prost::alloc::vec::Vec<u64>,
    /// The length of the i-th packet in bytes (wire_size - L2_header_size).
    #[prost(uint32, repeated, tag = "4")]
    pub packet_lengths: ::prost::alloc::vec::Vec<u32>,
    /// Total number of packets in the bundle (when above aggregation_threshold).
    #[prost(uint32, optional, tag = "5")]
    pub total_packets: ::core::option::Option<u32>,
    /// Duration between first and last packet (when above aggregation_threshold).
    #[prost(uint64, optional, tag = "6")]
    pub total_duration: ::core::option::Option<u64>,
    /// Total packet length in bytes (when above aggregation_threshold).
    #[prost(uint64, optional, tag = "7")]
    pub total_length: ::core::option::Option<u64>,
    #[prost(oneof = "network_packet_bundle::PacketContext", tags = "1, 2")]
    pub packet_context: ::core::option::Option<network_packet_bundle::PacketContext>,
}
/// Nested message and enum types in `NetworkPacketBundle`.
pub mod network_packet_bundle {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PacketContext {
        /// The intern id for looking up the associated packet context.
        #[prost(uint64, tag = "1")]
        Iid(u64),
        /// The inlined context for events in this bundle.
        #[prost(message, tag = "2")]
        Ctx(super::NetworkPacketEvent),
    }
}
/// An internable packet context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPacketContext {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub ctx: ::core::option::Option<NetworkPacketEvent>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TrafficDirection {
    DirUnspecified = 0,
    DirIngress = 1,
    DirEgress = 2,
}
impl TrafficDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DirUnspecified => "DIR_UNSPECIFIED",
            Self::DirIngress => "DIR_INGRESS",
            Self::DirEgress => "DIR_EGRESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIR_UNSPECIFIED" => Some(Self::DirUnspecified),
            "DIR_INGRESS" => Some(Self::DirIngress),
            "DIR_EGRESS" => Some(Self::DirEgress),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackagesList {
    #[prost(message, repeated, tag = "1")]
    pub packages: ::prost::alloc::vec::Vec<packages_list::PackageInfo>,
    /// At least one error occurred parsing the packages.list.
    #[prost(bool, optional, tag = "2")]
    pub parse_error: ::core::option::Option<bool>,
    /// Failed to open / read packages.list.
    #[prost(bool, optional, tag = "3")]
    pub read_error: ::core::option::Option<bool>,
}
/// Nested message and enum types in `PackagesList`.
pub mod packages_list {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PackageInfo {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag = "2")]
        pub uid: ::core::option::Option<u64>,
        #[prost(bool, optional, tag = "3")]
        pub debuggable: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "4")]
        pub profileable_from_shell: ::core::option::Option<bool>,
        #[prost(int64, optional, tag = "5")]
        pub version_code: ::core::option::Option<i64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PixelModemEvents {
    /// Pigweed-format dehydrated events.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Timestamps of the events, converted to CLOCK_BOOTTIME. The first
    /// timestamp is the absolute timestamp of the first event. Subsequent
    /// timestamps are deltas from the previous timestamp.
    /// The nth entry from `events` gets the nth entry here.
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub event_time_nanos: ::prost::alloc::vec::Vec<u64>,
}
/// NB: this is not emitted in the trace but can be prepended later.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PixelModemTokenDatabase {
    /// Pigweed-format database to allow event rehydration.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub database: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// represents a single log entry
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoLogMessage {
    /// log statement identifier, created from message string and log level.
    #[prost(fixed64, optional, tag = "1")]
    pub message_id: ::core::option::Option<u64>,
    /// string parameters passed to the log call that have been interned.
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub str_param_iids: ::prost::alloc::vec::Vec<u32>,
    /// integer parameters passed to the log call.
    #[prost(sint64, repeated, packed = "false", tag = "3")]
    pub sint64_params: ::prost::alloc::vec::Vec<i64>,
    /// floating point parameters passed to the log call.
    #[prost(double, repeated, packed = "false", tag = "4")]
    pub double_params: ::prost::alloc::vec::Vec<f64>,
    /// boolean parameters passed to the log call.
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub boolean_params: ::prost::alloc::vec::Vec<i32>,
    /// id of the interned stacktrace string
    /// (only dumped if explicitly confuigured to do so)
    #[prost(uint32, optional, tag = "6")]
    pub stacktrace_iid: ::core::option::Option<u32>,
}
/// contains all the data required to fully decode the protolog messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoLogViewerConfig {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<proto_log_viewer_config::MessageData>,
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<proto_log_viewer_config::Group>,
}
/// Nested message and enum types in `ProtoLogViewerConfig`.
pub mod proto_log_viewer_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MessageData {
        /// the id of the message that is logged in a ProtoLogMessage
        #[prost(fixed64, optional, tag = "1")]
        pub message_id: ::core::option::Option<u64>,
        /// the string representation of the message
        #[prost(string, optional, tag = "2")]
        pub message: ::core::option::Option<::prost::alloc::string::String>,
        /// the level of the message
        #[prost(enumeration = "super::ProtoLogLevel", optional, tag = "3")]
        pub level: ::core::option::Option<i32>,
        /// the id of the log group this message belongs to
        #[prost(uint32, optional, tag = "4")]
        pub group_id: ::core::option::Option<u32>,
    }
    /// information about a ProtoLog log group
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Group {
        #[prost(uint32, optional, tag = "1")]
        pub id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub tag: ::core::option::Option<::prost::alloc::string::String>,
    }
}
/// ShellTransition messages record information about the shell transitions in
/// the system. This is used to track the animations that are created and execute
/// through the shell transition system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShellTransition {
    /// The unique identifier of the transition.
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    /// The time the transition was created on the WM side
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "2")]
    pub create_time_ns: ::core::option::Option<i64>,
    /// The time the transition was sent from the WM side to shell
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "3")]
    pub send_time_ns: ::core::option::Option<i64>,
    /// The time the transition was dispatched by shell to execute
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "4")]
    pub dispatch_time_ns: ::core::option::Option<i64>,
    /// If the transition merge was accepted by the transition handler, this
    /// contains the time the transition was merged into transition with id
    /// `merge_target`.
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "5")]
    pub merge_time_ns: ::core::option::Option<i64>,
    /// The time shell proposed the transition should be merged to the transition
    /// handler into transition with id `merge_target`.
    /// (using SystemClock.elapsedRealtimeNanos()).
    #[prost(int64, optional, tag = "6")]
    pub merge_request_time_ns: ::core::option::Option<i64>,
    /// If the transition was aborted on the shell side, this is the time that
    /// occurred.
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "7")]
    pub shell_abort_time_ns: ::core::option::Option<i64>,
    /// If the transition was aborted on the wm side, this is the time that
    /// occurred.
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "8")]
    pub wm_abort_time_ns: ::core::option::Option<i64>,
    /// The time WM considers the transition to be complete.
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "9")]
    pub finish_time_ns: ::core::option::Option<i64>,
    /// The id of the transaction that WM proposed to use as the starting
    /// transaction. It contains all the layer changes required to setup the
    /// transition and should be executed right at the start of the transition
    /// by the transition handler.
    #[prost(uint64, optional, tag = "10")]
    pub start_transaction_id: ::core::option::Option<u64>,
    /// The if of the transaction that WM proposed to use as the finish
    /// transaction. It contains all the layer changes required to set the final
    /// state of the transition.
    #[prost(uint64, optional, tag = "11")]
    pub finish_transaction_id: ::core::option::Option<u64>,
    /// The id of the handler that executed the transition. A HandlerMappings
    /// message in the trace will contain the mapping of id to a string
    /// representation of the handler.
    #[prost(int32, optional, tag = "12")]
    pub handler: ::core::option::Option<i32>,
    /// The transition type of this transition (e.g. TO_FRONT, OPEN, CLOSE).
    #[prost(int32, optional, tag = "13")]
    pub r#type: ::core::option::Option<i32>,
    /// The list of targets that are part of this transition.
    #[prost(message, repeated, tag = "14")]
    pub targets: ::prost::alloc::vec::Vec<shell_transition::Target>,
    /// The id of the transition we have requested to merge or have merged this
    /// transition into.
    #[prost(int32, optional, tag = "15")]
    pub merge_target: ::core::option::Option<i32>,
    /// The flags set on this transition.
    #[prost(int32, optional, tag = "16")]
    pub flags: ::core::option::Option<i32>,
    /// The time the starting window was removed. Tracked because this can
    /// happen after the transition finishes, but the app may not yet be visible
    /// until the starting window is removed. So in a sense the transition is not
    /// finished until the starting window is removed. (b/284302118)
    /// (using SystemClock.elapsedRealtimeNanos())
    #[prost(int64, optional, tag = "17")]
    pub starting_window_remove_time_ns: ::core::option::Option<i64>,
}
/// Nested message and enum types in `ShellTransition`.
pub mod shell_transition {
    /// Contains the information about the windows targeted in a transition.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Target {
        /// The transition mode of this target (e.g. TO_FRONT, CLOSE...)
        #[prost(int32, optional, tag = "1")]
        pub mode: ::core::option::Option<i32>,
        /// The layer id of this target.
        #[prost(int32, optional, tag = "2")]
        pub layer_id: ::core::option::Option<i32>,
        /// The window id of this target.
        #[prost(int32, optional, tag = "3")]
        pub window_id: ::core::option::Option<i32>,
        /// The flags set on this target.
        #[prost(int32, optional, tag = "4")]
        pub flags: ::core::option::Option<i32>,
    }
}
/// Contains mappings from handler ids to string representation of the handlers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShellHandlerMappings {
    #[prost(message, repeated, tag = "1")]
    pub mapping: ::prost::alloc::vec::Vec<ShellHandlerMapping>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShellHandlerMapping {
    /// The id of the handler used in the ShellTransition message.
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    /// A human readable and meaningful string representation of the handler.
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RectProto {
    #[prost(int32, optional, tag = "1")]
    pub left: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub top: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub right: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub bottom: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionProto {
    #[prost(message, repeated, tag = "2")]
    pub rect: ::prost::alloc::vec::Vec<RectProto>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeProto {
    #[prost(int32, optional, tag = "1")]
    pub w: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub h: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransformProto {
    #[prost(float, optional, tag = "1")]
    pub dsdx: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub dtdx: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub dsdy: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub dtdy: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ColorProto {
    #[prost(float, optional, tag = "1")]
    pub r: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub g: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub b: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub a: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputWindowInfoProto {
    #[prost(uint32, optional, tag = "1")]
    pub layout_params_flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub layout_params_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub frame: ::core::option::Option<RectProto>,
    #[prost(message, optional, tag = "4")]
    pub touchable_region: ::core::option::Option<RegionProto>,
    #[prost(int32, optional, tag = "5")]
    pub surface_inset: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "6")]
    pub visible: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(bool, optional, tag = "7")]
    pub can_receive_keys: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub focusable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub has_wallpaper: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "10")]
    pub global_scale_factor: ::core::option::Option<f32>,
    #[deprecated]
    #[prost(float, optional, tag = "11")]
    pub window_x_scale: ::core::option::Option<f32>,
    #[deprecated]
    #[prost(float, optional, tag = "12")]
    pub window_y_scale: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "13")]
    pub crop_layer_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "14")]
    pub replace_touchable_region_with_crop: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "15")]
    pub touchable_region_crop: ::core::option::Option<RectProto>,
    #[prost(message, optional, tag = "16")]
    pub transform: ::core::option::Option<TransformProto>,
    #[prost(uint32, optional, tag = "17")]
    pub input_config: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlurRegion {
    #[prost(uint32, optional, tag = "1")]
    pub blur_radius: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub corner_radius_tl: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub corner_radius_tr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub corner_radius_bl: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "5")]
    pub corner_radius_br: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub alpha: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "7")]
    pub left: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub top: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub right: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub bottom: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColorTransformProto {
    /// This will be a 4x4 matrix of float values
    #[prost(float, repeated, tag = "1")]
    pub val: ::prost::alloc::vec::Vec<f32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TrustedOverlay {
    Unset = 0,
    Disabled = 1,
    Enabled = 2,
}
impl TrustedOverlay {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unset => "UNSET",
            Self::Disabled => "DISABLED",
            Self::Enabled => "ENABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSET" => Some(Self::Unset),
            "DISABLED" => Some(Self::Disabled),
            "ENABLED" => Some(Self::Enabled),
            _ => None,
        }
    }
}
/// Message used by Winscope to process legacy trace files.
/// Represents a file full of surface flinger trace entries.
/// Encoded, it should start with 0x4c 0x59 0x52 0x54 0x52 0x41 0x43 0x45
/// (.LYRTRACE), such that they can be easily identified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayersTraceFileProto {
    /// Must be the first field, set to value in MagicNumber
    #[prost(fixed64, optional, tag = "1")]
    pub magic_number: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub entry: ::prost::alloc::vec::Vec<LayersSnapshotProto>,
    /// Offset between real-time clock and elapsed time clock in nanoseconds.
    /// Calculated as: systemTime(SYSTEM_TIME_REALTIME) -
    /// systemTime(SYSTEM_TIME_MONOTONIC)
    #[prost(fixed64, optional, tag = "3")]
    pub real_to_elapsed_time_offset_nanos: ::core::option::Option<u64>,
}
/// Nested message and enum types in `LayersTraceFileProto`.
pub mod layers_trace_file_proto {
    /// constant; MAGIC_NUMBER = (long) MAGIC_NUMBER_H << 32 |
    /// MagicNumber.MAGIC_NUMBER_L (this is needed because enums have to be 32 bits
    /// and there's no nice way to put 64bit constants into .proto files.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MagicNumber {
        Invalid = 0,
        /// LYRT (little-endian ASCII)
        L = 1414682956,
        /// RACE (little-endian ASCII)
        H = 1162035538,
    }
    impl MagicNumber {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "INVALID",
                Self::L => "MAGIC_NUMBER_L",
                Self::H => "MAGIC_NUMBER_H",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID" => Some(Self::Invalid),
                "MAGIC_NUMBER_L" => Some(Self::L),
                "MAGIC_NUMBER_H" => Some(Self::H),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayersSnapshotProto {
    /// elapsed realtime in nanos since boot of when this entry was logged
    #[prost(sfixed64, optional, tag = "1")]
    pub elapsed_realtime_nanos: ::core::option::Option<i64>,
    /// SurfaceFlinger's stage where the snapshot was triggered.
    /// Currently either "visibleRegionsDirty" or "bufferLatched".
    #[prost(string, optional, tag = "2")]
    pub r#where: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub layers: ::core::option::Option<LayersProto>,
    /// Blob for the current HWC information for all layers, reported by dumpsys.
    /// Example:
    ///    "maxDownScale: 4, maxFullWidth: 8192, HWState: 1, AssignedState: 3, ..."
    #[prost(string, optional, tag = "4")]
    pub hwc_blob: ::core::option::Option<::prost::alloc::string::String>,
    /// Excludes state sent during composition like visible region and composition
    /// type.
    #[prost(bool, optional, tag = "5")]
    pub excludes_composition_state: ::core::option::Option<bool>,
    /// Number of missed entries since the last entry was recorded.
    #[prost(uint32, optional, tag = "6")]
    pub missed_entries: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub displays: ::prost::alloc::vec::Vec<DisplayProto>,
    #[prost(int64, optional, tag = "8")]
    pub vsync_id: ::core::option::Option<i64>,
}
/// Contains a list of all layers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayersProto {
    #[prost(message, repeated, tag = "1")]
    pub layers: ::prost::alloc::vec::Vec<LayerProto>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisplayProto {
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
    /// Display descriptor, e.g. "Built-In Screen"
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub layer_stack: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub size: ::core::option::Option<SizeProto>,
    #[prost(message, optional, tag = "5")]
    pub layer_stack_space_rect: ::core::option::Option<RectProto>,
    #[prost(message, optional, tag = "6")]
    pub transform: ::core::option::Option<TransformProto>,
    #[prost(bool, optional, tag = "7")]
    pub is_virtual: ::core::option::Option<bool>,
    #[prost(double, optional, tag = "8")]
    pub dpi_x: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "9")]
    pub dpi_y: ::core::option::Option<f64>,
}
/// Information about each layer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayerProto {
    /// unique id per layer.
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    /// unique name per layer.
    /// Example: "Wallpaper".
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// list of children this layer may have. May be empty.
    #[prost(int32, repeated, tag = "3")]
    pub children: ::prost::alloc::vec::Vec<i32>,
    /// list of layers that are z order relative to this layer.
    #[prost(int32, repeated, tag = "4")]
    pub relatives: ::prost::alloc::vec::Vec<i32>,
    /// The type of layer.
    /// Examples: "ContainerLayer", "BufferStateLayer".
    #[prost(string, optional, tag = "5")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub transparent_region: ::core::option::Option<RegionProto>,
    #[prost(message, optional, tag = "7")]
    pub visible_region: ::core::option::Option<RegionProto>,
    #[prost(message, optional, tag = "8")]
    pub damage_region: ::core::option::Option<RegionProto>,
    #[prost(uint32, optional, tag = "9")]
    pub layer_stack: ::core::option::Option<u32>,
    /// The layer's z order. Can be z order in layer stack, relative to parent,
    /// or relative to another layer specified in zOrderRelative.
    #[prost(int32, optional, tag = "10")]
    pub z: ::core::option::Option<i32>,
    /// The layer's position on the display.
    #[prost(message, optional, tag = "11")]
    pub position: ::core::option::Option<PositionProto>,
    /// The layer's requested position.
    #[prost(message, optional, tag = "12")]
    pub requested_position: ::core::option::Option<PositionProto>,
    /// The layer's size.
    #[prost(message, optional, tag = "13")]
    pub size: ::core::option::Option<SizeProto>,
    /// The layer's crop in its own bounds.
    #[prost(message, optional, tag = "14")]
    pub crop: ::core::option::Option<RectProto>,
    /// The layer's crop in its parent's bounds.
    #[deprecated]
    #[prost(message, optional, tag = "15")]
    pub final_crop: ::core::option::Option<RectProto>,
    #[prost(bool, optional, tag = "16")]
    pub is_opaque: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub invalidate: ::core::option::Option<bool>,
    /// Composition states's dataspace.
    /// Examples: "STANDARD_BT709", "STANDARD_BT601_625".
    /// See full enum in
    /// frameworks/native/libs/nativewindow/include/android/data_space.h
    #[prost(string, optional, tag = "18")]
    pub dataspace: ::core::option::Option<::prost::alloc::string::String>,
    /// Buffer's pixel format
    /// Examples: "PIXEL_FORMAT_TRANSLUCENT", "PIXEL_FORMAT_RGBA_8888".
    /// See full enum in frameworks/native/libs/ui/include/ui/PixelFormat.h
    #[prost(string, optional, tag = "19")]
    pub pixel_format: ::core::option::Option<::prost::alloc::string::String>,
    /// The layer's actual color.
    #[prost(message, optional, tag = "20")]
    pub color: ::core::option::Option<ColorProto>,
    /// The layer's requested color.
    #[prost(message, optional, tag = "21")]
    pub requested_color: ::core::option::Option<ColorProto>,
    /// Can be any combination of
    ///     hidden = 0x01
    ///     opaque = 0x02,
    ///     secure = 0x80,
    #[prost(uint32, optional, tag = "22")]
    pub flags: ::core::option::Option<u32>,
    /// The layer's actual transform
    #[prost(message, optional, tag = "23")]
    pub transform: ::core::option::Option<TransformProto>,
    /// The layer's requested transform.
    #[prost(message, optional, tag = "24")]
    pub requested_transform: ::core::option::Option<TransformProto>,
    /// The parent layer. This value can be null if there is no parent.
    #[prost(int32, optional, tag = "25")]
    pub parent: ::core::option::Option<i32>,
    /// The layer that this layer has a z order relative to. This value can be
    /// null.
    #[prost(int32, optional, tag = "26")]
    pub z_order_relative_of: ::core::option::Option<i32>,
    /// This value can be null if there's nothing to draw.
    #[prost(message, optional, tag = "27")]
    pub active_buffer: ::core::option::Option<ActiveBufferProto>,
    /// The number of frames available.
    #[prost(int32, optional, tag = "28")]
    pub queued_frames: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "29")]
    pub refresh_pending: ::core::option::Option<bool>,
    /// The layer's composer backend destination frame
    #[prost(message, optional, tag = "30")]
    pub hwc_frame: ::core::option::Option<RectProto>,
    /// The layer's composer backend source crop
    #[prost(message, optional, tag = "31")]
    pub hwc_crop: ::core::option::Option<FloatRectProto>,
    /// The layer's composer backend transform
    #[prost(int32, optional, tag = "32")]
    pub hwc_transform: ::core::option::Option<i32>,
    #[deprecated]
    #[prost(int32, optional, tag = "33")]
    pub window_type: ::core::option::Option<i32>,
    #[deprecated]
    #[prost(int32, optional, tag = "34")]
    pub app_id: ::core::option::Option<i32>,
    /// The layer's composition type
    #[prost(enumeration = "HwcCompositionType", optional, tag = "35")]
    pub hwc_composition_type: ::core::option::Option<i32>,
    /// If it's a buffer layer, indicate if the content is protected
    #[prost(bool, optional, tag = "36")]
    pub is_protected: ::core::option::Option<bool>,
    /// Current frame number being rendered.
    #[prost(uint64, optional, tag = "37")]
    pub curr_frame: ::core::option::Option<u64>,
    /// A list of barriers that the layer is waiting to update state.
    #[prost(message, repeated, tag = "38")]
    pub barrier_layer: ::prost::alloc::vec::Vec<BarrierLayerProto>,
    /// If active_buffer is not null, record its transform.
    #[prost(message, optional, tag = "39")]
    pub buffer_transform: ::core::option::Option<TransformProto>,
    #[prost(int32, optional, tag = "40")]
    pub effective_scaling_mode: ::core::option::Option<i32>,
    /// Layer's corner radius.
    #[prost(float, optional, tag = "41")]
    pub corner_radius: ::core::option::Option<f32>,
    /// Metadata map. May be empty.
    #[prost(map = "int32, string", tag = "42")]
    pub metadata: ::std::collections::HashMap<i32, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "43")]
    pub effective_transform: ::core::option::Option<TransformProto>,
    #[prost(message, optional, tag = "44")]
    pub source_bounds: ::core::option::Option<FloatRectProto>,
    #[prost(message, optional, tag = "45")]
    pub bounds: ::core::option::Option<FloatRectProto>,
    #[prost(message, optional, tag = "46")]
    pub screen_bounds: ::core::option::Option<FloatRectProto>,
    #[prost(message, optional, tag = "47")]
    pub input_window_info: ::core::option::Option<InputWindowInfoProto>,
    /// Crop used to draw the rounded corner.
    #[prost(message, optional, tag = "48")]
    pub corner_radius_crop: ::core::option::Option<FloatRectProto>,
    /// length of the shadow to draw around the layer, it may be set on the
    /// layer or set by a parent layer.
    #[prost(float, optional, tag = "49")]
    pub shadow_radius: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "50")]
    pub color_transform: ::core::option::Option<ColorTransformProto>,
    #[prost(bool, optional, tag = "51")]
    pub is_relative_of: ::core::option::Option<bool>,
    /// Layer's background blur radius in pixels.
    #[prost(int32, optional, tag = "52")]
    pub background_blur_radius: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "53")]
    pub owner_uid: ::core::option::Option<u32>,
    /// Regions of a layer, where blur should be applied.
    #[prost(message, repeated, tag = "54")]
    pub blur_regions: ::prost::alloc::vec::Vec<BlurRegion>,
    #[prost(bool, optional, tag = "55")]
    pub is_trusted_overlay: ::core::option::Option<bool>,
    /// Corner radius explicitly set on layer rather than inherited
    #[prost(float, optional, tag = "56")]
    pub requested_corner_radius: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "57")]
    pub destination_frame: ::core::option::Option<RectProto>,
    #[prost(uint32, optional, tag = "58")]
    pub original_id: ::core::option::Option<u32>,
    #[prost(enumeration = "TrustedOverlay", optional, tag = "59")]
    pub trusted_overlay: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositionProto {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloatRectProto {
    #[prost(float, optional, tag = "1")]
    pub left: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub top: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub right: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub bottom: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActiveBufferProto {
    #[prost(uint32, optional, tag = "1")]
    pub width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub stride: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub format: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub usage: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BarrierLayerProto {
    /// layer id the barrier is waiting on.
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    /// frame number the barrier is waiting on.
    #[prost(uint64, optional, tag = "2")]
    pub frame_number: ::core::option::Option<u64>,
}
/// Must match definition in the IComposerClient HAL
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HwcCompositionType {
    /// Invalid composition type
    HwcTypeUnspecified = 0,
    /// Layer was composited by the client into the client target buffer
    HwcTypeClient = 1,
    /// Layer was composited by the device through hardware overlays
    HwcTypeDevice = 2,
    /// Layer was composited by the device using a color
    HwcTypeSolidColor = 3,
    /// Similar to DEVICE, but the layer position may have been asynchronously set
    /// through setCursorPosition
    HwcTypeCursor = 4,
    /// Layer was composited by the device via a sideband stream
    HwcTypeSideband = 5,
    /// Layer was composited by hardware optimized for display decoration
    HwcTypeDisplayDecoration = 6,
}
impl HwcCompositionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HwcTypeUnspecified => "HWC_TYPE_UNSPECIFIED",
            Self::HwcTypeClient => "HWC_TYPE_CLIENT",
            Self::HwcTypeDevice => "HWC_TYPE_DEVICE",
            Self::HwcTypeSolidColor => "HWC_TYPE_SOLID_COLOR",
            Self::HwcTypeCursor => "HWC_TYPE_CURSOR",
            Self::HwcTypeSideband => "HWC_TYPE_SIDEBAND",
            Self::HwcTypeDisplayDecoration => "HWC_TYPE_DISPLAY_DECORATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HWC_TYPE_UNSPECIFIED" => Some(Self::HwcTypeUnspecified),
            "HWC_TYPE_CLIENT" => Some(Self::HwcTypeClient),
            "HWC_TYPE_DEVICE" => Some(Self::HwcTypeDevice),
            "HWC_TYPE_SOLID_COLOR" => Some(Self::HwcTypeSolidColor),
            "HWC_TYPE_CURSOR" => Some(Self::HwcTypeCursor),
            "HWC_TYPE_SIDEBAND" => Some(Self::HwcTypeSideband),
            "HWC_TYPE_DISPLAY_DECORATION" => Some(Self::HwcTypeDisplayDecoration),
            _ => None,
        }
    }
}
/// Message used by Winscope to process legacy trace files.
/// Represents a file full of surface flinger transactions.
/// Encoded, it should start with 0x54 0x4E 0x58 0x54 0x52 0x41 0x43 0x45
/// (.TNXTRACE), such that they can be easily identified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTraceFile {
    /// Must be the first field, set to value in MagicNumber
    #[prost(fixed64, optional, tag = "1")]
    pub magic_number: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub entry: ::prost::alloc::vec::Vec<TransactionTraceEntry>,
    /// offset between real-time clock and elapsed time clock in nanoseconds.
    /// Calculated as: systemTime(SYSTEM_TIME_REALTIME) -
    /// systemTime(SYSTEM_TIME_MONOTONIC)
    #[prost(fixed64, optional, tag = "3")]
    pub real_to_elapsed_time_offset_nanos: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub version: ::core::option::Option<u32>,
}
/// Nested message and enum types in `TransactionTraceFile`.
pub mod transaction_trace_file {
    /// constant; MAGIC_NUMBER = (long) MAGIC_NUMBER_H << 32 |
    /// MagicNumber.MAGIC_NUMBER_L (this is needed because enums have to be 32 bits
    /// and there's no nice way to put 64bit constants into .proto files.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MagicNumber {
        Invalid = 0,
        /// TNXT (little-endian ASCII)
        L = 1415073364,
        /// RACE (little-endian ASCII)
        H = 1162035538,
    }
    impl MagicNumber {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "INVALID",
                Self::L => "MAGIC_NUMBER_L",
                Self::H => "MAGIC_NUMBER_H",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID" => Some(Self::Invalid),
                "MAGIC_NUMBER_L" => Some(Self::L),
                "MAGIC_NUMBER_H" => Some(Self::H),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTraceEntry {
    #[prost(int64, optional, tag = "1")]
    pub elapsed_realtime_nanos: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub vsync_id: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "3")]
    pub transactions: ::prost::alloc::vec::Vec<TransactionState>,
    #[prost(message, repeated, tag = "4")]
    pub added_layers: ::prost::alloc::vec::Vec<LayerCreationArgs>,
    #[prost(uint32, repeated, packed = "false", tag = "5")]
    pub destroyed_layers: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "6")]
    pub added_displays: ::prost::alloc::vec::Vec<DisplayState>,
    #[prost(int32, repeated, packed = "false", tag = "7")]
    pub removed_displays: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub destroyed_layer_handles: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "9")]
    pub displays_changed: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "10")]
    pub displays: ::prost::alloc::vec::Vec<DisplayInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayInfo {
    #[prost(uint32, optional, tag = "1")]
    pub layer_stack: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub display_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub logical_width: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub logical_height: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "5")]
    pub transform_inverse: ::core::option::Option<Transform>,
    #[prost(message, optional, tag = "6")]
    pub transform: ::core::option::Option<Transform>,
    #[prost(bool, optional, tag = "7")]
    pub receives_input: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub is_secure: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub is_primary: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub is_virtual: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "11")]
    pub rotation_flags: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub transform_hint: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayerCreationArgs {
    #[prost(uint32, optional, tag = "1")]
    pub layer_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub parent_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub mirror_from_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub add_to_root: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "7")]
    pub layer_stack_to_mirror: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Transform {
    #[prost(float, optional, tag = "1")]
    pub dsdx: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub dtdx: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub dtdy: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub dsdy: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub tx: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub ty: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionState {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub uid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub vsync_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub input_event_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub post_time: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "6")]
    pub transaction_id: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "7")]
    pub layer_changes: ::prost::alloc::vec::Vec<LayerState>,
    #[prost(message, repeated, tag = "8")]
    pub display_changes: ::prost::alloc::vec::Vec<DisplayState>,
    #[prost(uint64, repeated, packed = "false", tag = "9")]
    pub merged_transaction_ids: ::prost::alloc::vec::Vec<u64>,
}
/// Keep insync with layer_state_t
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayerState {
    #[prost(uint32, optional, tag = "1")]
    pub layer_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub what: ::core::option::Option<u64>,
    #[prost(float, optional, tag = "3")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub y: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub z: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub h: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub layer_stack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub mask: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "11")]
    pub matrix: ::core::option::Option<layer_state::Matrix22>,
    #[prost(float, optional, tag = "12")]
    pub corner_radius: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "13")]
    pub background_blur_radius: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub parent_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub relative_parent_id: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "16")]
    pub alpha: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "17")]
    pub color: ::core::option::Option<layer_state::Color3>,
    #[prost(message, optional, tag = "18")]
    pub transparent_region: ::core::option::Option<RegionProto>,
    #[prost(uint32, optional, tag = "19")]
    pub transform: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "20")]
    pub transform_to_display_inverse: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "21")]
    pub crop: ::core::option::Option<RectProto>,
    #[prost(message, optional, tag = "22")]
    pub buffer_data: ::core::option::Option<layer_state::BufferData>,
    #[prost(int32, optional, tag = "23")]
    pub api: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "24")]
    pub has_sideband_stream: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "25")]
    pub color_transform: ::core::option::Option<ColorTransformProto>,
    #[prost(message, repeated, tag = "26")]
    pub blur_regions: ::prost::alloc::vec::Vec<BlurRegion>,
    #[prost(message, optional, tag = "27")]
    pub window_info_handle: ::core::option::Option<layer_state::WindowInfo>,
    #[prost(float, optional, tag = "28")]
    pub bg_color_alpha: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "29")]
    pub bg_color_dataspace: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "30")]
    pub color_space_agnostic: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "31")]
    pub shadow_radius: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "32")]
    pub frame_rate_selection_priority: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "33")]
    pub frame_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "34")]
    pub frame_rate_compatibility: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "35")]
    pub change_frame_rate_strategy: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "36")]
    pub fixed_transform_hint: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "37")]
    pub frame_number: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "38")]
    pub auto_refresh: ::core::option::Option<bool>,
    /// unused
    #[prost(bool, optional, tag = "39")]
    pub is_trusted_overlay: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "40")]
    pub buffer_crop: ::core::option::Option<RectProto>,
    #[prost(message, optional, tag = "41")]
    pub destination_frame: ::core::option::Option<RectProto>,
    #[prost(enumeration = "layer_state::DropInputMode", optional, tag = "42")]
    pub drop_input_mode: ::core::option::Option<i32>,
    #[prost(enumeration = "TrustedOverlay", optional, tag = "43")]
    pub trusted_overlay: ::core::option::Option<i32>,
}
/// Nested message and enum types in `LayerState`.
pub mod layer_state {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Matrix22 {
        #[prost(float, optional, tag = "1")]
        pub dsdx: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub dtdx: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub dtdy: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4")]
        pub dsdy: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Color3 {
        #[prost(float, optional, tag = "1")]
        pub r: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub g: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub b: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BufferData {
        #[prost(uint64, optional, tag = "1")]
        pub buffer_id: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "2")]
        pub width: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub height: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "4")]
        pub frame_number: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "5")]
        pub flags: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "6")]
        pub cached_buffer_id: ::core::option::Option<u64>,
        #[prost(enumeration = "buffer_data::PixelFormat", optional, tag = "7")]
        pub pixel_format: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "8")]
        pub usage: ::core::option::Option<u64>,
    }
    /// Nested message and enum types in `BufferData`.
    pub mod buffer_data {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BufferDataChange {
            None = 0,
            FenceChanged = 1,
            FrameNumberChanged = 2,
            CachedBufferChanged = 4,
        }
        impl BufferDataChange {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "BufferDataChangeNone",
                    Self::FenceChanged => "fenceChanged",
                    Self::FrameNumberChanged => "frameNumberChanged",
                    Self::CachedBufferChanged => "cachedBufferChanged",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BufferDataChangeNone" => Some(Self::None),
                    "fenceChanged" => Some(Self::FenceChanged),
                    "frameNumberChanged" => Some(Self::FrameNumberChanged),
                    "cachedBufferChanged" => Some(Self::CachedBufferChanged),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PixelFormat {
            Unknown = 0,
            Custom = -4,
            Translucent = -3,
            Transparent = -2,
            Opaque = -1,
            Rgba8888 = 1,
            Rgbx8888 = 2,
            Rgb888 = 3,
            Rgb565 = 4,
            Bgra8888 = 5,
            Rgba5551 = 6,
            Rgba4444 = 7,
            RgbaFp16 = 22,
            Rgba1010102 = 43,
            R8 = 56,
        }
        impl PixelFormat {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "PIXEL_FORMAT_UNKNOWN",
                    Self::Custom => "PIXEL_FORMAT_CUSTOM",
                    Self::Translucent => "PIXEL_FORMAT_TRANSLUCENT",
                    Self::Transparent => "PIXEL_FORMAT_TRANSPARENT",
                    Self::Opaque => "PIXEL_FORMAT_OPAQUE",
                    Self::Rgba8888 => "PIXEL_FORMAT_RGBA_8888",
                    Self::Rgbx8888 => "PIXEL_FORMAT_RGBX_8888",
                    Self::Rgb888 => "PIXEL_FORMAT_RGB_888",
                    Self::Rgb565 => "PIXEL_FORMAT_RGB_565",
                    Self::Bgra8888 => "PIXEL_FORMAT_BGRA_8888",
                    Self::Rgba5551 => "PIXEL_FORMAT_RGBA_5551",
                    Self::Rgba4444 => "PIXEL_FORMAT_RGBA_4444",
                    Self::RgbaFp16 => "PIXEL_FORMAT_RGBA_FP16",
                    Self::Rgba1010102 => "PIXEL_FORMAT_RGBA_1010102",
                    Self::R8 => "PIXEL_FORMAT_R_8",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PIXEL_FORMAT_UNKNOWN" => Some(Self::Unknown),
                    "PIXEL_FORMAT_CUSTOM" => Some(Self::Custom),
                    "PIXEL_FORMAT_TRANSLUCENT" => Some(Self::Translucent),
                    "PIXEL_FORMAT_TRANSPARENT" => Some(Self::Transparent),
                    "PIXEL_FORMAT_OPAQUE" => Some(Self::Opaque),
                    "PIXEL_FORMAT_RGBA_8888" => Some(Self::Rgba8888),
                    "PIXEL_FORMAT_RGBX_8888" => Some(Self::Rgbx8888),
                    "PIXEL_FORMAT_RGB_888" => Some(Self::Rgb888),
                    "PIXEL_FORMAT_RGB_565" => Some(Self::Rgb565),
                    "PIXEL_FORMAT_BGRA_8888" => Some(Self::Bgra8888),
                    "PIXEL_FORMAT_RGBA_5551" => Some(Self::Rgba5551),
                    "PIXEL_FORMAT_RGBA_4444" => Some(Self::Rgba4444),
                    "PIXEL_FORMAT_RGBA_FP16" => Some(Self::RgbaFp16),
                    "PIXEL_FORMAT_RGBA_1010102" => Some(Self::Rgba1010102),
                    "PIXEL_FORMAT_R_8" => Some(Self::R8),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowInfo {
        #[prost(uint32, optional, tag = "1")]
        pub layout_params_flags: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "2")]
        pub layout_params_type: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "3")]
        pub touchable_region: ::core::option::Option<super::RegionProto>,
        #[prost(int32, optional, tag = "4")]
        pub surface_inset: ::core::option::Option<i32>,
        /// unused
        #[prost(bool, optional, tag = "5")]
        pub focusable: ::core::option::Option<bool>,
        /// unused
        #[prost(bool, optional, tag = "6")]
        pub has_wallpaper: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "7")]
        pub global_scale_factor: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "8")]
        pub crop_layer_id: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "9")]
        pub replace_touchable_region_with_crop: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "10")]
        pub touchable_region_crop: ::core::option::Option<super::RectProto>,
        #[prost(message, optional, tag = "11")]
        pub transform: ::core::option::Option<super::Transform>,
        #[prost(uint32, optional, tag = "12")]
        pub input_config: ::core::option::Option<u32>,
    }
    /// Changes are split into ChangesLsb and ChangesMsb. First 32 bits are in
    /// ChangesLsb and the next 32 bits are in ChangesMsb. This is needed because
    /// enums have to be 32 bits and there's no nice way to put 64bit constants
    /// into .proto files.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangesLsb {
        EChangesLsbNone = 0,
        EPositionChanged = 1,
        ELayerChanged = 2,
        /// unused = 0x00000004;
        EAlphaChanged = 8,
        EMatrixChanged = 16,
        ETransparentRegionChanged = 32,
        EFlagsChanged = 64,
        ELayerStackChanged = 128,
        EReleaseBufferListenerChanged = 1024,
        EShadowRadiusChanged = 2048,
        EBufferCropChanged = 8192,
        ERelativeLayerChanged = 16384,
        EReparent = 32768,
        EColorChanged = 65536,
        EBufferTransformChanged = 262144,
        ETransformToDisplayInverseChanged = 524288,
        ECropChanged = 1048576,
        EBufferChanged = 2097152,
        EAcquireFenceChanged = 4194304,
        EDataspaceChanged = 8388608,
        EHdrMetadataChanged = 16777216,
        ESurfaceDamageRegionChanged = 33554432,
        EApiChanged = 67108864,
        ESidebandStreamChanged = 134217728,
        EColorTransformChanged = 268435456,
        EHasListenerCallbacksChanged = 536870912,
        EInputInfoChanged = 1073741824,
        /// 0x80000000; (proto stores enums as signed int)
        ECornerRadiusChanged = -2147483648,
    }
    impl ChangesLsb {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EChangesLsbNone => "eChangesLsbNone",
                Self::EPositionChanged => "ePositionChanged",
                Self::ELayerChanged => "eLayerChanged",
                Self::EAlphaChanged => "eAlphaChanged",
                Self::EMatrixChanged => "eMatrixChanged",
                Self::ETransparentRegionChanged => "eTransparentRegionChanged",
                Self::EFlagsChanged => "eFlagsChanged",
                Self::ELayerStackChanged => "eLayerStackChanged",
                Self::EReleaseBufferListenerChanged => "eReleaseBufferListenerChanged",
                Self::EShadowRadiusChanged => "eShadowRadiusChanged",
                Self::EBufferCropChanged => "eBufferCropChanged",
                Self::ERelativeLayerChanged => "eRelativeLayerChanged",
                Self::EReparent => "eReparent",
                Self::EColorChanged => "eColorChanged",
                Self::EBufferTransformChanged => "eBufferTransformChanged",
                Self::ETransformToDisplayInverseChanged => {
                    "eTransformToDisplayInverseChanged"
                }
                Self::ECropChanged => "eCropChanged",
                Self::EBufferChanged => "eBufferChanged",
                Self::EAcquireFenceChanged => "eAcquireFenceChanged",
                Self::EDataspaceChanged => "eDataspaceChanged",
                Self::EHdrMetadataChanged => "eHdrMetadataChanged",
                Self::ESurfaceDamageRegionChanged => "eSurfaceDamageRegionChanged",
                Self::EApiChanged => "eApiChanged",
                Self::ESidebandStreamChanged => "eSidebandStreamChanged",
                Self::EColorTransformChanged => "eColorTransformChanged",
                Self::EHasListenerCallbacksChanged => "eHasListenerCallbacksChanged",
                Self::EInputInfoChanged => "eInputInfoChanged",
                Self::ECornerRadiusChanged => "eCornerRadiusChanged",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "eChangesLsbNone" => Some(Self::EChangesLsbNone),
                "ePositionChanged" => Some(Self::EPositionChanged),
                "eLayerChanged" => Some(Self::ELayerChanged),
                "eAlphaChanged" => Some(Self::EAlphaChanged),
                "eMatrixChanged" => Some(Self::EMatrixChanged),
                "eTransparentRegionChanged" => Some(Self::ETransparentRegionChanged),
                "eFlagsChanged" => Some(Self::EFlagsChanged),
                "eLayerStackChanged" => Some(Self::ELayerStackChanged),
                "eReleaseBufferListenerChanged" => {
                    Some(Self::EReleaseBufferListenerChanged)
                }
                "eShadowRadiusChanged" => Some(Self::EShadowRadiusChanged),
                "eBufferCropChanged" => Some(Self::EBufferCropChanged),
                "eRelativeLayerChanged" => Some(Self::ERelativeLayerChanged),
                "eReparent" => Some(Self::EReparent),
                "eColorChanged" => Some(Self::EColorChanged),
                "eBufferTransformChanged" => Some(Self::EBufferTransformChanged),
                "eTransformToDisplayInverseChanged" => {
                    Some(Self::ETransformToDisplayInverseChanged)
                }
                "eCropChanged" => Some(Self::ECropChanged),
                "eBufferChanged" => Some(Self::EBufferChanged),
                "eAcquireFenceChanged" => Some(Self::EAcquireFenceChanged),
                "eDataspaceChanged" => Some(Self::EDataspaceChanged),
                "eHdrMetadataChanged" => Some(Self::EHdrMetadataChanged),
                "eSurfaceDamageRegionChanged" => Some(Self::ESurfaceDamageRegionChanged),
                "eApiChanged" => Some(Self::EApiChanged),
                "eSidebandStreamChanged" => Some(Self::ESidebandStreamChanged),
                "eColorTransformChanged" => Some(Self::EColorTransformChanged),
                "eHasListenerCallbacksChanged" => {
                    Some(Self::EHasListenerCallbacksChanged)
                }
                "eInputInfoChanged" => Some(Self::EInputInfoChanged),
                "eCornerRadiusChanged" => Some(Self::ECornerRadiusChanged),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangesMsb {
        EChangesMsbNone = 0,
        EDestinationFrameChanged = 1,
        ECachedBufferChanged = 2,
        EBackgroundColorChanged = 4,
        EMetadataChanged = 8,
        EColorSpaceAgnosticChanged = 16,
        EFrameRateSelectionPriority = 32,
        EFrameRateChanged = 64,
        EBackgroundBlurRadiusChanged = 128,
        EProducerDisconnect = 256,
        EFixedTransformHintChanged = 512,
        EFrameNumberChanged = 1024,
        EBlurRegionsChanged = 2048,
        EAutoRefreshChanged = 4096,
        EStretchChanged = 8192,
        ETrustedOverlayChanged = 16384,
        EDropInputModeChanged = 32768,
    }
    impl ChangesMsb {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EChangesMsbNone => "eChangesMsbNone",
                Self::EDestinationFrameChanged => "eDestinationFrameChanged",
                Self::ECachedBufferChanged => "eCachedBufferChanged",
                Self::EBackgroundColorChanged => "eBackgroundColorChanged",
                Self::EMetadataChanged => "eMetadataChanged",
                Self::EColorSpaceAgnosticChanged => "eColorSpaceAgnosticChanged",
                Self::EFrameRateSelectionPriority => "eFrameRateSelectionPriority",
                Self::EFrameRateChanged => "eFrameRateChanged",
                Self::EBackgroundBlurRadiusChanged => "eBackgroundBlurRadiusChanged",
                Self::EProducerDisconnect => "eProducerDisconnect",
                Self::EFixedTransformHintChanged => "eFixedTransformHintChanged",
                Self::EFrameNumberChanged => "eFrameNumberChanged",
                Self::EBlurRegionsChanged => "eBlurRegionsChanged",
                Self::EAutoRefreshChanged => "eAutoRefreshChanged",
                Self::EStretchChanged => "eStretchChanged",
                Self::ETrustedOverlayChanged => "eTrustedOverlayChanged",
                Self::EDropInputModeChanged => "eDropInputModeChanged",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "eChangesMsbNone" => Some(Self::EChangesMsbNone),
                "eDestinationFrameChanged" => Some(Self::EDestinationFrameChanged),
                "eCachedBufferChanged" => Some(Self::ECachedBufferChanged),
                "eBackgroundColorChanged" => Some(Self::EBackgroundColorChanged),
                "eMetadataChanged" => Some(Self::EMetadataChanged),
                "eColorSpaceAgnosticChanged" => Some(Self::EColorSpaceAgnosticChanged),
                "eFrameRateSelectionPriority" => Some(Self::EFrameRateSelectionPriority),
                "eFrameRateChanged" => Some(Self::EFrameRateChanged),
                "eBackgroundBlurRadiusChanged" => {
                    Some(Self::EBackgroundBlurRadiusChanged)
                }
                "eProducerDisconnect" => Some(Self::EProducerDisconnect),
                "eFixedTransformHintChanged" => Some(Self::EFixedTransformHintChanged),
                "eFrameNumberChanged" => Some(Self::EFrameNumberChanged),
                "eBlurRegionsChanged" => Some(Self::EBlurRegionsChanged),
                "eAutoRefreshChanged" => Some(Self::EAutoRefreshChanged),
                "eStretchChanged" => Some(Self::EStretchChanged),
                "eTrustedOverlayChanged" => Some(Self::ETrustedOverlayChanged),
                "eDropInputModeChanged" => Some(Self::EDropInputModeChanged),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Flags {
        EFlagsNone = 0,
        ELayerHidden = 1,
        ELayerOpaque = 2,
        ELayerSkipScreenshot = 64,
        ELayerSecure = 128,
        EEnableBackpressure = 256,
        ELayerIsDisplayDecoration = 512,
    }
    impl Flags {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EFlagsNone => "eFlagsNone",
                Self::ELayerHidden => "eLayerHidden",
                Self::ELayerOpaque => "eLayerOpaque",
                Self::ELayerSkipScreenshot => "eLayerSkipScreenshot",
                Self::ELayerSecure => "eLayerSecure",
                Self::EEnableBackpressure => "eEnableBackpressure",
                Self::ELayerIsDisplayDecoration => "eLayerIsDisplayDecoration",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "eFlagsNone" => Some(Self::EFlagsNone),
                "eLayerHidden" => Some(Self::ELayerHidden),
                "eLayerOpaque" => Some(Self::ELayerOpaque),
                "eLayerSkipScreenshot" => Some(Self::ELayerSkipScreenshot),
                "eLayerSecure" => Some(Self::ELayerSecure),
                "eEnableBackpressure" => Some(Self::EEnableBackpressure),
                "eLayerIsDisplayDecoration" => Some(Self::ELayerIsDisplayDecoration),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DropInputMode {
        None = 0,
        All = 1,
        Obscured = 2,
    }
    impl DropInputMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::All => "ALL",
                Self::Obscured => "OBSCURED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "ALL" => Some(Self::All),
                "OBSCURED" => Some(Self::Obscured),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayState {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub what: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub layer_stack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub orientation: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub layer_stack_space_rect: ::core::option::Option<RectProto>,
    #[prost(message, optional, tag = "7")]
    pub oriented_display_space_rect: ::core::option::Option<RectProto>,
    #[prost(uint32, optional, tag = "8")]
    pub width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub height: ::core::option::Option<u32>,
}
/// Nested message and enum types in `DisplayState`.
pub mod display_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Changes {
        EChangesNone = 0,
        ESurfaceChanged = 1,
        ELayerStackChanged = 2,
        EDisplayProjectionChanged = 4,
        EDisplaySizeChanged = 8,
        EFlagsChanged = 16,
    }
    impl Changes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EChangesNone => "eChangesNone",
                Self::ESurfaceChanged => "eSurfaceChanged",
                Self::ELayerStackChanged => "eLayerStackChanged",
                Self::EDisplayProjectionChanged => "eDisplayProjectionChanged",
                Self::EDisplaySizeChanged => "eDisplaySizeChanged",
                Self::EFlagsChanged => "eFlagsChanged",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "eChangesNone" => Some(Self::EChangesNone),
                "eSurfaceChanged" => Some(Self::ESurfaceChanged),
                "eLayerStackChanged" => Some(Self::ELayerStackChanged),
                "eDisplayProjectionChanged" => Some(Self::EDisplayProjectionChanged),
                "eDisplaySizeChanged" => Some(Self::EDisplaySizeChanged),
                "eFlagsChanged" => Some(Self::EFlagsChanged),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinscopeExtensions {}
/// This message is not intended to be written by the chrome on the device.
/// It's emitted on the host by the telemetry benchmark infrastructure (it's a
/// part of the trace that's written by the telemetry tracing agent).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeBenchmarkMetadata {
    /// Time when the benchmark execution started (host unixtime in microseconds).
    #[prost(int64, optional, tag = "1")]
    pub benchmark_start_time_us: ::core::option::Option<i64>,
    /// Time when this particular story was run (host unixtime in microseconds).
    #[prost(int64, optional, tag = "2")]
    pub story_run_time_us: ::core::option::Option<i64>,
    /// Name of benchmark.
    #[prost(string, optional, tag = "3")]
    pub benchmark_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Description of benchmark.
    #[prost(string, optional, tag = "4")]
    pub benchmark_description: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional label.
    #[prost(string, optional, tag = "5")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of story.
    #[prost(string, optional, tag = "6")]
    pub story_name: ::core::option::Option<::prost::alloc::string::String>,
    /// List of story tags.
    #[prost(string, repeated, tag = "7")]
    pub story_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Index of the story run (>0 if the same story was run several times).
    #[prost(int32, optional, tag = "8")]
    pub story_run_index: ::core::option::Option<i32>,
    /// Whether this run failed.
    #[prost(bool, optional, tag = "9")]
    pub had_failures: ::core::option::Option<bool>,
}
/// Metadata for chrome traces.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeMetadataPacket {
    #[prost(message, optional, tag = "1")]
    pub background_tracing_metadata: ::core::option::Option<BackgroundTracingMetadata>,
    /// Version code of Chrome used by Android's Play Store. This field is only set
    /// on Android.
    #[prost(int32, optional, tag = "2")]
    pub chrome_version_code: ::core::option::Option<i32>,
    /// Comma separated list of enabled categories for tracing. The list of
    /// possible category strings are listed in code
    /// base/trace_event/builtin_categories.h.
    #[prost(string, optional, tag = "3")]
    pub enabled_categories: ::core::option::Option<::prost::alloc::string::String>,
    /// List of Finch study/groups that apply to this trace.
    #[prost(message, repeated, tag = "4")]
    pub field_trial_hashes: ::prost::alloc::vec::Vec<chrome_metadata_packet::FinchHash>,
}
/// Nested message and enum types in `ChromeMetadataPacket`.
pub mod chrome_metadata_packet {
    /// Finch name and group based on the ActiveGroupId.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FinchHash {
        #[prost(uint32, optional, tag = "1")]
        pub name: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub group: ::core::option::Option<u32>,
    }
}
/// Metadata related to background tracing scenarios, states and triggers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackgroundTracingMetadata {
    /// Specifies the rule that caused the trace to be uploaded.
    #[prost(message, optional, tag = "1")]
    pub triggered_rule: ::core::option::Option<background_tracing_metadata::TriggerRule>,
    /// List of all active triggers in current session, when trace was triggered.
    #[prost(message, repeated, tag = "2")]
    pub active_rules: ::prost::alloc::vec::Vec<background_tracing_metadata::TriggerRule>,
    /// Hash of the scenario name.
    #[prost(fixed32, optional, tag = "3")]
    pub scenario_name_hash: ::core::option::Option<u32>,
}
/// Nested message and enum types in `BackgroundTracingMetadata`.
pub mod background_tracing_metadata {
    /// Information about a trigger rule defined in the experiment config.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TriggerRule {
        #[prost(enumeration = "trigger_rule::TriggerType", optional, tag = "1")]
        pub trigger_type: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub histogram_rule: ::core::option::Option<trigger_rule::HistogramRule>,
        #[prost(message, optional, tag = "3")]
        pub named_rule: ::core::option::Option<trigger_rule::NamedRule>,
        /// Hash of the rule name.
        #[prost(fixed32, optional, tag = "4")]
        pub name_hash: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `TriggerRule`.
    pub mod trigger_rule {
        /// Configuration of histogram trigger.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct HistogramRule {
            /// UMA histogram name hash, same as HistogramEventProto.name_hash.
            #[prost(fixed64, optional, tag = "1")]
            pub histogram_name_hash: ::core::option::Option<u64>,
            /// Range of values of the histogram that activates trigger.
            #[prost(int64, optional, tag = "2")]
            pub histogram_min_trigger: ::core::option::Option<i64>,
            #[prost(int64, optional, tag = "3")]
            pub histogram_max_trigger: ::core::option::Option<i64>,
        }
        /// Configuration of named trigger.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NamedRule {
            #[prost(enumeration = "named_rule::EventType", optional, tag = "1")]
            pub event_type: ::core::option::Option<i32>,
            /// If |event_type| is CONTENT_TRIGGER, then this stores the hash of the
            /// content-trigger that actually fired.
            #[prost(fixed64, optional, tag = "2")]
            pub content_trigger_name_hash: ::core::option::Option<u64>,
        }
        /// Nested message and enum types in `NamedRule`.
        pub mod named_rule {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum EventType {
                Unspecified = 0,
                SessionRestore = 1,
                Navigation = 2,
                Startup = 3,
                ReachedCode = 4,
                ContentTrigger = 5,
                TestRule = 1000,
            }
            impl EventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::SessionRestore => "SESSION_RESTORE",
                        Self::Navigation => "NAVIGATION",
                        Self::Startup => "STARTUP",
                        Self::ReachedCode => "REACHED_CODE",
                        Self::ContentTrigger => "CONTENT_TRIGGER",
                        Self::TestRule => "TEST_RULE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "SESSION_RESTORE" => Some(Self::SessionRestore),
                        "NAVIGATION" => Some(Self::Navigation),
                        "STARTUP" => Some(Self::Startup),
                        "REACHED_CODE" => Some(Self::ReachedCode),
                        "CONTENT_TRIGGER" => Some(Self::ContentTrigger),
                        "TEST_RULE" => Some(Self::TestRule),
                        _ => None,
                    }
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TriggerType {
            TriggerUnspecified = 0,
            /// Traces are triggered by specific range of values of an UMA histogram.
            MonitorAndDumpWhenSpecificHistogramAndValue = 1,
            /// Traces are triggered by specific named events in chromium codebase,
            /// like "second-update-failure".
            MonitorAndDumpWhenTriggerNamed = 2,
        }
        impl TriggerType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::TriggerUnspecified => "TRIGGER_UNSPECIFIED",
                    Self::MonitorAndDumpWhenSpecificHistogramAndValue => {
                        "MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE"
                    }
                    Self::MonitorAndDumpWhenTriggerNamed => {
                        "MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TRIGGER_UNSPECIFIED" => Some(Self::TriggerUnspecified),
                    "MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE" => {
                        Some(Self::MonitorAndDumpWhenSpecificHistogramAndValue)
                    }
                    "MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED" => {
                        Some(Self::MonitorAndDumpWhenTriggerNamed)
                    }
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeTracedValue {
    #[prost(enumeration = "chrome_traced_value::NestedType", optional, tag = "1")]
    pub nested_type: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub dict_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub dict_values: ::prost::alloc::vec::Vec<ChromeTracedValue>,
    #[prost(message, repeated, tag = "4")]
    pub array_values: ::prost::alloc::vec::Vec<ChromeTracedValue>,
    #[prost(int32, optional, tag = "5")]
    pub int_value: ::core::option::Option<i32>,
    #[prost(double, optional, tag = "6")]
    pub double_value: ::core::option::Option<f64>,
    #[prost(bool, optional, tag = "7")]
    pub bool_value: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "8")]
    pub string_value: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChromeTracedValue`.
pub mod chrome_traced_value {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NestedType {
        Dict = 0,
        Array = 1,
    }
    impl NestedType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Dict => "DICT",
                Self::Array => "ARRAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DICT" => Some(Self::Dict),
                "ARRAY" => Some(Self::Array),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeStringTableEntry {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub index: ::core::option::Option<i32>,
}
/// Deprecated, use TrackEvent protos instead.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeTraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub phase: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub thread_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub duration: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub thread_duration: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "7")]
    pub scope: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "8")]
    pub id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "9")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "10")]
    pub category_group_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "11")]
    pub process_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "12")]
    pub thread_timestamp: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "13")]
    pub bind_id: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "14")]
    pub args: ::prost::alloc::vec::Vec<chrome_trace_event::Arg>,
    /// Takes precedence over respectively |name| and
    /// |category_group_name_index| if set,
    /// and are indices into |string_table|.
    #[prost(uint32, optional, tag = "15")]
    pub name_index: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub category_group_name_index: ::core::option::Option<u32>,
}
/// Nested message and enum types in `ChromeTraceEvent`.
pub mod chrome_trace_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Arg {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// Takes precedence over |name| if set,
        /// and is an index into |string_table|.
        #[prost(uint32, optional, tag = "9")]
        pub name_index: ::core::option::Option<u32>,
        #[prost(oneof = "arg::Value", tags = "2, 3, 4, 5, 6, 7, 8, 10")]
        pub value: ::core::option::Option<arg::Value>,
    }
    /// Nested message and enum types in `Arg`.
    pub mod arg {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(bool, tag = "2")]
            BoolValue(bool),
            #[prost(uint64, tag = "3")]
            UintValue(u64),
            #[prost(int64, tag = "4")]
            IntValue(i64),
            #[prost(double, tag = "5")]
            DoubleValue(f64),
            #[prost(string, tag = "6")]
            StringValue(::prost::alloc::string::String),
            /// Pointers are stored in a separate type as the JSON output treats them
            /// differently from other uint64 values.
            #[prost(uint64, tag = "7")]
            PointerValue(u64),
            #[prost(string, tag = "8")]
            JsonValue(::prost::alloc::string::String),
            #[prost(message, tag = "10")]
            TracedValue(super::super::ChromeTracedValue),
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeMetadata {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "chrome_metadata::Value", tags = "2, 3, 4, 5")]
    pub value: ::core::option::Option<chrome_metadata::Value>,
}
/// Nested message and enum types in `ChromeMetadata`.
pub mod chrome_metadata {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "2")]
        StringValue(::prost::alloc::string::String),
        #[prost(bool, tag = "3")]
        BoolValue(bool),
        #[prost(int64, tag = "4")]
        IntValue(i64),
        #[prost(string, tag = "5")]
        JsonValue(::prost::alloc::string::String),
    }
}
/// Subtraces produced in legacy json format by Chrome tracing agents not yet
/// updated to support the new binary format, e.g. ETW and CrOS ARC.
/// TODO(eseckler): Update these agents to become perfetto producers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeLegacyJsonTrace {
    #[prost(enumeration = "chrome_legacy_json_trace::TraceType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChromeLegacyJsonTrace`.
pub mod chrome_legacy_json_trace {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TraceType {
        UserTrace = 0,
        /// Deprecated.
        SystemTrace = 1,
    }
    impl TraceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UserTrace => "USER_TRACE",
                Self::SystemTrace => "SYSTEM_TRACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "USER_TRACE" => Some(Self::UserTrace),
                "SYSTEM_TRACE" => Some(Self::SystemTrace),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeEventBundle {
    /// Deprecated, use TrackEvent protos instead.
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub trace_events: ::prost::alloc::vec::Vec<ChromeTraceEvent>,
    /// TODO(ssid): This should be deprecated in favor of ChromeMetadataPacket
    /// which contains typed fields.
    #[prost(message, repeated, tag = "2")]
    pub metadata: ::prost::alloc::vec::Vec<ChromeMetadata>,
    /// ftrace output from CrOS and Cast system tracing agents.
    /// TODO(eseckler): Replace system traces with native perfetto service.
    #[prost(string, repeated, tag = "4")]
    pub legacy_ftrace_output: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub legacy_json_trace: ::prost::alloc::vec::Vec<ChromeLegacyJsonTrace>,
    /// Contents of a string table that's valid for
    /// the whole ChromeEventBundle entry.
    #[deprecated]
    #[prost(message, repeated, tag = "3")]
    pub string_table: ::prost::alloc::vec::Vec<ChromeStringTableEntry>,
}
/// Information about a specific trigger during a background tracing scenario
/// Associated packet timestamps are useful to delimitate a scenario range in a
/// trace. Triggers are also useful for filtering traces.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeTrigger {
    /// Name of the trigger which was received.
    #[prost(string, optional, tag = "1")]
    pub trigger_name: ::core::option::Option<::prost::alloc::string::String>,
    /// SHA1 hash of the trigger name.
    #[prost(fixed32, optional, tag = "2")]
    pub trigger_name_hash: ::core::option::Option<u32>,
}
/// Strings used by V8 can have different encodings, instead of coverting to a
/// common encoding (e.g. UTF-8) on device is expensive. Instead we send the
/// "raw" string and do the convestion at trace ingestion time.
///
/// ATTENTION: There is some overhead in using a message (as opossed to having
/// the `oneof encoded_string`` direcly embedded in the message), so use this
/// message in places were these extra bytes don't matter that much.
/// Next id: 5
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V8String {
    #[prost(oneof = "v8_string::EncodedString", tags = "1, 2, 3")]
    pub encoded_string: ::core::option::Option<v8_string::EncodedString>,
}
/// Nested message and enum types in `V8String`.
pub mod v8_string {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EncodedString {
        /// ISO/IEC 8859-1:1998 encoding aka latin1
        /// <https://en.wikipedia.org/wiki/ISO/IEC_8859-1>
        #[prost(bytes, tag = "1")]
        Latin1(::prost::alloc::vec::Vec<u8>),
        /// UTF-16 Little Endian Encoding
        #[prost(bytes, tag = "2")]
        Utf16Le(::prost::alloc::vec::Vec<u8>),
        /// UTF-16 Big Endian Encoding
        #[prost(bytes, tag = "3")]
        Utf16Be(::prost::alloc::vec::Vec<u8>),
    }
}
/// Interned version of V8String
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternedV8String {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    /// We inline the fields in V8String here to save some bytes in the serialized
    /// proto format. Interning is about saving bytes so this makes sense here.
    #[prost(oneof = "interned_v8_string::EncodedString", tags = "2, 3, 4")]
    pub encoded_string: ::core::option::Option<interned_v8_string::EncodedString>,
}
/// Nested message and enum types in `InternedV8String`.
pub mod interned_v8_string {
    /// We inline the fields in V8String here to save some bytes in the serialized
    /// proto format. Interning is about saving bytes so this makes sense here.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EncodedString {
        /// ISO/IEC 8859-1:1998 encoding aka latin1
        /// <https://en.wikipedia.org/wiki/ISO/IEC_8859-1>
        #[prost(bytes, tag = "2")]
        Latin1(::prost::alloc::vec::Vec<u8>),
        /// UTF-16 Little Endian Encoding
        #[prost(bytes, tag = "3")]
        Utf16Le(::prost::alloc::vec::Vec<u8>),
        /// UTF-16 Big Endian Encoding
        #[prost(bytes, tag = "4")]
        Utf16Be(::prost::alloc::vec::Vec<u8>),
    }
}
/// Represents a script that was compiled to generate code. Some V8 code is
/// generated out of scripts and will reference a V8Script other types of code
/// will not (e.g. builtins).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternedV8JsScript {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    /// Unique in a given isolate
    #[prost(int32, optional, tag = "2")]
    pub script_id: ::core::option::Option<i32>,
    #[prost(enumeration = "interned_v8_js_script::Type", optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<V8String>,
    /// Actual source of the script
    #[prost(message, optional, tag = "5")]
    pub source: ::core::option::Option<V8String>,
}
/// Nested message and enum types in `InternedV8JsScript`.
pub mod interned_v8_js_script {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Normal = 1,
        Eval = 2,
        Module = 3,
        Native = 4,
        Extension = 5,
        Inspector = 6,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_UNKNOWN",
                Self::Normal => "TYPE_NORMAL",
                Self::Eval => "TYPE_EVAL",
                Self::Module => "TYPE_MODULE",
                Self::Native => "TYPE_NATIVE",
                Self::Extension => "TYPE_EXTENSION",
                Self::Inspector => "TYPE_INSPECTOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TYPE_NORMAL" => Some(Self::Normal),
                "TYPE_EVAL" => Some(Self::Eval),
                "TYPE_MODULE" => Some(Self::Module),
                "TYPE_NATIVE" => Some(Self::Native),
                "TYPE_EXTENSION" => Some(Self::Extension),
                "TYPE_INSPECTOR" => Some(Self::Inspector),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternedV8WasmScript {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    /// Unique in a given isolate
    #[prost(int32, optional, tag = "2")]
    pub script_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternedV8JsFunction {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub v8_js_function_name_iid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub v8_js_script_iid: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "4")]
    pub is_toplevel: ::core::option::Option<bool>,
    #[prost(enumeration = "interned_v8_js_function::Kind", optional, tag = "5")]
    pub kind: ::core::option::Option<i32>,
    /// Where in the script source this function is defined. This is counted in
    /// bytes not characters.
    #[prost(uint32, optional, tag = "6")]
    pub byte_offset: ::core::option::Option<u32>,
}
/// Nested message and enum types in `InternedV8JsFunction`.
pub mod interned_v8_js_function {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unknown = 0,
        NormalFunction = 1,
        Module = 2,
        AsyncModule = 3,
        BaseConstructor = 4,
        DefaultBaseConstructor = 5,
        DefaultDerivedConstructor = 6,
        DerivedConstructor = 7,
        GetterFunction = 8,
        StaticGetterFunction = 9,
        SetterFunction = 10,
        StaticSetterFunction = 11,
        ArrowFunction = 12,
        AsyncArrowFunction = 13,
        AsyncFunction = 14,
        AsyncConciseMethod = 15,
        StaticAsyncConciseMethod = 16,
        AsyncConciseGeneratorMethod = 17,
        StaticAsyncConciseGeneratorMethod = 18,
        AsyncGeneratorFunction = 19,
        GeneratorFunction = 20,
        ConciseGeneratorMethod = 21,
        StaticConciseGeneratorMethod = 22,
        ConciseMethod = 23,
        StaticConciseMethod = 24,
        ClassMembersInitializerFunction = 25,
        ClassStaticInitializerFunction = 26,
        Invalid = 27,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "KIND_UNKNOWN",
                Self::NormalFunction => "KIND_NORMAL_FUNCTION",
                Self::Module => "KIND_MODULE",
                Self::AsyncModule => "KIND_ASYNC_MODULE",
                Self::BaseConstructor => "KIND_BASE_CONSTRUCTOR",
                Self::DefaultBaseConstructor => "KIND_DEFAULT_BASE_CONSTRUCTOR",
                Self::DefaultDerivedConstructor => "KIND_DEFAULT_DERIVED_CONSTRUCTOR",
                Self::DerivedConstructor => "KIND_DERIVED_CONSTRUCTOR",
                Self::GetterFunction => "KIND_GETTER_FUNCTION",
                Self::StaticGetterFunction => "KIND_STATIC_GETTER_FUNCTION",
                Self::SetterFunction => "KIND_SETTER_FUNCTION",
                Self::StaticSetterFunction => "KIND_STATIC_SETTER_FUNCTION",
                Self::ArrowFunction => "KIND_ARROW_FUNCTION",
                Self::AsyncArrowFunction => "KIND_ASYNC_ARROW_FUNCTION",
                Self::AsyncFunction => "KIND_ASYNC_FUNCTION",
                Self::AsyncConciseMethod => "KIND_ASYNC_CONCISE_METHOD",
                Self::StaticAsyncConciseMethod => "KIND_STATIC_ASYNC_CONCISE_METHOD",
                Self::AsyncConciseGeneratorMethod => {
                    "KIND_ASYNC_CONCISE_GENERATOR_METHOD"
                }
                Self::StaticAsyncConciseGeneratorMethod => {
                    "KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD"
                }
                Self::AsyncGeneratorFunction => "KIND_ASYNC_GENERATOR_FUNCTION",
                Self::GeneratorFunction => "KIND_GENERATOR_FUNCTION",
                Self::ConciseGeneratorMethod => "KIND_CONCISE_GENERATOR_METHOD",
                Self::StaticConciseGeneratorMethod => {
                    "KIND_STATIC_CONCISE_GENERATOR_METHOD"
                }
                Self::ConciseMethod => "KIND_CONCISE_METHOD",
                Self::StaticConciseMethod => "KIND_STATIC_CONCISE_METHOD",
                Self::ClassMembersInitializerFunction => {
                    "KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION"
                }
                Self::ClassStaticInitializerFunction => {
                    "KIND_CLASS_STATIC_INITIALIZER_FUNCTION"
                }
                Self::Invalid => "KIND_INVALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNKNOWN" => Some(Self::Unknown),
                "KIND_NORMAL_FUNCTION" => Some(Self::NormalFunction),
                "KIND_MODULE" => Some(Self::Module),
                "KIND_ASYNC_MODULE" => Some(Self::AsyncModule),
                "KIND_BASE_CONSTRUCTOR" => Some(Self::BaseConstructor),
                "KIND_DEFAULT_BASE_CONSTRUCTOR" => Some(Self::DefaultBaseConstructor),
                "KIND_DEFAULT_DERIVED_CONSTRUCTOR" => {
                    Some(Self::DefaultDerivedConstructor)
                }
                "KIND_DERIVED_CONSTRUCTOR" => Some(Self::DerivedConstructor),
                "KIND_GETTER_FUNCTION" => Some(Self::GetterFunction),
                "KIND_STATIC_GETTER_FUNCTION" => Some(Self::StaticGetterFunction),
                "KIND_SETTER_FUNCTION" => Some(Self::SetterFunction),
                "KIND_STATIC_SETTER_FUNCTION" => Some(Self::StaticSetterFunction),
                "KIND_ARROW_FUNCTION" => Some(Self::ArrowFunction),
                "KIND_ASYNC_ARROW_FUNCTION" => Some(Self::AsyncArrowFunction),
                "KIND_ASYNC_FUNCTION" => Some(Self::AsyncFunction),
                "KIND_ASYNC_CONCISE_METHOD" => Some(Self::AsyncConciseMethod),
                "KIND_STATIC_ASYNC_CONCISE_METHOD" => {
                    Some(Self::StaticAsyncConciseMethod)
                }
                "KIND_ASYNC_CONCISE_GENERATOR_METHOD" => {
                    Some(Self::AsyncConciseGeneratorMethod)
                }
                "KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD" => {
                    Some(Self::StaticAsyncConciseGeneratorMethod)
                }
                "KIND_ASYNC_GENERATOR_FUNCTION" => Some(Self::AsyncGeneratorFunction),
                "KIND_GENERATOR_FUNCTION" => Some(Self::GeneratorFunction),
                "KIND_CONCISE_GENERATOR_METHOD" => Some(Self::ConciseGeneratorMethod),
                "KIND_STATIC_CONCISE_GENERATOR_METHOD" => {
                    Some(Self::StaticConciseGeneratorMethod)
                }
                "KIND_CONCISE_METHOD" => Some(Self::ConciseMethod),
                "KIND_STATIC_CONCISE_METHOD" => Some(Self::StaticConciseMethod),
                "KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION" => {
                    Some(Self::ClassMembersInitializerFunction)
                }
                "KIND_CLASS_STATIC_INITIALIZER_FUNCTION" => {
                    Some(Self::ClassStaticInitializerFunction)
                }
                "KIND_INVALID" => Some(Self::Invalid),
                _ => None,
            }
        }
    }
}
/// A V8 Isolate instance. A V8 Isolate represents an isolated instance of the V8
/// engine.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternedV8Isolate {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    /// Process unique isolate id.
    #[prost(int32, optional, tag = "3")]
    pub isolate_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub code_range: ::core::option::Option<interned_v8_isolate::CodeRange>,
    /// The embedded blob holds code for built in functions that are precompiled in
    /// the V8 library.
    #[prost(uint64, optional, tag = "5")]
    pub embedded_blob_code_start_address: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub embedded_blob_code_size: ::core::option::Option<u64>,
}
/// Nested message and enum types in `InternedV8Isolate`.
pub mod interned_v8_isolate {
    /// A code range is a virtual memory cage that may contain executable code.
    /// Depending on the Isolate settings the Isolate might have one or not.
    /// See:
    /// <https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/code-range.h>
    /// If the isolate defines code range this will be tracked here.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CodeRange {
        #[prost(uint64, optional, tag = "1")]
        pub base_address: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "2")]
        pub size: ::core::option::Option<u64>,
        /// Used when short builtin calls are enabled, where embedded builtins are
        /// copied into the CodeRange so calls can be nearer.
        #[prost(uint64, optional, tag = "3")]
        pub embedded_blob_code_copy_start_address: ::core::option::Option<u64>,
        /// Whether this code range is shared with other Isolates in the same process
        #[prost(bool, optional, tag = "4")]
        pub is_process_wide: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V8JsCode {
    #[prost(uint64, optional, tag = "1")]
    pub v8_isolate_iid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub tid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub v8_js_function_iid: ::core::option::Option<u64>,
    #[prost(enumeration = "v8_js_code::Tier", optional, tag = "4")]
    pub tier: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub instruction_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub instruction_size_bytes: ::core::option::Option<u64>,
    #[prost(oneof = "v8_js_code::Instructions", tags = "7, 8")]
    pub instructions: ::core::option::Option<v8_js_code::Instructions>,
}
/// Nested message and enum types in `V8JsCode`.
pub mod v8_js_code {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tier {
        Unknown = 0,
        Ignition = 1,
        Sparkplug = 2,
        Maglev = 3,
        Turboshaft = 4,
        Turbofan = 5,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TIER_UNKNOWN",
                Self::Ignition => "TIER_IGNITION",
                Self::Sparkplug => "TIER_SPARKPLUG",
                Self::Maglev => "TIER_MAGLEV",
                Self::Turboshaft => "TIER_TURBOSHAFT",
                Self::Turbofan => "TIER_TURBOFAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNKNOWN" => Some(Self::Unknown),
                "TIER_IGNITION" => Some(Self::Ignition),
                "TIER_SPARKPLUG" => Some(Self::Sparkplug),
                "TIER_MAGLEV" => Some(Self::Maglev),
                "TIER_TURBOSHAFT" => Some(Self::Turboshaft),
                "TIER_TURBOFAN" => Some(Self::Turbofan),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Instructions {
        #[prost(bytes, tag = "7")]
        MachineCode(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "8")]
        Bytecode(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V8InternalCode {
    #[prost(uint64, optional, tag = "1")]
    pub v8_isolate_iid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub tid: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "v8_internal_code::Type", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub builtin_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    pub instruction_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub instruction_size_bytes: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub machine_code: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `V8InternalCode`.
pub mod v8_internal_code {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        BytecodeHandler = 1,
        ForTesting = 2,
        Builtin = 3,
        WasmFunction = 4,
        WasmToCapiFunction = 5,
        WasmToJsFunction = 6,
        JsToWasmFunction = 7,
        JsToJsFunction = 8,
        CWasmEntry = 9,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_UNKNOWN",
                Self::BytecodeHandler => "TYPE_BYTECODE_HANDLER",
                Self::ForTesting => "TYPE_FOR_TESTING",
                Self::Builtin => "TYPE_BUILTIN",
                Self::WasmFunction => "TYPE_WASM_FUNCTION",
                Self::WasmToCapiFunction => "TYPE_WASM_TO_CAPI_FUNCTION",
                Self::WasmToJsFunction => "TYPE_WASM_TO_JS_FUNCTION",
                Self::JsToWasmFunction => "TYPE_JS_TO_WASM_FUNCTION",
                Self::JsToJsFunction => "TYPE_JS_TO_JS_FUNCTION",
                Self::CWasmEntry => "TYPE_C_WASM_ENTRY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TYPE_BYTECODE_HANDLER" => Some(Self::BytecodeHandler),
                "TYPE_FOR_TESTING" => Some(Self::ForTesting),
                "TYPE_BUILTIN" => Some(Self::Builtin),
                "TYPE_WASM_FUNCTION" => Some(Self::WasmFunction),
                "TYPE_WASM_TO_CAPI_FUNCTION" => Some(Self::WasmToCapiFunction),
                "TYPE_WASM_TO_JS_FUNCTION" => Some(Self::WasmToJsFunction),
                "TYPE_JS_TO_WASM_FUNCTION" => Some(Self::JsToWasmFunction),
                "TYPE_JS_TO_JS_FUNCTION" => Some(Self::JsToJsFunction),
                "TYPE_C_WASM_ENTRY" => Some(Self::CWasmEntry),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V8WasmCode {
    #[prost(uint64, optional, tag = "1")]
    pub v8_isolate_iid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub tid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub v8_wasm_script_iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "v8_wasm_code::Tier", optional, tag = "5")]
    pub tier: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub code_offset_in_module: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "7")]
    pub instruction_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub instruction_size_bytes: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "9")]
    pub machine_code: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `V8WasmCode`.
pub mod v8_wasm_code {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tier {
        Unknown = 0,
        Liftoff = 1,
        Turbofan = 2,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TIER_UNKNOWN",
                Self::Liftoff => "TIER_LIFTOFF",
                Self::Turbofan => "TIER_TURBOFAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNKNOWN" => Some(Self::Unknown),
                "TIER_LIFTOFF" => Some(Self::Liftoff),
                "TIER_TURBOFAN" => Some(Self::Turbofan),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V8RegExpCode {
    #[prost(uint64, optional, tag = "1")]
    pub v8_isolate_iid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub tid: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub pattern: ::core::option::Option<V8String>,
    #[prost(uint64, optional, tag = "4")]
    pub instruction_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub instruction_size_bytes: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub machine_code: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Move event for V8 code (JS / Wasm / Internal / Regexp) that was relocated in
/// memory by V8's GC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct V8CodeMove {
    #[prost(uint64, optional, tag = "1")]
    pub isolate_iid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub tid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub from_instruction_start_address: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub to_instruction_start_address: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub instruction_size_bytes: ::core::option::Option<u64>,
    #[prost(oneof = "v8_code_move::ToInstructions", tags = "6, 7")]
    pub to_instructions: ::core::option::Option<v8_code_move::ToInstructions>,
}
/// Nested message and enum types in `V8CodeMove`.
pub mod v8_code_move {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ToInstructions {
        #[prost(bytes, tag = "6")]
        ToMachineCode(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "7")]
        ToBytecode(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct V8CodeDefaults {
    #[prost(uint32, optional, tag = "1")]
    pub tid: ::core::option::Option<u32>,
}
/// A snapshot of clock readings to allow for trace alignment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockSnapshot {
    #[prost(message, repeated, tag = "1")]
    pub clocks: ::prost::alloc::vec::Vec<clock_snapshot::Clock>,
    /// The authoritative clock domain for the trace. Defaults to BOOTTIME, but can
    /// be overridden in TraceConfig's builtin_data_sources. Trace processor will
    /// attempt to translate packet/event timestamps from various data sources (and
    /// their chosen clock domains) to this domain during import.
    #[prost(enumeration = "BuiltinClock", optional, tag = "2")]
    pub primary_trace_clock: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ClockSnapshot`.
pub mod clock_snapshot {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Clock {
        /// Clock IDs have the following semantic:
        /// \[1, 63\]:    Builtin types, see BuiltinClock from
        ///              ../common/builtin_clock.proto.
        /// \[64, 127\]:  User-defined clocks. These clocks are sequence-scoped. They
        ///              are only valid within the same |trusted_packet_sequence_id|
        ///              (i.e. only for TracePacket(s) emitted by the same TraceWriter
        ///              that emitted the clock snapshot).
        /// \[128, MAX\]: Reserved for future use. The idea is to allow global clock
        ///              IDs and setting this ID to hash(full_clock_name) & ~127.
        #[prost(uint32, optional, tag = "1")]
        pub clock_id: ::core::option::Option<u32>,
        /// Absolute timestamp. Unit is ns unless specified otherwise by the
        /// unit_multiplier_ns field below.
        #[prost(uint64, optional, tag = "2")]
        pub timestamp: ::core::option::Option<u64>,
        /// When true each TracePacket's timestamp should be interpreted as a delta
        /// from the last TracePacket's timestamp (referencing this clock) emitted by
        /// the same packet_sequence_id. Should only be used for user-defined
        /// sequence-local clocks. The first packet timestamp after each
        /// ClockSnapshot that contains this clock is relative to the |timestamp| in
        /// the ClockSnapshot.
        #[prost(bool, optional, tag = "3")]
        pub is_incremental: ::core::option::Option<bool>,
        /// Allows to specify a custom unit different than the default (ns) for this
        /// clock domain. A multiplier of 1000 means that a timestamp = 3 should be
        /// interpreted as 3000 ns = 3 us. All snapshots for the same clock within a
        /// trace need to use the same unit.
        #[prost(uint64, optional, tag = "4")]
        pub unit_multiplier_ns: ::core::option::Option<u64>,
    }
    /// Nested message and enum types in `Clock`.
    pub mod clock {
        /// DEPRECATED. This enum has moved to ../common/builtin_clock.proto.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BuiltinClocks {
            Unknown = 0,
            Realtime = 1,
            RealtimeCoarse = 2,
            Monotonic = 3,
            MonotonicCoarse = 4,
            MonotonicRaw = 5,
            Boottime = 6,
            BuiltinClockMaxId = 63,
        }
        impl BuiltinClocks {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Realtime => "REALTIME",
                    Self::RealtimeCoarse => "REALTIME_COARSE",
                    Self::Monotonic => "MONOTONIC",
                    Self::MonotonicCoarse => "MONOTONIC_COARSE",
                    Self::MonotonicRaw => "MONOTONIC_RAW",
                    Self::Boottime => "BOOTTIME",
                    Self::BuiltinClockMaxId => "BUILTIN_CLOCK_MAX_ID",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "REALTIME" => Some(Self::Realtime),
                    "REALTIME_COARSE" => Some(Self::RealtimeCoarse),
                    "MONOTONIC" => Some(Self::Monotonic),
                    "MONOTONIC_COARSE" => Some(Self::MonotonicCoarse),
                    "MONOTONIC_RAW" => Some(Self::MonotonicRaw),
                    "BOOTTIME" => Some(Self::Boottime),
                    "BUILTIN_CLOCK_MAX_ID" => Some(Self::BuiltinClockMaxId),
                    _ => None,
                }
            }
        }
    }
}
/// Proto definition based on the Thread_v2 CSwitch class definition
/// See: <https://learn.microsoft.com/en-us/windows/win32/etw/cswitch>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSwitchEtwEvent {
    /// New thread ID after the switch.
    #[prost(uint32, optional, tag = "1")]
    pub new_thread_id: ::core::option::Option<u32>,
    /// Previous thread ID.
    #[prost(uint32, optional, tag = "2")]
    pub old_thread_id: ::core::option::Option<u32>,
    /// Thread priority of the new thread.
    #[prost(sint32, optional, tag = "3")]
    pub new_thread_priority: ::core::option::Option<i32>,
    /// Thread priority of the previous thread.
    #[prost(sint32, optional, tag = "4")]
    pub old_thread_priority: ::core::option::Option<i32>,
    /// The index of the C-state that was last used by the processor. A value of 0
    /// represents the lightest idle state with higher values representing deeper
    /// C-states.
    #[prost(uint32, optional, tag = "5")]
    pub previous_c_state: ::core::option::Option<u32>,
    #[prost(
        enumeration = "c_switch_etw_event::OldThreadWaitReason",
        optional,
        tag = "6"
    )]
    pub old_thread_wait_reason: ::core::option::Option<i32>,
    #[prost(enumeration = "c_switch_etw_event::OldThreadWaitMode", optional, tag = "7")]
    pub old_thread_wait_mode: ::core::option::Option<i32>,
    #[prost(enumeration = "c_switch_etw_event::OldThreadState", optional, tag = "8")]
    pub old_thread_state: ::core::option::Option<i32>,
    /// Ideal wait time of the previous thread.
    #[prost(sint32, optional, tag = "9")]
    pub old_thread_wait_ideal_processor: ::core::option::Option<i32>,
    /// Wait time for the new thread.
    #[prost(uint32, optional, tag = "10")]
    pub new_thread_wait_time: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CSwitchEtwEvent`.
pub mod c_switch_etw_event {
    /// Wait reason for the previous thread. The ordering is important as based on
    /// the OldThreadWaitReason definition from the link above. The following are
    /// the possible values:
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OldThreadWaitReason {
        Executive = 0,
        FreePage = 1,
        PageIn = 2,
        PoolAllocation = 3,
        DelayExecution = 4,
        Suspend = 5,
        UserRequest = 6,
        WrExecutive = 7,
        WrFreePage = 8,
        WrPageIn = 9,
        WrPoolAllocation = 10,
        WrDelayExecution = 11,
        WrSuspended = 12,
        WrUserRequest = 13,
        WrEventPair = 14,
        WrQueue = 15,
        WrLpcReceiver = 16,
        WrLpcReply = 17,
        WrVirtualMemory = 18,
        WrPageOut = 19,
        WrRendezVous = 20,
        WrKeyedEvent = 21,
        WrTerminated = 22,
        WrProcessInSwap = 23,
        WrCpuRateControl = 24,
        WrCalloutStack = 25,
        WrKernel = 26,
        WrResource = 27,
        WrPushLock = 28,
        WrMutex = 29,
        WrQuantumEnd = 30,
        WrDispatchInt = 31,
        WrPreempted = 32,
        WrYieldExecution = 33,
        WrFastMutex = 34,
        WrGuardMutex = 35,
        WrRundown = 36,
        MaximumWaitReason = 37,
    }
    impl OldThreadWaitReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Executive => "EXECUTIVE",
                Self::FreePage => "FREE_PAGE",
                Self::PageIn => "PAGE_IN",
                Self::PoolAllocation => "POOL_ALLOCATION",
                Self::DelayExecution => "DELAY_EXECUTION",
                Self::Suspend => "SUSPEND",
                Self::UserRequest => "USER_REQUEST",
                Self::WrExecutive => "WR_EXECUTIVE",
                Self::WrFreePage => "WR_FREE_PAGE",
                Self::WrPageIn => "WR_PAGE_IN",
                Self::WrPoolAllocation => "WR_POOL_ALLOCATION",
                Self::WrDelayExecution => "WR_DELAY_EXECUTION",
                Self::WrSuspended => "WR_SUSPENDED",
                Self::WrUserRequest => "WR_USER_REQUEST",
                Self::WrEventPair => "WR_EVENT_PAIR",
                Self::WrQueue => "WR_QUEUE",
                Self::WrLpcReceiver => "WR_LPC_RECEIVER",
                Self::WrLpcReply => "WR_LPC_REPLY",
                Self::WrVirtualMemory => "WR_VIRTUAL_MEMORY",
                Self::WrPageOut => "WR_PAGE_OUT",
                Self::WrRendezVous => "WR_RENDEZ_VOUS",
                Self::WrKeyedEvent => "WR_KEYED_EVENT",
                Self::WrTerminated => "WR_TERMINATED",
                Self::WrProcessInSwap => "WR_PROCESS_IN_SWAP",
                Self::WrCpuRateControl => "WR_CPU_RATE_CONTROL",
                Self::WrCalloutStack => "WR_CALLOUT_STACK",
                Self::WrKernel => "WR_KERNEL",
                Self::WrResource => "WR_RESOURCE",
                Self::WrPushLock => "WR_PUSH_LOCK",
                Self::WrMutex => "WR_MUTEX",
                Self::WrQuantumEnd => "WR_QUANTUM_END",
                Self::WrDispatchInt => "WR_DISPATCH_INT",
                Self::WrPreempted => "WR_PREEMPTED",
                Self::WrYieldExecution => "WR_YIELD_EXECUTION",
                Self::WrFastMutex => "WR_FAST_MUTEX",
                Self::WrGuardMutex => "WR_GUARD_MUTEX",
                Self::WrRundown => "WR_RUNDOWN",
                Self::MaximumWaitReason => "MAXIMUM_WAIT_REASON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTIVE" => Some(Self::Executive),
                "FREE_PAGE" => Some(Self::FreePage),
                "PAGE_IN" => Some(Self::PageIn),
                "POOL_ALLOCATION" => Some(Self::PoolAllocation),
                "DELAY_EXECUTION" => Some(Self::DelayExecution),
                "SUSPEND" => Some(Self::Suspend),
                "USER_REQUEST" => Some(Self::UserRequest),
                "WR_EXECUTIVE" => Some(Self::WrExecutive),
                "WR_FREE_PAGE" => Some(Self::WrFreePage),
                "WR_PAGE_IN" => Some(Self::WrPageIn),
                "WR_POOL_ALLOCATION" => Some(Self::WrPoolAllocation),
                "WR_DELAY_EXECUTION" => Some(Self::WrDelayExecution),
                "WR_SUSPENDED" => Some(Self::WrSuspended),
                "WR_USER_REQUEST" => Some(Self::WrUserRequest),
                "WR_EVENT_PAIR" => Some(Self::WrEventPair),
                "WR_QUEUE" => Some(Self::WrQueue),
                "WR_LPC_RECEIVER" => Some(Self::WrLpcReceiver),
                "WR_LPC_REPLY" => Some(Self::WrLpcReply),
                "WR_VIRTUAL_MEMORY" => Some(Self::WrVirtualMemory),
                "WR_PAGE_OUT" => Some(Self::WrPageOut),
                "WR_RENDEZ_VOUS" => Some(Self::WrRendezVous),
                "WR_KEYED_EVENT" => Some(Self::WrKeyedEvent),
                "WR_TERMINATED" => Some(Self::WrTerminated),
                "WR_PROCESS_IN_SWAP" => Some(Self::WrProcessInSwap),
                "WR_CPU_RATE_CONTROL" => Some(Self::WrCpuRateControl),
                "WR_CALLOUT_STACK" => Some(Self::WrCalloutStack),
                "WR_KERNEL" => Some(Self::WrKernel),
                "WR_RESOURCE" => Some(Self::WrResource),
                "WR_PUSH_LOCK" => Some(Self::WrPushLock),
                "WR_MUTEX" => Some(Self::WrMutex),
                "WR_QUANTUM_END" => Some(Self::WrQuantumEnd),
                "WR_DISPATCH_INT" => Some(Self::WrDispatchInt),
                "WR_PREEMPTED" => Some(Self::WrPreempted),
                "WR_YIELD_EXECUTION" => Some(Self::WrYieldExecution),
                "WR_FAST_MUTEX" => Some(Self::WrFastMutex),
                "WR_GUARD_MUTEX" => Some(Self::WrGuardMutex),
                "WR_RUNDOWN" => Some(Self::WrRundown),
                "MAXIMUM_WAIT_REASON" => Some(Self::MaximumWaitReason),
                _ => None,
            }
        }
    }
    /// Wait mode for the previous thread. The ordering is important as based on
    /// the OldThreadWaitMode definition from the link above. The following are the
    /// possible values:
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OldThreadWaitMode {
        KernelMode = 0,
        UserMode = 1,
    }
    impl OldThreadWaitMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::KernelMode => "KERNEL_MODE",
                Self::UserMode => "USER_MODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KERNEL_MODE" => Some(Self::KernelMode),
                "USER_MODE" => Some(Self::UserMode),
                _ => None,
            }
        }
    }
    /// State of the previous thread. The ordering is important as based on the
    /// OldThreadState definition from the link above. The following are the
    /// possible state values:
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OldThreadState {
        Initialized = 0,
        Ready = 1,
        Running = 2,
        Standby = 3,
        Terminated = 4,
        Waiting = 5,
        Transition = 6,
        DeferredReady = 7,
    }
    impl OldThreadState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Initialized => "INITIALIZED",
                Self::Ready => "READY",
                Self::Running => "RUNNING",
                Self::Standby => "STANDBY",
                Self::Terminated => "TERMINATED",
                Self::Waiting => "WAITING",
                Self::Transition => "TRANSITION",
                Self::DeferredReady => "DEFERRED_READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INITIALIZED" => Some(Self::Initialized),
                "READY" => Some(Self::Ready),
                "RUNNING" => Some(Self::Running),
                "STANDBY" => Some(Self::Standby),
                "TERMINATED" => Some(Self::Terminated),
                "WAITING" => Some(Self::Waiting),
                "TRANSITION" => Some(Self::Transition),
                "DEFERRED_READY" => Some(Self::DeferredReady),
                _ => None,
            }
        }
    }
}
/// Proto definition based on the Thread_v2 CSwitch class definition
/// See: <https://learn.microsoft.com/en-us/windows/win32/etw/readythread>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadyThreadEtwEvent {
    /// The thread identifier of the thread being readied for execution.
    #[prost(uint32, optional, tag = "1")]
    pub t_thread_id: ::core::option::Option<u32>,
    #[prost(enumeration = "ready_thread_etw_event::AdjustReason", optional, tag = "2")]
    pub adjust_reason: ::core::option::Option<i32>,
    ///   The value by which the priority is being adjusted.
    #[prost(sint32, optional, tag = "3")]
    pub adjust_increment: ::core::option::Option<i32>,
    #[prost(enumeration = "ready_thread_etw_event::TraceFlag", optional, tag = "4")]
    pub flag: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ReadyThreadEtwEvent`.
pub mod ready_thread_etw_event {
    /// The reason for the priority boost. The ordering is important as based on
    /// the AdjustReason definition from the link above.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdjustReason {
        IgnoreTheIncrement = 0,
        /// Apply the increment, which will decay incrementally at the end of each
        /// quantum.
        ApplyIncrement = 1,
        /// Apply the increment as a boost that will decay in its entirety at quantum
        /// (typically for priority donation).
        ApplyIncrementBoost = 2,
    }
    impl AdjustReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::IgnoreTheIncrement => "IGNORE_THE_INCREMENT",
                Self::ApplyIncrement => "APPLY_INCREMENT",
                Self::ApplyIncrementBoost => "APPLY_INCREMENT_BOOST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IGNORE_THE_INCREMENT" => Some(Self::IgnoreTheIncrement),
                "APPLY_INCREMENT" => Some(Self::ApplyIncrement),
                "APPLY_INCREMENT_BOOST" => Some(Self::ApplyIncrementBoost),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TraceFlag {
        Unspecified = 0,
        /// The thread has been readied from DPC (deferred procedure call).
        ThreadReadied = 1,
        /// The kernel stack is currently swapped out.
        KernelStackSwappedOut = 2,
        /// The process address space is swapped out.
        ProcessAddressSwappedOut = 4,
    }
    impl TraceFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRACE_FLAG_UNSPECIFIED",
                Self::ThreadReadied => "THREAD_READIED",
                Self::KernelStackSwappedOut => "KERNEL_STACK_SWAPPED_OUT",
                Self::ProcessAddressSwappedOut => "PROCESS_ADDRESS_SWAPPED_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRACE_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                "THREAD_READIED" => Some(Self::ThreadReadied),
                "KERNEL_STACK_SWAPPED_OUT" => Some(Self::KernelStackSwappedOut),
                "PROCESS_ADDRESS_SWAPPED_OUT" => Some(Self::ProcessAddressSwappedOut),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtwTraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(oneof = "etw_trace_event::Event", tags = "2, 3")]
    pub event: ::core::option::Option<etw_trace_event::Event>,
}
/// Nested message and enum types in `EtwTraceEvent`.
pub mod etw_trace_event {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "2")]
        CSwitch(super::CSwitchEtwEvent),
        #[prost(message, tag = "3")]
        ReadyThread(super::ReadyThreadEtwEvent),
    }
}
/// The result of tracing one or more etw event uses per-processor buffers where
/// an in-use buffer is assigned to each processor at all times. Therefore,
/// collecting multiple events they should already be synchronized.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtwTraceEventBundle {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub event: ::prost::alloc::vec::Vec<EtwTraceEvent>,
}
/// Represents the mapping between inode numbers in a block device and their path
/// on the filesystem
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InodeFileMap {
    #[prost(uint64, optional, tag = "1")]
    pub block_device_id: ::core::option::Option<u64>,
    /// The mount points of the block device, e.g. \["system"\].
    #[prost(string, repeated, tag = "2")]
    pub mount_points: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The list of all the entries from the block device
    #[prost(message, repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<inode_file_map::Entry>,
}
/// Nested message and enum types in `InodeFileMap`.
pub mod inode_file_map {
    /// Representation of Entry
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint64, optional, tag = "1")]
        pub inode_number: ::core::option::Option<u64>,
        /// The path to the file, e.g. "etc/file.xml"
        /// List of strings for multiple hardlinks
        #[prost(string, repeated, tag = "2")]
        pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(enumeration = "entry::Type", optional, tag = "3")]
        pub r#type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `Entry`.
    pub mod entry {
        /// The file type
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Unknown = 0,
            File = 1,
            Directory = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::File => "FILE",
                    Self::Directory => "DIRECTORY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "FILE" => Some(Self::File),
                    "DIRECTORY" => Some(Self::Directory),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidFsDatareadEndFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub bytes: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidFsDatareadStartFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub bytes: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub cmdline: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub i_size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "5")]
    pub offset: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "6")]
    pub pathbuf: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidFsDatawriteEndFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub bytes: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidFsDatawriteStartFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub bytes: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub cmdline: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub i_size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "5")]
    pub offset: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "6")]
    pub pathbuf: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidFsFsyncEndFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub bytes: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidFsFsyncStartFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub cmdline: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub i_size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "3")]
    pub ino: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub pathbuf: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinderTransactionFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub debug_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_node: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub to_proc: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub to_thread: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub reply: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub code: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinderTransactionReceivedFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub debug_id: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinderSetPriorityFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub proc: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub thread: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub old_prio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub new_prio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub desired_prio: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinderLockFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinderLockedFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinderUnlockFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinderTransactionAllocBufFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub data_size: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub debug_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub offsets_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub extra_buffers_size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinderCommandFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cmd: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinderReturnFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cmd: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRqIssueFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub bytes: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBioBackmergeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBioBounceFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBioCompleteFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBioFrontmergeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBioQueueFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBioRemapFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub old_dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub old_sector: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "6")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlockDirtyBufferFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockGetrqFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockPlugFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRqAbortFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub errors: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRqCompleteFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub errors: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub error: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRqInsertFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub bytes: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRqRemapFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub old_dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub old_sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub nr_bios: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "7")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRqRequeueFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub errors: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockSleeprqFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nr_sector: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockSplitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub new_sector: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub rwbs: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlockTouchBufferFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockUnplugFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nr_rq: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupAttachTaskFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub dst_root: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub dst_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub cname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "6")]
    pub dst_level: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    pub dst_path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupMkdirFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub cname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub level: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupRemountFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub ss_mask: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupRmdirFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub cname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub level: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupTransferTasksFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub dst_root: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub dst_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub cname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "6")]
    pub dst_level: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    pub dst_path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupDestroyRootFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub ss_mask: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupReleaseFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub cname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub level: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupRenameFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub cname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub level: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupSetupRootFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub root: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub ss_mask: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClkEnableFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClkDisableFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClkSetRateFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub rate: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmaAllocStartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub align: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub count: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmaAllocInfoFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub align: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub err_iso: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub err_mig: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub err_test: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "7")]
    pub nr_mapped: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub nr_migrated: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub nr_reclaimed: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionBeginFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub zone_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub migrate_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub free_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub zone_end: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub sync: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionDeferCompactionFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub idx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub considered: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub defer_shift: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub order_failed: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionDeferredFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub idx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub considered: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub defer_shift: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub order_failed: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionDeferResetFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub idx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub considered: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub defer_shift: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub order_failed: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub zone_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub migrate_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub free_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub zone_end: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub sync: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub status: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionFinishedFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub idx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionIsolateFreepagesFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub start_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub end_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub nr_scanned: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub nr_taken: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionIsolateMigratepagesFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub start_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub end_pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub nr_scanned: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub nr_taken: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionKcompactdSleepFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionKcompactdWakeFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub order: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub classzone_idx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub highest_zoneidx: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionMigratepagesFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub nr_migrated: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub nr_failed: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionSuitableFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub idx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionTryToCompactPagesFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub gfp_mask: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub mode: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub prio: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmCompactionWakeupKcompactdFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub order: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub classzone_idx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub highest_zoneidx: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuhpExitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub state: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuhpMultiEnterFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub fun: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub target: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuhpEnterFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub fun: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub target: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuhpLatencyFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub ret: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub state: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub time: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuhpPauseFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub active_cpus: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub cpus: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub pause: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub time: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrosEcSensorhubDataFtraceEvent {
    #[prost(int64, optional, tag = "1")]
    pub current_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub current_timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub delta: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub ec_fifo_timestamp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub ec_sensor_num: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "6")]
    pub fifo_timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DcvshFreqFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub cpu: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub freq: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmaFenceInitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmaFenceEmitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmaFenceSignaledFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmaFenceWaitStartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmaFenceWaitEndFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmaHeapStatFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub inode: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "2")]
    pub len: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "3")]
    pub total_allocated: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DpuTracingMarkWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub trace_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub trace_begin: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "5")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DpuDsiCmdFifoStatusFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub header: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub payload: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DpuDsiRxFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cmd: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub rx_buf: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DpuDsiTxFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub tx_buf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub last: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub delay_ms: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DrmVblankEventFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub crtc: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub high_prec: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub seq: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "4")]
    pub time: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DrmVblankEventDeliveredFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub crtc: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub file: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub seq: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaWriteBeginFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaWriteEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub copied: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4SyncFileEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub parent: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub datasync: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4SyncFileExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4AllocDaBlocksFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub data_blocks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub meta_blocks: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4AllocateBlocksFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub block: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub logical: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub lleft: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub lright: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub goal: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub pleft: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub pright: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "11")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4AllocateInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub dir: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4BeginOrderedTruncateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub new_size: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4CollapseRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub len: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaReleaseSpaceFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub i_blocks: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub freed_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub reserved_data_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub reserved_meta_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub allocated_meta_blocks: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "8")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaReserveSpaceFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub i_blocks: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub reserved_data_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub reserved_meta_blocks: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub mode: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub md_needed: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaUpdateReserveSpaceFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub i_blocks: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub used_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub reserved_data_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub reserved_meta_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub allocated_meta_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub quota_claim: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaWritePagesFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub first_page: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "4")]
    pub nr_to_write: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub sync_mode: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    pub b_blocknr: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "7")]
    pub b_size: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub b_state: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "9")]
    pub io_done: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub pages_written: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DaWritePagesExtentFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub lblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DirectIoEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub rw: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DirectIoExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub rw: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DiscardBlocksFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub blk: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub count: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DiscardPreallocationsFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub needed: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4DropInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub drop: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsCacheExtentFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub status: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsFindDelayedExtentRangeEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsFindDelayedExtentRangeExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub status: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsInsertExtentFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub status: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsLookupExtentEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsLookupExtentExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub status: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "7")]
    pub found: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsRemoveExtentFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub lblk: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub len: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsShrinkFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub nr_shrunk: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub scan_time: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub nr_skipped: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub retried: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsShrinkCountFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub nr_to_scan: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cache_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsShrinkScanEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub nr_to_scan: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cache_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EsShrinkScanExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub nr_shrunk: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cache_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4EvictInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub nlink: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtConvertToInitializedEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub m_lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub m_len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub u_lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub u_len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub u_pblk: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtConvertToInitializedFastpathFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub m_lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub m_len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub u_lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub u_len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub u_pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "8")]
    pub i_lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub i_len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "10")]
    pub i_pblk: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtHandleUnwrittenExtentsFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub flags: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub allocated: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub newblk: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtInCacheFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtLoadExtentFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub lblk: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtMapBlocksEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtMapBlocksExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub mflags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtPutInCacheFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub start: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtRemoveSpaceFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub end: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub depth: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtRemoveSpaceDoneFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub end: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub depth: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub partial: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "7")]
    pub eh_entries: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub pc_lblk: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "9")]
    pub pc_pclu: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "10")]
    pub pc_state: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtRmIdxFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pblk: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtRmLeafFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub partial: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub ee_lblk: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "6")]
    pub ee_pblk: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "7")]
    pub ee_len: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "8")]
    pub pc_lblk: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "9")]
    pub pc_pclu: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "10")]
    pub pc_state: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ExtShowExtentFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4FallocateEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub len: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub mode: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub pos: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4FallocateExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub blocks: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4FindDelallocRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub from: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub to: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub reverse: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub found: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub found_blk: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ForgetFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub block: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub is_metadata: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4FreeBlocksFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub block: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub count: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub flags: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4FreeInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub uid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub gid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4GetImpliedClusterAllocExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4GetReservedClusterAllocFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4IndMapBlocksEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4IndMapBlocksExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub mflags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4InsertRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub len: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4InvalidatepageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub offset: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub length: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4JournalStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ip: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub rsv_blocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub nblocks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub revoke_creds: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4JournalStartReservedFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ip: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub blocks: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4JournalledInvalidatepageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub offset: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub length: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4JournalledWriteEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub copied: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4LoadInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4LoadInodeBitmapFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub group: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MarkInodeDirtyFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub ip: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbBitmapLoadFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub group: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbBuddyBitmapLoadFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub group: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbDiscardPreallocationsFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub needed: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbNewGroupPaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pa_pstart: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub pa_lstart: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub pa_len: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbNewInodePaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pa_pstart: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub pa_lstart: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub pa_len: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbReleaseGroupPaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub pa_pstart: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub pa_len: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MbReleaseInodePaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub block: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub count: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MballocAllocFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub orig_logical: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub orig_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub orig_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub orig_len: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub goal_logical: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub goal_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub goal_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub goal_len: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "11")]
    pub result_logical: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "12")]
    pub result_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "13")]
    pub result_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "14")]
    pub result_len: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "15")]
    pub found: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub groups: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub buddy: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub tail: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "20")]
    pub cr: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MballocDiscardFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub result_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub result_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub result_len: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MballocFreeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub result_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub result_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub result_len: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4MballocPreallocFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub orig_logical: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub orig_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub orig_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub orig_len: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub result_logical: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub result_start: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub result_group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub result_len: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4OtherInodeUpdateTimeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub orig_ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub uid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub gid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4PunchHoleFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub len: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ReadBlockBitmapLoadFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub group: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub prefetch: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ReadpageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ReleasepageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4RemoveBlocksFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub from: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub to: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "5")]
    pub partial: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "6")]
    pub ee_pblk: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "7")]
    pub ee_lblk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub ee_len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub pc_lblk: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "10")]
    pub pc_pclu: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "11")]
    pub pc_state: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4RequestBlocksFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub logical: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub lleft: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub lright: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub goal: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub pleft: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub pright: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "10")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4RequestInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub dir: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub mode: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4SyncFsFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub wait: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4TrimAllFreeFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub dev_major: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub dev_minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub start: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub len: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4TrimExtentFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub dev_major: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub dev_minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub group: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub start: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub len: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4TruncateEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub blocks: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4TruncateExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub blocks: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4UnlinkEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub parent: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "4")]
    pub size: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4UnlinkExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4WriteBeginFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4WriteEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub copied: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4WritepageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4WritepagesFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub nr_to_write: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub pages_skipped: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub range_start: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub range_end: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "7")]
    pub writeback_index: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "8")]
    pub sync_mode: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub for_kupdate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub range_cyclic: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4WritepagesResultFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub pages_written: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub pages_skipped: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "6")]
    pub writeback_index: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "7")]
    pub sync_mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ext4ZeroRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub len: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsDoSubmitBioFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub btype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub sync: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub sector: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub size: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsEvictInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub mode: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "5")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "6")]
    pub nlink: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "8")]
    pub advise: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsFallocateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub mode: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub len: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "7")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "8")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsGetDataBlockFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub iblock: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub bh_start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub bh_size: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "6")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsGetVictimFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub gc_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub alloc_mode: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub gc_mode: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub victim: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub ofs_unit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub pre_victim: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub prefree: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub free: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub cost: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsIgetFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub mode: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "5")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "6")]
    pub nlink: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "8")]
    pub advise: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsIgetExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsNewInodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsReadpageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub blkaddr: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub dir: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub dirty: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub uptodate: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsReserveNewBlockFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub nid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub ofs_in_node: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsSetPageDirtyFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub dir: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub index: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "6")]
    pub dirty: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub uptodate: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsSubmitWritePageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub index: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub block: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsSyncFileEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub mode: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "5")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "6")]
    pub nlink: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "8")]
    pub advise: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsSyncFileExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub need_cp: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub datasync: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub ret: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub cp_reason: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsSyncFsFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub dirty: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub wait: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub mode: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "5")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "6")]
    pub nlink: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "7")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "8")]
    pub advise: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateBlocksEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub from: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateBlocksExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateDataBlocksRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub ofs: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub free: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateInodeBlocksEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub from: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateInodeBlocksExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateNodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub blk_addr: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateNodesEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub blk_addr: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncateNodesExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsTruncatePartialNodesFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub nid: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub depth: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub err: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct F2fsUnlinkEnterFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "4")]
    pub blocks: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsUnlinkExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsVmPageMkwriteFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub dir: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub index: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "6")]
    pub dirty: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub uptodate: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsWriteBeginFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct F2fsWriteCheckpointFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub is_umount: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub msg: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub reason: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsWriteEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ino: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub pos: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub copied: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsIostatFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub app_bio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub app_brio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub app_dio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub app_drio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub app_mio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub app_mrio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub app_rio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub app_wio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub fs_cdrio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "11")]
    pub fs_cp_dio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub fs_cp_mio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "13")]
    pub fs_cp_nio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "14")]
    pub fs_dio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "15")]
    pub fs_discard: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "16")]
    pub fs_drio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "17")]
    pub fs_gc_dio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "18")]
    pub fs_gc_nio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "19")]
    pub fs_gdrio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "20")]
    pub fs_mio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "21")]
    pub fs_mrio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "22")]
    pub fs_nio: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "23")]
    pub fs_nrio: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsIostatLatencyFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub d_rd_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub d_rd_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub d_rd_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub d_wr_as_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub d_wr_as_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub d_wr_as_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub d_wr_s_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub d_wr_s_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub d_wr_s_peak: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "10")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "11")]
    pub m_rd_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub m_rd_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub m_rd_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub m_wr_as_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub m_wr_as_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub m_wr_as_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub m_wr_s_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub m_wr_s_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub m_wr_s_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "20")]
    pub n_rd_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "21")]
    pub n_rd_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "22")]
    pub n_rd_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "23")]
    pub n_wr_as_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "24")]
    pub n_wr_as_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "25")]
    pub n_wr_as_peak: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "26")]
    pub n_wr_s_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "27")]
    pub n_wr_s_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "28")]
    pub n_wr_s_peak: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsBackgroundGcFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub wait_ms: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub prefree: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub free: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsGcBeginFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub sync: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub background: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "4")]
    pub dirty_nodes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub dirty_dents: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub dirty_imeta: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "7")]
    pub free_sec: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub free_seg: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "9")]
    pub reserved_seg: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "10")]
    pub prefree_seg: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "11")]
    pub gc_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "12")]
    pub no_bg_gc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub nr_free_secs: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct F2fsGcEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub dev: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub ret: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub seg_freed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub sec_freed: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub dirty_nodes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub dirty_dents: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub dirty_imeta: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "8")]
    pub free_sec: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub free_seg: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub reserved_seg: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "11")]
    pub prefree_seg: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FastrpcDmaStatFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub cid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub len: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "3")]
    pub total_allocated: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FastrpcDmaFreeFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub cid: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub phys: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FastrpcDmaAllocFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub cid: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub phys: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub attr: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub mflags: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FastrpcDmaUnmapFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub cid: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub phys: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FastrpcDmaMapFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub cid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub fd: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub phys: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub attr: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub mflags: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FenceInitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FenceDestroyFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FenceEnableSignalFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FenceSignaledFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub context: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmFilemapAddToPageCacheFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub i_ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub s_dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub page: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmFilemapDeleteFromPageCacheFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub pfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub i_ino: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub index: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub s_dev: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub page: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrintFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ip: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub buf: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FuncgraphEntryFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub depth: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub func: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FuncgraphExitFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub calltime: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub depth: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub func: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub overrun: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub rettime: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct G2dTracingMarkWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "5")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleIccEventFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub event: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleIrmEventFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub event: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpuMemTotalFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gpu_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrmSchedJobFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub entity: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub fence: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub hw_job_count: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub job_count: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrmRunJobFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub entity: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub fence: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub hw_job_count: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub job_count: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DrmSchedProcessJobFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub fence: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HypEnterFtraceEvent {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HypExitFtraceEvent {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostHcallFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub invalid: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostSmcFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub forwarded: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostMemAbortFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub esr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub addr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct I2cReadFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub msg_nr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct I2cWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub msg_nr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub buf: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct I2cResultFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub nr_msgs: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct I2cReplyFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub msg_nr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub buf: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmbusReadFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub command: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub protocol: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmbusWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub command: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub protocol: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmbusResultFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub read_write: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub command: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub res: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub protocol: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmbusReplyFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub adapter_nr: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub command: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub protocol: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonStatFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub buffer_id: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "2")]
    pub len: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "3")]
    pub total_allocated: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpiEntryFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpiExitFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpiRaiseFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub target_cpus: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SoftirqEntryFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub vec: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SoftirqExitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub vec: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SoftirqRaiseFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub vec: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrqHandlerEntryFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub irq: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub handler: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrqHandlerExitFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub irq: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KgslGpuFrequencyFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gpu_freq: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub gpu_id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocPagesIommuEndFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocPagesIommuFailFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocPagesIommuStartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocPagesSysEndFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocPagesSysFailFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocPagesSysStartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmaAllocContiguousRetryFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub tries: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IommuMapRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub chunk_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pa: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub va: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IommuSecPtblMapRangeEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub len: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub num: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub pa: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub sec_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub va: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IommuSecPtblMapRangeStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub len: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub num: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub pa: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub sec_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub va: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonAllocBufferEndFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub mask: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonAllocBufferFailFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub error: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "5")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub mask: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonAllocBufferFallbackFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub error: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "5")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub mask: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonAllocBufferStartFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub mask: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonCpAllocRetryFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub tries: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonCpSecureBufferEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub align: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub flags: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonCpSecureBufferStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub align: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub flags: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonPrefetchingFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonSecureCmaAddToPoolEndFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub is_prefetch: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub pool_total: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonSecureCmaAddToPoolStartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub is_prefetch: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub pool_total: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonSecureCmaAllocateEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub align: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub flags: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonSecureCmaAllocateStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub align: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub flags: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonSecureCmaShrinkPoolEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub drained_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub skipped_size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonSecureCmaShrinkPoolStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub drained_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub skipped_size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KfreeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub call_site: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ptr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KmallocFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub bytes_alloc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub bytes_req: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub call_site: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub ptr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KmallocNodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub bytes_alloc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub bytes_req: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub call_site: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub node: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    pub ptr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KmemCacheAllocFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub bytes_alloc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub bytes_req: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub call_site: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub ptr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KmemCacheAllocNodeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub bytes_alloc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub bytes_req: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub call_site: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub node: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    pub ptr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KmemCacheFreeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub call_site: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub ptr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigratePagesEndFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigratePagesStartFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigrateRetryFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub tries: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmPageAllocFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub migratetype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub order: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub page: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmPageAllocExtfragFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub alloc_migratetype: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub alloc_order: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub fallback_migratetype: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub fallback_order: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub page: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "6")]
    pub change_ownership: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "7")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmPageAllocZoneLockedFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub migratetype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub page: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmPageFreeFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub order: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub page: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmPageFreeBatchedFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub cold: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub page: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmPagePcpuDrainFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub migratetype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub order: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub page: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub pfn: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RssStatFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub member: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub size: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "3")]
    pub curr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub mm_id: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonHeapShrinkFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub total_allocated: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IonHeapGrowFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "3")]
    pub total_allocated: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonBufferCreateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub addr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IonBufferDestroyFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub addr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmAccessFaultFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ipa: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmAckIrqFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub irqchip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub pin: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmAgeHvaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub end: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub start: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmAgePageFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub gfn: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub hva: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub referenced: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmArmClearDebugFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub guest_debug: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvmArmSetDreg32FtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub value: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvmArmSetRegsetFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub len: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmArmSetupDebugFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub guest_debug: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub vcpu: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmEntryFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmExitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub esr_ec: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub ret: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmFpuFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub load: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmGetTimerMapFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub direct_ptimer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub direct_vtimer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub emul_ptimer: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub vcpu_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmGuestFaultFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub hsr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub hxfar: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub ipa: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmHandleSysRegFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub hsr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmHvcArm64FtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub imm: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub r0: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmIrqLineFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub irq_num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub vcpu_idx: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmMmioFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub gpa: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmMmioEmulateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub cpsr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub instr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmSetGuestDebugFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub guest_debug: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub vcpu: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmSetIrqFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gsi: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub irq_source_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub level: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmSetSpteHvaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub hva: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmSetWayFlushFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cache: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvmSysAccessFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub c_rm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub c_rn: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub op0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub op1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub op2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub is_write: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "7")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "8")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmTestAgeHvaFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub hva: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmTimerEmulateFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub should_fire: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub timer_idx: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmTimerHrtimerExpireFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub timer_idx: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmTimerRestoreStateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ctl: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub cval: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub timer_idx: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmTimerSaveStateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ctl: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub cval: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub timer_idx: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmTimerUpdateIrqFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub irq: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub vcpu_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmToggleCacheFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub now: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub vcpu_pc: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub was: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmUnmapHvaRangeFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub end: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub start: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmUserspaceExitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub reason: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmVcpuWakeupFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ns: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub valid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub waited: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KvmWfxArm64FtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub is_wfe: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub vcpu_pc: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrapRegFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub r#fn: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub is_write: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub reg: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub write_value: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VgicUpdateIrqPendingFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub irq: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub level: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub vcpu_id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowmemoryKillFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub pagecache_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub pagecache_limit: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub free: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LwisTracingMarkWriteFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub lwis_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub func_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "5")]
    pub value: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaliTracingMarkWriteFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliKcpucqssetFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub info_val1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val2: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub kctx_tgid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliKcpucqswaitstartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub info_val1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val2: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub kctx_tgid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliKcpucqswaitendFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub info_val1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val2: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub kctx_tgid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliKcpufencesignalFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub info_val1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub info_val2: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliKcpufencewaitstartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub info_val1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub info_val2: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliKcpufencewaitendFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub info_val1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub info_val2: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliCsfinterruptstartFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliCsfinterruptendFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlcoresdownscalenotifypendFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlcoresnotifypendFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlcoreinactivependFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlmcuonrecheckFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlshaderscoreoffpendFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlshaderspendoffFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlshaderspendonFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuhctlshadersreadyoffFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuinsleepFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuoffFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuoncoreattrupdatependFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonglbreinitpendFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonhaltFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonhwcntdisableFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonhwcntenableFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonpendhaltFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonpendsleepFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuonsleepinitiateFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcupendoffFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcupendonreloadFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcupowerdownFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliMaliPmmcuresetwaitFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub kctx_tgid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub kctx_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub info_val: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCmdKickoffFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctl_num: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub kickoff_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCommitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub num: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub play_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub clk_rate: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub bandwidth: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpPerfSetOtFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub pnum: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub xin_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub rd_lim: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub is_vbif_rt: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpSsppChangeFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub num: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub play_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub mixer: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub stage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub format: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub img_w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub img_h: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub src_x: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub src_y: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub src_w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub src_h: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub dst_x: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub dst_y: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub dst_w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub dst_h: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracingMarkWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub trace_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub trace_begin: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCmdPingpongDoneFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctl_num: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub intf_num: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub pp_num: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub koff_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCompareBwFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub new_ab: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub new_ib: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub new_wb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub old_ab: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub old_ib: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub old_wb: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "7")]
    pub params_changed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub update_bw: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpPerfSetPanicLutsFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub pnum: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub fmt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub panic_lut: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub robust_lut: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpSsppSetFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub num: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub play_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub mixer: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub stage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub format: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub img_w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub img_h: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub src_x: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub src_y: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub src_w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub src_h: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub dst_x: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub dst_y: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub dst_w: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub dst_h: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCmdReadptrDoneFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctl_num: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub koff_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpMisrCrcFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub block_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub vsync_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub crc: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpPerfSetQosLutsFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub pnum: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub fmt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub intf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub rot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub fl: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub lut: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub linear: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdpTraceCounterFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub counter_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCmdReleaseBwFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctl_num: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpMixerUpdateFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub mixer_num: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpPerfSetWmLevelsFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub pnum: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub use_space: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub priority_bytes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub wm0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub wm1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub wm2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub mb_cnt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub mb_size: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpVideoUnderrunDoneFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctl_num: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub underrun_cnt: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpCmdWaitPingpongFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctl_num: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub kickoff_cnt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpPerfPrefillCalcFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub pnum: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub latency_buf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub ot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub y_buf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub y_scaler: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub pp_lines: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub pp_bytes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub post_sc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub fbc_bytes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub prefill_bytes: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MdpPerfUpdateBusFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub client: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub ab_quota: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub ib_quota: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RotatorBwAoAsContextFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub state: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmEventRecordFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub avg_lat: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub max_lat: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub r#type: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetifReceiveSkbFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub len: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3")]
    pub skbaddr: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetDevXmitFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub len: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub rc: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub skbaddr: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NapiGroReceiveEntryFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub data_len: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub gso_size: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub gso_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub hash: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub ip_summed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub l4_hash: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub len: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub mac_header: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub mac_header_valid: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "10")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "11")]
    pub napi_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub nr_frags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub protocol: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub queue_mapping: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "15")]
    pub skbaddr: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "16")]
    pub truesize: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub vlan_proto: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub vlan_tagged: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub vlan_tci: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NapiGroReceiveExitFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OomScoreAdjUpdateFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub oom_score_adj: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarkVictimFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DsiCmdFifoStatusFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub header: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub payload: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DsiRxFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub cmd: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub rx_buf: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DsiTxFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub last: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub tx_buf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub r#type: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PanelWriteGenericFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub trace_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub trace_begin: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "5")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedSwitchWithCtrsFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub old_pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub new_pid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub cctr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub ctr0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub ctr1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub ctr2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub ctr3: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub lctr0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub lctr1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub ctr4: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub ctr5: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "12")]
    pub prev_comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "13")]
    pub prev_pid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "14")]
    pub cyc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub inst: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub stallbm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub l3dm: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuFrequencyFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub state: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub cpu_id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuFrequencyLimitsFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub min_freq: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub max_freq: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub cpu_id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuIdleFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub state: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub cpu_id: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockEnableFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub state: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub cpu_id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockDisableFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub state: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub cpu_id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockSetRateFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub state: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub cpu_id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendResumeFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub val: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub start: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpuFrequencyFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gpu_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub state: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeupSourceActivateFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub state: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeupSourceDeactivateFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub state: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpuWorkPeriodFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub gpu_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub uid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub start_time_ns: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub end_time_ns: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub total_active_duration_ns: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DevicePmCallbackStartFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub device: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub parent: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub pm_ops: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub event: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DevicePmCallbackEndFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub device: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub error: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsoleFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub msg: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SysEnterFtraceEvent {
    #[prost(int64, optional, tag = "1")]
    pub id: ::core::option::Option<i64>,
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub args: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SysExitFtraceEvent {
    #[prost(int64, optional, tag = "1")]
    pub id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub ret: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorDisableFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorDisableCompleteFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorEnableFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorEnableCompleteFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorEnableDelayFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorSetVoltageFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub min: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub max: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegulatorSetVoltageCompleteFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub val: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpmStatusFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub status: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SamsungTracingMarkWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub trace_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub trace_begin: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub trace_type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedSwitchFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub prev_comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub prev_pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prev_prio: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub prev_state: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "5")]
    pub next_comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "6")]
    pub next_pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub next_prio: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedWakeupFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub success: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub target_cpu: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchedBlockedReasonFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub caller: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub io_wait: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchedCpuHotplugFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub affected_cpu: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub error: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub status: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedWakingFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub success: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub target_cpu: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedWakeupNewFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub success: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub target_cpu: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedProcessExecFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub old_pid: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedProcessExitFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub tgid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub prio: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedProcessForkFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub parent_comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub parent_pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub child_comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub child_pid: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedProcessFreeFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedProcessHangFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedProcessWaitFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedPiSetprioFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub newprio: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub oldprio: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub pid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchedCpuUtilCfsFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub active: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub capacity: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub capacity_orig: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "5")]
    pub cpu_importance: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub cpu_util: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "7")]
    pub exit_lat: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub group_capacity: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "9")]
    pub grp_overutilized: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub idle_cpu: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub nr_running: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "12")]
    pub spare_cap: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "13")]
    pub task_fits: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "14")]
    pub wake_group_util: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "15")]
    pub wake_util: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedMigrateTaskFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub orig_cpu: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub dest_cpu: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub running: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub load: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScmCallStartFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub arginfo: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub x0: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub x5: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScmCallEndFtraceEvent {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdeTracingMarkWriteFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub trace_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub trace_type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub value: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub trace_begin: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdeSdeEvtlogFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub evtlog_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub tag_id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SdeSdePerfCalcCrtcFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub bw_ctl_ebi: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub bw_ctl_llcc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub bw_ctl_mnoc: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub core_clk_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub crtc: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "6")]
    pub ib_ebi: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub ib_llcc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub ib_mnoc: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SdeSdePerfCrtcUpdateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub bw_ctl_ebi: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub bw_ctl_llcc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub bw_ctl_mnoc: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub core_clk_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub crtc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub params: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "7")]
    pub per_pipe_ib_ebi: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub per_pipe_ib_llcc: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub per_pipe_ib_mnoc: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "10")]
    pub stop_req: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub update_bus: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub update_clk: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SdeSdePerfSetQosLutsFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub fl: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub fmt: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub lut: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub lut_usage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub pnum: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub rt: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SdeSdePerfUpdateBusFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ab_quota: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub bus_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub client: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub ib_quota: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignalDeliverFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub code: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub sa_flags: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub sig: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalGenerateFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub group: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub result: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub sig: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KfreeSkbFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub location: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub protocol: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub skbaddr: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InetSockSetStateFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub daddr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub dport: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub family: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub newstate: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub oldstate: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub protocol: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub saddr: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub skaddr: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "9")]
    pub sport: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncPtFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub timeline: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncTimelineFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncWaitFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub begin: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RssStatThrottledFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub curr: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub member: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub mm_id: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "4")]
    pub size: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuspendResumeMinimalFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub start: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZeroFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub flag: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub value: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskNewtaskFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub comm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3")]
    pub clone_flags: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub oom_score_adj: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskRenameFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub oldcomm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub newcomm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub oom_score_adj: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TcpRetransmitSkbFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub daddr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub dport: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub saddr: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub skaddr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub skbaddr: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "6")]
    pub sport: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub state: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThermalTemperatureFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub temp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub temp_prev: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub thermal_zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CdevUpdateFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub target: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThermalExynosAcpmBulkFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub tz_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub current_temp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub ctrl_temp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub cdev_state: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub pid_et_p: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub pid_power_range: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub pid_p: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub pid_i: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub k_p: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub k_i: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "11")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThermalExynosAcpmHighOverheadFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub tz_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub current_temp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub ctrl_temp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub cdev_state: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub pid_et_p: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub k_p: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub k_i: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustySmcFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub r0: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub r1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub r2: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub r3: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustySmcDoneFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub ret: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyStdCall32FtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub r0: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub r1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub r2: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub r3: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyStdCall32DoneFtraceEvent {
    #[prost(int64, optional, tag = "1")]
    pub ret: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyShareMemoryFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub lend: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub nents: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyShareMemoryDoneFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub handle: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub lend: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub nents: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyReclaimMemoryFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyReclaimMemoryDoneFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub ret: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyIrqFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub irq: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcHandleEventFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub chan: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub srv_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcConnectFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub chan: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub port: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub state: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyIpcConnectEndFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub chan: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub err: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub state: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcWriteFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub buf_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub chan: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub kind_shm: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub len_or_err: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub shm_cnt: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "6")]
    pub srv_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcPollFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub chan: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub poll_mask: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub srv_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcReadFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub chan: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub srv_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcReadEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub buf_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub chan: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub len_or_err: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub shm_cnt: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "5")]
    pub srv_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustyIpcRxFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub buf_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub chan: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub srv_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrustyEnqueueNopFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub arg1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub arg2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub arg3: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UfshcdCommandFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub dev_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub doorbell: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub intr: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub lba: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub opcode: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "7")]
    pub tag: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub transfer_len: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub group_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub str_t: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UfshcdClkGatingFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub dev_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub state: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct V4l2QbufFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub bytesused: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub field: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub index: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub sequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub timecode_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub timecode_frames: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub timecode_hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub timecode_minutes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub timecode_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub timecode_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub timecode_userbits0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub timecode_userbits1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub timecode_userbits2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub timecode_userbits3: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "17")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "18")]
    pub r#type: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct V4l2DqbufFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub bytesused: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub field: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub index: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub sequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub timecode_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub timecode_frames: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub timecode_hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub timecode_minutes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub timecode_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub timecode_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub timecode_userbits0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub timecode_userbits1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub timecode_userbits2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub timecode_userbits3: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "17")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "18")]
    pub r#type: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vb2V4l2BufQueueFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub field: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub sequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub timecode_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub timecode_frames: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub timecode_hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub timecode_minutes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub timecode_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub timecode_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub timecode_userbits0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub timecode_userbits1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub timecode_userbits2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub timecode_userbits3: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "15")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vb2V4l2BufDoneFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub field: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub sequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub timecode_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub timecode_frames: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub timecode_hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub timecode_minutes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub timecode_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub timecode_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub timecode_userbits0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub timecode_userbits1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub timecode_userbits2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub timecode_userbits3: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "15")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vb2V4l2QbufFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub field: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub sequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub timecode_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub timecode_frames: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub timecode_hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub timecode_minutes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub timecode_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub timecode_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub timecode_userbits0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub timecode_userbits1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub timecode_userbits2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub timecode_userbits3: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "15")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vb2V4l2DqbufFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub field: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub minor: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub sequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub timecode_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub timecode_frames: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub timecode_hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub timecode_minutes: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub timecode_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub timecode_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub timecode_userbits0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub timecode_userbits1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub timecode_userbits2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub timecode_userbits3: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "15")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtioGpuCmdQueueFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctx_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub dev: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub fence_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "6")]
    pub num_free: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub vq: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtioGpuCmdResponseFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub ctx_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub dev: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub fence_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub flags: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "6")]
    pub num_free: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub seqno: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub vq: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VirtioVideoCmdFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub stream_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub r#type: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VirtioVideoCmdDoneFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub stream_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub r#type: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VirtioVideoResourceQueueFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub data_size0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub data_size1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub data_size2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub data_size3: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub queue_type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub resource_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub stream_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "8")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VirtioVideoResourceQueueDoneFtraceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub data_size0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub data_size1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub data_size2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub data_size3: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub queue_type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub resource_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub stream_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "8")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmVmscanDirectReclaimBeginFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub order: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub may_writepage: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub gfp_flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmVmscanDirectReclaimEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub nr_reclaimed: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmVmscanKswapdWakeFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub order: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub zid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmVmscanKswapdSleepFtraceEvent {
    #[prost(int32, optional, tag = "1")]
    pub nid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmShrinkSlabStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub cache_items: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub delta: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub gfp_flags: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub lru_pgs: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "5")]
    pub nr_objects_to_shrink: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "6")]
    pub pgs_scanned: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub shr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub shrink: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub total_scan: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "10")]
    pub nid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub priority: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MmShrinkSlabEndFtraceEvent {
    #[prost(int64, optional, tag = "1")]
    pub new_scan: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub retval: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub shr: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub shrink: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "5")]
    pub total_scan: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub unused_scan: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "7")]
    pub nid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkqueueActivateWorkFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub work: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkqueueExecuteEndFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub work: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub function: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkqueueExecuteStartFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub work: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub function: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkqueueQueueWorkFtraceEvent {
    #[prost(uint64, optional, tag = "1")]
    pub work: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub function: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub workqueue: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub req_cpu: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub cpu: ::core::option::Option<u32>,
}
/// This generic proto is used to output events in the trace
/// when a specific proto for that event does not exist.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericFtraceEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub field: ::prost::alloc::vec::Vec<generic_ftrace_event::Field>,
}
/// Nested message and enum types in `GenericFtraceEvent`.
pub mod generic_ftrace_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Field {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(oneof = "field::Value", tags = "3, 4, 5")]
        pub value: ::core::option::Option<field::Value>,
    }
    /// Nested message and enum types in `Field`.
    pub mod field {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(string, tag = "3")]
            StrValue(::prost::alloc::string::String),
            #[prost(int64, tag = "4")]
            IntValue(i64),
            #[prost(uint64, tag = "5")]
            UintValue(u64),
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtraceEvent {
    /// Timestamp in nanoseconds using .../tracing/trace_clock.
    #[prost(uint64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<u64>,
    /// Kernel pid (do not confuse with userspace pid aka tgid).
    #[prost(uint32, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    /// Not populated in actual traces. Wire format might change.
    /// Placeholder declaration so that the ftrace parsing code accepts the
    /// existence of this common field. If this becomes needed for all events:
    /// consider merging with common_preempt_count to avoid extra proto tags.
    #[prost(uint32, optional, tag = "5")]
    pub common_flags: ::core::option::Option<u32>,
    #[prost(
        oneof = "ftrace_event::Event",
        tags = "3, 4, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 460, 461, 462, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532"
    )]
    pub event: ::core::option::Option<ftrace_event::Event>,
}
/// Nested message and enum types in `FtraceEvent`.
pub mod ftrace_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "3")]
        Print(super::PrintFtraceEvent),
        #[prost(message, tag = "4")]
        SchedSwitch(super::SchedSwitchFtraceEvent),
        /// removed field with id 5;
        /// removed field with id 6;
        /// removed field with id 7;
        /// removed field with id 8;
        /// removed field with id 9;
        /// removed field with id 10;
        #[prost(message, tag = "11")]
        CpuFrequency(super::CpuFrequencyFtraceEvent),
        #[prost(message, tag = "12")]
        CpuFrequencyLimits(super::CpuFrequencyLimitsFtraceEvent),
        #[prost(message, tag = "13")]
        CpuIdle(super::CpuIdleFtraceEvent),
        #[prost(message, tag = "14")]
        ClockEnable(super::ClockEnableFtraceEvent),
        #[prost(message, tag = "15")]
        ClockDisable(super::ClockDisableFtraceEvent),
        #[prost(message, tag = "16")]
        ClockSetRate(super::ClockSetRateFtraceEvent),
        #[prost(message, tag = "17")]
        SchedWakeup(super::SchedWakeupFtraceEvent),
        #[prost(message, tag = "18")]
        SchedBlockedReason(super::SchedBlockedReasonFtraceEvent),
        #[prost(message, tag = "19")]
        SchedCpuHotplug(super::SchedCpuHotplugFtraceEvent),
        #[prost(message, tag = "20")]
        SchedWaking(super::SchedWakingFtraceEvent),
        #[prost(message, tag = "21")]
        IpiEntry(super::IpiEntryFtraceEvent),
        #[prost(message, tag = "22")]
        IpiExit(super::IpiExitFtraceEvent),
        #[prost(message, tag = "23")]
        IpiRaise(super::IpiRaiseFtraceEvent),
        #[prost(message, tag = "24")]
        SoftirqEntry(super::SoftirqEntryFtraceEvent),
        #[prost(message, tag = "25")]
        SoftirqExit(super::SoftirqExitFtraceEvent),
        #[prost(message, tag = "26")]
        SoftirqRaise(super::SoftirqRaiseFtraceEvent),
        #[prost(message, tag = "27")]
        I2cRead(super::I2cReadFtraceEvent),
        #[prost(message, tag = "28")]
        I2cWrite(super::I2cWriteFtraceEvent),
        #[prost(message, tag = "29")]
        I2cResult(super::I2cResultFtraceEvent),
        #[prost(message, tag = "30")]
        I2cReply(super::I2cReplyFtraceEvent),
        #[prost(message, tag = "31")]
        SmbusRead(super::SmbusReadFtraceEvent),
        #[prost(message, tag = "32")]
        SmbusWrite(super::SmbusWriteFtraceEvent),
        #[prost(message, tag = "33")]
        SmbusResult(super::SmbusResultFtraceEvent),
        #[prost(message, tag = "34")]
        SmbusReply(super::SmbusReplyFtraceEvent),
        #[prost(message, tag = "35")]
        LowmemoryKill(super::LowmemoryKillFtraceEvent),
        #[prost(message, tag = "36")]
        IrqHandlerEntry(super::IrqHandlerEntryFtraceEvent),
        #[prost(message, tag = "37")]
        IrqHandlerExit(super::IrqHandlerExitFtraceEvent),
        #[prost(message, tag = "38")]
        SyncPt(super::SyncPtFtraceEvent),
        #[prost(message, tag = "39")]
        SyncTimeline(super::SyncTimelineFtraceEvent),
        #[prost(message, tag = "40")]
        SyncWait(super::SyncWaitFtraceEvent),
        #[prost(message, tag = "41")]
        Ext4DaWriteBegin(super::Ext4DaWriteBeginFtraceEvent),
        #[prost(message, tag = "42")]
        Ext4DaWriteEnd(super::Ext4DaWriteEndFtraceEvent),
        #[prost(message, tag = "43")]
        Ext4SyncFileEnter(super::Ext4SyncFileEnterFtraceEvent),
        #[prost(message, tag = "44")]
        Ext4SyncFileExit(super::Ext4SyncFileExitFtraceEvent),
        #[prost(message, tag = "45")]
        BlockRqIssue(super::BlockRqIssueFtraceEvent),
        #[prost(message, tag = "46")]
        MmVmscanDirectReclaimBegin(super::MmVmscanDirectReclaimBeginFtraceEvent),
        #[prost(message, tag = "47")]
        MmVmscanDirectReclaimEnd(super::MmVmscanDirectReclaimEndFtraceEvent),
        #[prost(message, tag = "48")]
        MmVmscanKswapdWake(super::MmVmscanKswapdWakeFtraceEvent),
        #[prost(message, tag = "49")]
        MmVmscanKswapdSleep(super::MmVmscanKswapdSleepFtraceEvent),
        #[prost(message, tag = "50")]
        BinderTransaction(super::BinderTransactionFtraceEvent),
        #[prost(message, tag = "51")]
        BinderTransactionReceived(super::BinderTransactionReceivedFtraceEvent),
        #[prost(message, tag = "52")]
        BinderSetPriority(super::BinderSetPriorityFtraceEvent),
        #[prost(message, tag = "53")]
        BinderLock(super::BinderLockFtraceEvent),
        #[prost(message, tag = "54")]
        BinderLocked(super::BinderLockedFtraceEvent),
        #[prost(message, tag = "55")]
        BinderUnlock(super::BinderUnlockFtraceEvent),
        #[prost(message, tag = "56")]
        WorkqueueActivateWork(super::WorkqueueActivateWorkFtraceEvent),
        #[prost(message, tag = "57")]
        WorkqueueExecuteEnd(super::WorkqueueExecuteEndFtraceEvent),
        #[prost(message, tag = "58")]
        WorkqueueExecuteStart(super::WorkqueueExecuteStartFtraceEvent),
        #[prost(message, tag = "59")]
        WorkqueueQueueWork(super::WorkqueueQueueWorkFtraceEvent),
        #[prost(message, tag = "60")]
        RegulatorDisable(super::RegulatorDisableFtraceEvent),
        #[prost(message, tag = "61")]
        RegulatorDisableComplete(super::RegulatorDisableCompleteFtraceEvent),
        #[prost(message, tag = "62")]
        RegulatorEnable(super::RegulatorEnableFtraceEvent),
        #[prost(message, tag = "63")]
        RegulatorEnableComplete(super::RegulatorEnableCompleteFtraceEvent),
        #[prost(message, tag = "64")]
        RegulatorEnableDelay(super::RegulatorEnableDelayFtraceEvent),
        #[prost(message, tag = "65")]
        RegulatorSetVoltage(super::RegulatorSetVoltageFtraceEvent),
        #[prost(message, tag = "66")]
        RegulatorSetVoltageComplete(super::RegulatorSetVoltageCompleteFtraceEvent),
        #[prost(message, tag = "67")]
        CgroupAttachTask(super::CgroupAttachTaskFtraceEvent),
        #[prost(message, tag = "68")]
        CgroupMkdir(super::CgroupMkdirFtraceEvent),
        #[prost(message, tag = "69")]
        CgroupRemount(super::CgroupRemountFtraceEvent),
        #[prost(message, tag = "70")]
        CgroupRmdir(super::CgroupRmdirFtraceEvent),
        #[prost(message, tag = "71")]
        CgroupTransferTasks(super::CgroupTransferTasksFtraceEvent),
        #[prost(message, tag = "72")]
        CgroupDestroyRoot(super::CgroupDestroyRootFtraceEvent),
        #[prost(message, tag = "73")]
        CgroupRelease(super::CgroupReleaseFtraceEvent),
        #[prost(message, tag = "74")]
        CgroupRename(super::CgroupRenameFtraceEvent),
        #[prost(message, tag = "75")]
        CgroupSetupRoot(super::CgroupSetupRootFtraceEvent),
        #[prost(message, tag = "76")]
        MdpCmdKickoff(super::MdpCmdKickoffFtraceEvent),
        #[prost(message, tag = "77")]
        MdpCommit(super::MdpCommitFtraceEvent),
        #[prost(message, tag = "78")]
        MdpPerfSetOt(super::MdpPerfSetOtFtraceEvent),
        #[prost(message, tag = "79")]
        MdpSsppChange(super::MdpSsppChangeFtraceEvent),
        #[prost(message, tag = "80")]
        TracingMarkWrite(super::TracingMarkWriteFtraceEvent),
        #[prost(message, tag = "81")]
        MdpCmdPingpongDone(super::MdpCmdPingpongDoneFtraceEvent),
        #[prost(message, tag = "82")]
        MdpCompareBw(super::MdpCompareBwFtraceEvent),
        #[prost(message, tag = "83")]
        MdpPerfSetPanicLuts(super::MdpPerfSetPanicLutsFtraceEvent),
        #[prost(message, tag = "84")]
        MdpSsppSet(super::MdpSsppSetFtraceEvent),
        #[prost(message, tag = "85")]
        MdpCmdReadptrDone(super::MdpCmdReadptrDoneFtraceEvent),
        #[prost(message, tag = "86")]
        MdpMisrCrc(super::MdpMisrCrcFtraceEvent),
        #[prost(message, tag = "87")]
        MdpPerfSetQosLuts(super::MdpPerfSetQosLutsFtraceEvent),
        #[prost(message, tag = "88")]
        MdpTraceCounter(super::MdpTraceCounterFtraceEvent),
        #[prost(message, tag = "89")]
        MdpCmdReleaseBw(super::MdpCmdReleaseBwFtraceEvent),
        #[prost(message, tag = "90")]
        MdpMixerUpdate(super::MdpMixerUpdateFtraceEvent),
        #[prost(message, tag = "91")]
        MdpPerfSetWmLevels(super::MdpPerfSetWmLevelsFtraceEvent),
        #[prost(message, tag = "92")]
        MdpVideoUnderrunDone(super::MdpVideoUnderrunDoneFtraceEvent),
        #[prost(message, tag = "93")]
        MdpCmdWaitPingpong(super::MdpCmdWaitPingpongFtraceEvent),
        #[prost(message, tag = "94")]
        MdpPerfPrefillCalc(super::MdpPerfPrefillCalcFtraceEvent),
        #[prost(message, tag = "95")]
        MdpPerfUpdateBus(super::MdpPerfUpdateBusFtraceEvent),
        #[prost(message, tag = "96")]
        RotatorBwAoAsContext(super::RotatorBwAoAsContextFtraceEvent),
        #[prost(message, tag = "97")]
        MmFilemapAddToPageCache(super::MmFilemapAddToPageCacheFtraceEvent),
        #[prost(message, tag = "98")]
        MmFilemapDeleteFromPageCache(super::MmFilemapDeleteFromPageCacheFtraceEvent),
        #[prost(message, tag = "99")]
        MmCompactionBegin(super::MmCompactionBeginFtraceEvent),
        #[prost(message, tag = "100")]
        MmCompactionDeferCompaction(super::MmCompactionDeferCompactionFtraceEvent),
        #[prost(message, tag = "101")]
        MmCompactionDeferred(super::MmCompactionDeferredFtraceEvent),
        #[prost(message, tag = "102")]
        MmCompactionDeferReset(super::MmCompactionDeferResetFtraceEvent),
        #[prost(message, tag = "103")]
        MmCompactionEnd(super::MmCompactionEndFtraceEvent),
        #[prost(message, tag = "104")]
        MmCompactionFinished(super::MmCompactionFinishedFtraceEvent),
        #[prost(message, tag = "105")]
        MmCompactionIsolateFreepages(super::MmCompactionIsolateFreepagesFtraceEvent),
        #[prost(message, tag = "106")]
        MmCompactionIsolateMigratepages(
            super::MmCompactionIsolateMigratepagesFtraceEvent,
        ),
        #[prost(message, tag = "107")]
        MmCompactionKcompactdSleep(super::MmCompactionKcompactdSleepFtraceEvent),
        #[prost(message, tag = "108")]
        MmCompactionKcompactdWake(super::MmCompactionKcompactdWakeFtraceEvent),
        #[prost(message, tag = "109")]
        MmCompactionMigratepages(super::MmCompactionMigratepagesFtraceEvent),
        #[prost(message, tag = "110")]
        MmCompactionSuitable(super::MmCompactionSuitableFtraceEvent),
        #[prost(message, tag = "111")]
        MmCompactionTryToCompactPages(super::MmCompactionTryToCompactPagesFtraceEvent),
        #[prost(message, tag = "112")]
        MmCompactionWakeupKcompactd(super::MmCompactionWakeupKcompactdFtraceEvent),
        #[prost(message, tag = "113")]
        SuspendResume(super::SuspendResumeFtraceEvent),
        #[prost(message, tag = "114")]
        SchedWakeupNew(super::SchedWakeupNewFtraceEvent),
        #[prost(message, tag = "115")]
        BlockBioBackmerge(super::BlockBioBackmergeFtraceEvent),
        #[prost(message, tag = "116")]
        BlockBioBounce(super::BlockBioBounceFtraceEvent),
        #[prost(message, tag = "117")]
        BlockBioComplete(super::BlockBioCompleteFtraceEvent),
        #[prost(message, tag = "118")]
        BlockBioFrontmerge(super::BlockBioFrontmergeFtraceEvent),
        #[prost(message, tag = "119")]
        BlockBioQueue(super::BlockBioQueueFtraceEvent),
        #[prost(message, tag = "120")]
        BlockBioRemap(super::BlockBioRemapFtraceEvent),
        #[prost(message, tag = "121")]
        BlockDirtyBuffer(super::BlockDirtyBufferFtraceEvent),
        #[prost(message, tag = "122")]
        BlockGetrq(super::BlockGetrqFtraceEvent),
        #[prost(message, tag = "123")]
        BlockPlug(super::BlockPlugFtraceEvent),
        #[prost(message, tag = "124")]
        BlockRqAbort(super::BlockRqAbortFtraceEvent),
        #[prost(message, tag = "125")]
        BlockRqComplete(super::BlockRqCompleteFtraceEvent),
        #[prost(message, tag = "126")]
        BlockRqInsert(super::BlockRqInsertFtraceEvent),
        /// removed field with id 127;
        #[prost(message, tag = "128")]
        BlockRqRemap(super::BlockRqRemapFtraceEvent),
        #[prost(message, tag = "129")]
        BlockRqRequeue(super::BlockRqRequeueFtraceEvent),
        #[prost(message, tag = "130")]
        BlockSleeprq(super::BlockSleeprqFtraceEvent),
        #[prost(message, tag = "131")]
        BlockSplit(super::BlockSplitFtraceEvent),
        #[prost(message, tag = "132")]
        BlockTouchBuffer(super::BlockTouchBufferFtraceEvent),
        #[prost(message, tag = "133")]
        BlockUnplug(super::BlockUnplugFtraceEvent),
        #[prost(message, tag = "134")]
        Ext4AllocDaBlocks(super::Ext4AllocDaBlocksFtraceEvent),
        #[prost(message, tag = "135")]
        Ext4AllocateBlocks(super::Ext4AllocateBlocksFtraceEvent),
        #[prost(message, tag = "136")]
        Ext4AllocateInode(super::Ext4AllocateInodeFtraceEvent),
        #[prost(message, tag = "137")]
        Ext4BeginOrderedTruncate(super::Ext4BeginOrderedTruncateFtraceEvent),
        #[prost(message, tag = "138")]
        Ext4CollapseRange(super::Ext4CollapseRangeFtraceEvent),
        #[prost(message, tag = "139")]
        Ext4DaReleaseSpace(super::Ext4DaReleaseSpaceFtraceEvent),
        #[prost(message, tag = "140")]
        Ext4DaReserveSpace(super::Ext4DaReserveSpaceFtraceEvent),
        #[prost(message, tag = "141")]
        Ext4DaUpdateReserveSpace(super::Ext4DaUpdateReserveSpaceFtraceEvent),
        #[prost(message, tag = "142")]
        Ext4DaWritePages(super::Ext4DaWritePagesFtraceEvent),
        #[prost(message, tag = "143")]
        Ext4DaWritePagesExtent(super::Ext4DaWritePagesExtentFtraceEvent),
        #[prost(message, tag = "144")]
        Ext4DirectIoEnter(super::Ext4DirectIoEnterFtraceEvent),
        #[prost(message, tag = "145")]
        Ext4DirectIoExit(super::Ext4DirectIoExitFtraceEvent),
        #[prost(message, tag = "146")]
        Ext4DiscardBlocks(super::Ext4DiscardBlocksFtraceEvent),
        #[prost(message, tag = "147")]
        Ext4DiscardPreallocations(super::Ext4DiscardPreallocationsFtraceEvent),
        #[prost(message, tag = "148")]
        Ext4DropInode(super::Ext4DropInodeFtraceEvent),
        #[prost(message, tag = "149")]
        Ext4EsCacheExtent(super::Ext4EsCacheExtentFtraceEvent),
        #[prost(message, tag = "150")]
        Ext4EsFindDelayedExtentRangeEnter(
            super::Ext4EsFindDelayedExtentRangeEnterFtraceEvent,
        ),
        #[prost(message, tag = "151")]
        Ext4EsFindDelayedExtentRangeExit(
            super::Ext4EsFindDelayedExtentRangeExitFtraceEvent,
        ),
        #[prost(message, tag = "152")]
        Ext4EsInsertExtent(super::Ext4EsInsertExtentFtraceEvent),
        #[prost(message, tag = "153")]
        Ext4EsLookupExtentEnter(super::Ext4EsLookupExtentEnterFtraceEvent),
        #[prost(message, tag = "154")]
        Ext4EsLookupExtentExit(super::Ext4EsLookupExtentExitFtraceEvent),
        #[prost(message, tag = "155")]
        Ext4EsRemoveExtent(super::Ext4EsRemoveExtentFtraceEvent),
        #[prost(message, tag = "156")]
        Ext4EsShrink(super::Ext4EsShrinkFtraceEvent),
        #[prost(message, tag = "157")]
        Ext4EsShrinkCount(super::Ext4EsShrinkCountFtraceEvent),
        #[prost(message, tag = "158")]
        Ext4EsShrinkScanEnter(super::Ext4EsShrinkScanEnterFtraceEvent),
        #[prost(message, tag = "159")]
        Ext4EsShrinkScanExit(super::Ext4EsShrinkScanExitFtraceEvent),
        #[prost(message, tag = "160")]
        Ext4EvictInode(super::Ext4EvictInodeFtraceEvent),
        #[prost(message, tag = "161")]
        Ext4ExtConvertToInitializedEnter(
            super::Ext4ExtConvertToInitializedEnterFtraceEvent,
        ),
        #[prost(message, tag = "162")]
        Ext4ExtConvertToInitializedFastpath(
            super::Ext4ExtConvertToInitializedFastpathFtraceEvent,
        ),
        #[prost(message, tag = "163")]
        Ext4ExtHandleUnwrittenExtents(super::Ext4ExtHandleUnwrittenExtentsFtraceEvent),
        #[prost(message, tag = "164")]
        Ext4ExtInCache(super::Ext4ExtInCacheFtraceEvent),
        #[prost(message, tag = "165")]
        Ext4ExtLoadExtent(super::Ext4ExtLoadExtentFtraceEvent),
        #[prost(message, tag = "166")]
        Ext4ExtMapBlocksEnter(super::Ext4ExtMapBlocksEnterFtraceEvent),
        #[prost(message, tag = "167")]
        Ext4ExtMapBlocksExit(super::Ext4ExtMapBlocksExitFtraceEvent),
        #[prost(message, tag = "168")]
        Ext4ExtPutInCache(super::Ext4ExtPutInCacheFtraceEvent),
        #[prost(message, tag = "169")]
        Ext4ExtRemoveSpace(super::Ext4ExtRemoveSpaceFtraceEvent),
        #[prost(message, tag = "170")]
        Ext4ExtRemoveSpaceDone(super::Ext4ExtRemoveSpaceDoneFtraceEvent),
        #[prost(message, tag = "171")]
        Ext4ExtRmIdx(super::Ext4ExtRmIdxFtraceEvent),
        #[prost(message, tag = "172")]
        Ext4ExtRmLeaf(super::Ext4ExtRmLeafFtraceEvent),
        #[prost(message, tag = "173")]
        Ext4ExtShowExtent(super::Ext4ExtShowExtentFtraceEvent),
        #[prost(message, tag = "174")]
        Ext4FallocateEnter(super::Ext4FallocateEnterFtraceEvent),
        #[prost(message, tag = "175")]
        Ext4FallocateExit(super::Ext4FallocateExitFtraceEvent),
        #[prost(message, tag = "176")]
        Ext4FindDelallocRange(super::Ext4FindDelallocRangeFtraceEvent),
        #[prost(message, tag = "177")]
        Ext4Forget(super::Ext4ForgetFtraceEvent),
        #[prost(message, tag = "178")]
        Ext4FreeBlocks(super::Ext4FreeBlocksFtraceEvent),
        #[prost(message, tag = "179")]
        Ext4FreeInode(super::Ext4FreeInodeFtraceEvent),
        #[prost(message, tag = "180")]
        Ext4GetImpliedClusterAllocExit(super::Ext4GetImpliedClusterAllocExitFtraceEvent),
        #[prost(message, tag = "181")]
        Ext4GetReservedClusterAlloc(super::Ext4GetReservedClusterAllocFtraceEvent),
        #[prost(message, tag = "182")]
        Ext4IndMapBlocksEnter(super::Ext4IndMapBlocksEnterFtraceEvent),
        #[prost(message, tag = "183")]
        Ext4IndMapBlocksExit(super::Ext4IndMapBlocksExitFtraceEvent),
        #[prost(message, tag = "184")]
        Ext4InsertRange(super::Ext4InsertRangeFtraceEvent),
        #[prost(message, tag = "185")]
        Ext4Invalidatepage(super::Ext4InvalidatepageFtraceEvent),
        #[prost(message, tag = "186")]
        Ext4JournalStart(super::Ext4JournalStartFtraceEvent),
        #[prost(message, tag = "187")]
        Ext4JournalStartReserved(super::Ext4JournalStartReservedFtraceEvent),
        #[prost(message, tag = "188")]
        Ext4JournalledInvalidatepage(super::Ext4JournalledInvalidatepageFtraceEvent),
        #[prost(message, tag = "189")]
        Ext4JournalledWriteEnd(super::Ext4JournalledWriteEndFtraceEvent),
        #[prost(message, tag = "190")]
        Ext4LoadInode(super::Ext4LoadInodeFtraceEvent),
        #[prost(message, tag = "191")]
        Ext4LoadInodeBitmap(super::Ext4LoadInodeBitmapFtraceEvent),
        #[prost(message, tag = "192")]
        Ext4MarkInodeDirty(super::Ext4MarkInodeDirtyFtraceEvent),
        #[prost(message, tag = "193")]
        Ext4MbBitmapLoad(super::Ext4MbBitmapLoadFtraceEvent),
        #[prost(message, tag = "194")]
        Ext4MbBuddyBitmapLoad(super::Ext4MbBuddyBitmapLoadFtraceEvent),
        #[prost(message, tag = "195")]
        Ext4MbDiscardPreallocations(super::Ext4MbDiscardPreallocationsFtraceEvent),
        #[prost(message, tag = "196")]
        Ext4MbNewGroupPa(super::Ext4MbNewGroupPaFtraceEvent),
        #[prost(message, tag = "197")]
        Ext4MbNewInodePa(super::Ext4MbNewInodePaFtraceEvent),
        #[prost(message, tag = "198")]
        Ext4MbReleaseGroupPa(super::Ext4MbReleaseGroupPaFtraceEvent),
        #[prost(message, tag = "199")]
        Ext4MbReleaseInodePa(super::Ext4MbReleaseInodePaFtraceEvent),
        #[prost(message, tag = "200")]
        Ext4MballocAlloc(super::Ext4MballocAllocFtraceEvent),
        #[prost(message, tag = "201")]
        Ext4MballocDiscard(super::Ext4MballocDiscardFtraceEvent),
        #[prost(message, tag = "202")]
        Ext4MballocFree(super::Ext4MballocFreeFtraceEvent),
        #[prost(message, tag = "203")]
        Ext4MballocPrealloc(super::Ext4MballocPreallocFtraceEvent),
        #[prost(message, tag = "204")]
        Ext4OtherInodeUpdateTime(super::Ext4OtherInodeUpdateTimeFtraceEvent),
        #[prost(message, tag = "205")]
        Ext4PunchHole(super::Ext4PunchHoleFtraceEvent),
        #[prost(message, tag = "206")]
        Ext4ReadBlockBitmapLoad(super::Ext4ReadBlockBitmapLoadFtraceEvent),
        #[prost(message, tag = "207")]
        Ext4Readpage(super::Ext4ReadpageFtraceEvent),
        #[prost(message, tag = "208")]
        Ext4Releasepage(super::Ext4ReleasepageFtraceEvent),
        #[prost(message, tag = "209")]
        Ext4RemoveBlocks(super::Ext4RemoveBlocksFtraceEvent),
        #[prost(message, tag = "210")]
        Ext4RequestBlocks(super::Ext4RequestBlocksFtraceEvent),
        #[prost(message, tag = "211")]
        Ext4RequestInode(super::Ext4RequestInodeFtraceEvent),
        #[prost(message, tag = "212")]
        Ext4SyncFs(super::Ext4SyncFsFtraceEvent),
        #[prost(message, tag = "213")]
        Ext4TrimAllFree(super::Ext4TrimAllFreeFtraceEvent),
        #[prost(message, tag = "214")]
        Ext4TrimExtent(super::Ext4TrimExtentFtraceEvent),
        #[prost(message, tag = "215")]
        Ext4TruncateEnter(super::Ext4TruncateEnterFtraceEvent),
        #[prost(message, tag = "216")]
        Ext4TruncateExit(super::Ext4TruncateExitFtraceEvent),
        #[prost(message, tag = "217")]
        Ext4UnlinkEnter(super::Ext4UnlinkEnterFtraceEvent),
        #[prost(message, tag = "218")]
        Ext4UnlinkExit(super::Ext4UnlinkExitFtraceEvent),
        #[prost(message, tag = "219")]
        Ext4WriteBegin(super::Ext4WriteBeginFtraceEvent),
        /// removed field with id 220;
        /// removed field with id 221;
        /// removed field with id 222;
        /// removed field with id 223;
        /// removed field with id 224;
        /// removed field with id 225;
        /// removed field with id 226;
        /// removed field with id 227;
        /// removed field with id 228;
        /// removed field with id 229;
        #[prost(message, tag = "230")]
        Ext4WriteEnd(super::Ext4WriteEndFtraceEvent),
        #[prost(message, tag = "231")]
        Ext4Writepage(super::Ext4WritepageFtraceEvent),
        #[prost(message, tag = "232")]
        Ext4Writepages(super::Ext4WritepagesFtraceEvent),
        #[prost(message, tag = "233")]
        Ext4WritepagesResult(super::Ext4WritepagesResultFtraceEvent),
        #[prost(message, tag = "234")]
        Ext4ZeroRange(super::Ext4ZeroRangeFtraceEvent),
        #[prost(message, tag = "235")]
        TaskNewtask(super::TaskNewtaskFtraceEvent),
        #[prost(message, tag = "236")]
        TaskRename(super::TaskRenameFtraceEvent),
        #[prost(message, tag = "237")]
        SchedProcessExec(super::SchedProcessExecFtraceEvent),
        #[prost(message, tag = "238")]
        SchedProcessExit(super::SchedProcessExitFtraceEvent),
        #[prost(message, tag = "239")]
        SchedProcessFork(super::SchedProcessForkFtraceEvent),
        #[prost(message, tag = "240")]
        SchedProcessFree(super::SchedProcessFreeFtraceEvent),
        #[prost(message, tag = "241")]
        SchedProcessHang(super::SchedProcessHangFtraceEvent),
        #[prost(message, tag = "242")]
        SchedProcessWait(super::SchedProcessWaitFtraceEvent),
        #[prost(message, tag = "243")]
        F2fsDoSubmitBio(super::F2fsDoSubmitBioFtraceEvent),
        #[prost(message, tag = "244")]
        F2fsEvictInode(super::F2fsEvictInodeFtraceEvent),
        #[prost(message, tag = "245")]
        F2fsFallocate(super::F2fsFallocateFtraceEvent),
        #[prost(message, tag = "246")]
        F2fsGetDataBlock(super::F2fsGetDataBlockFtraceEvent),
        #[prost(message, tag = "247")]
        F2fsGetVictim(super::F2fsGetVictimFtraceEvent),
        #[prost(message, tag = "248")]
        F2fsIget(super::F2fsIgetFtraceEvent),
        #[prost(message, tag = "249")]
        F2fsIgetExit(super::F2fsIgetExitFtraceEvent),
        #[prost(message, tag = "250")]
        F2fsNewInode(super::F2fsNewInodeFtraceEvent),
        #[prost(message, tag = "251")]
        F2fsReadpage(super::F2fsReadpageFtraceEvent),
        #[prost(message, tag = "252")]
        F2fsReserveNewBlock(super::F2fsReserveNewBlockFtraceEvent),
        #[prost(message, tag = "253")]
        F2fsSetPageDirty(super::F2fsSetPageDirtyFtraceEvent),
        #[prost(message, tag = "254")]
        F2fsSubmitWritePage(super::F2fsSubmitWritePageFtraceEvent),
        #[prost(message, tag = "255")]
        F2fsSyncFileEnter(super::F2fsSyncFileEnterFtraceEvent),
        #[prost(message, tag = "256")]
        F2fsSyncFileExit(super::F2fsSyncFileExitFtraceEvent),
        #[prost(message, tag = "257")]
        F2fsSyncFs(super::F2fsSyncFsFtraceEvent),
        #[prost(message, tag = "258")]
        F2fsTruncate(super::F2fsTruncateFtraceEvent),
        #[prost(message, tag = "259")]
        F2fsTruncateBlocksEnter(super::F2fsTruncateBlocksEnterFtraceEvent),
        #[prost(message, tag = "260")]
        F2fsTruncateBlocksExit(super::F2fsTruncateBlocksExitFtraceEvent),
        #[prost(message, tag = "261")]
        F2fsTruncateDataBlocksRange(super::F2fsTruncateDataBlocksRangeFtraceEvent),
        #[prost(message, tag = "262")]
        F2fsTruncateInodeBlocksEnter(super::F2fsTruncateInodeBlocksEnterFtraceEvent),
        #[prost(message, tag = "263")]
        F2fsTruncateInodeBlocksExit(super::F2fsTruncateInodeBlocksExitFtraceEvent),
        #[prost(message, tag = "264")]
        F2fsTruncateNode(super::F2fsTruncateNodeFtraceEvent),
        #[prost(message, tag = "265")]
        F2fsTruncateNodesEnter(super::F2fsTruncateNodesEnterFtraceEvent),
        #[prost(message, tag = "266")]
        F2fsTruncateNodesExit(super::F2fsTruncateNodesExitFtraceEvent),
        #[prost(message, tag = "267")]
        F2fsTruncatePartialNodes(super::F2fsTruncatePartialNodesFtraceEvent),
        #[prost(message, tag = "268")]
        F2fsUnlinkEnter(super::F2fsUnlinkEnterFtraceEvent),
        #[prost(message, tag = "269")]
        F2fsUnlinkExit(super::F2fsUnlinkExitFtraceEvent),
        #[prost(message, tag = "270")]
        F2fsVmPageMkwrite(super::F2fsVmPageMkwriteFtraceEvent),
        #[prost(message, tag = "271")]
        F2fsWriteBegin(super::F2fsWriteBeginFtraceEvent),
        #[prost(message, tag = "272")]
        F2fsWriteCheckpoint(super::F2fsWriteCheckpointFtraceEvent),
        #[prost(message, tag = "273")]
        F2fsWriteEnd(super::F2fsWriteEndFtraceEvent),
        #[prost(message, tag = "274")]
        AllocPagesIommuEnd(super::AllocPagesIommuEndFtraceEvent),
        #[prost(message, tag = "275")]
        AllocPagesIommuFail(super::AllocPagesIommuFailFtraceEvent),
        #[prost(message, tag = "276")]
        AllocPagesIommuStart(super::AllocPagesIommuStartFtraceEvent),
        #[prost(message, tag = "277")]
        AllocPagesSysEnd(super::AllocPagesSysEndFtraceEvent),
        #[prost(message, tag = "278")]
        AllocPagesSysFail(super::AllocPagesSysFailFtraceEvent),
        #[prost(message, tag = "279")]
        AllocPagesSysStart(super::AllocPagesSysStartFtraceEvent),
        #[prost(message, tag = "280")]
        DmaAllocContiguousRetry(super::DmaAllocContiguousRetryFtraceEvent),
        #[prost(message, tag = "281")]
        IommuMapRange(super::IommuMapRangeFtraceEvent),
        #[prost(message, tag = "282")]
        IommuSecPtblMapRangeEnd(super::IommuSecPtblMapRangeEndFtraceEvent),
        #[prost(message, tag = "283")]
        IommuSecPtblMapRangeStart(super::IommuSecPtblMapRangeStartFtraceEvent),
        #[prost(message, tag = "284")]
        IonAllocBufferEnd(super::IonAllocBufferEndFtraceEvent),
        #[prost(message, tag = "285")]
        IonAllocBufferFail(super::IonAllocBufferFailFtraceEvent),
        #[prost(message, tag = "286")]
        IonAllocBufferFallback(super::IonAllocBufferFallbackFtraceEvent),
        #[prost(message, tag = "287")]
        IonAllocBufferStart(super::IonAllocBufferStartFtraceEvent),
        #[prost(message, tag = "288")]
        IonCpAllocRetry(super::IonCpAllocRetryFtraceEvent),
        #[prost(message, tag = "289")]
        IonCpSecureBufferEnd(super::IonCpSecureBufferEndFtraceEvent),
        #[prost(message, tag = "290")]
        IonCpSecureBufferStart(super::IonCpSecureBufferStartFtraceEvent),
        #[prost(message, tag = "291")]
        IonPrefetching(super::IonPrefetchingFtraceEvent),
        #[prost(message, tag = "292")]
        IonSecureCmaAddToPoolEnd(super::IonSecureCmaAddToPoolEndFtraceEvent),
        #[prost(message, tag = "293")]
        IonSecureCmaAddToPoolStart(super::IonSecureCmaAddToPoolStartFtraceEvent),
        #[prost(message, tag = "294")]
        IonSecureCmaAllocateEnd(super::IonSecureCmaAllocateEndFtraceEvent),
        #[prost(message, tag = "295")]
        IonSecureCmaAllocateStart(super::IonSecureCmaAllocateStartFtraceEvent),
        #[prost(message, tag = "296")]
        IonSecureCmaShrinkPoolEnd(super::IonSecureCmaShrinkPoolEndFtraceEvent),
        #[prost(message, tag = "297")]
        IonSecureCmaShrinkPoolStart(super::IonSecureCmaShrinkPoolStartFtraceEvent),
        #[prost(message, tag = "298")]
        Kfree(super::KfreeFtraceEvent),
        #[prost(message, tag = "299")]
        Kmalloc(super::KmallocFtraceEvent),
        #[prost(message, tag = "300")]
        KmallocNode(super::KmallocNodeFtraceEvent),
        #[prost(message, tag = "301")]
        KmemCacheAlloc(super::KmemCacheAllocFtraceEvent),
        #[prost(message, tag = "302")]
        KmemCacheAllocNode(super::KmemCacheAllocNodeFtraceEvent),
        #[prost(message, tag = "303")]
        KmemCacheFree(super::KmemCacheFreeFtraceEvent),
        #[prost(message, tag = "304")]
        MigratePagesEnd(super::MigratePagesEndFtraceEvent),
        #[prost(message, tag = "305")]
        MigratePagesStart(super::MigratePagesStartFtraceEvent),
        #[prost(message, tag = "306")]
        MigrateRetry(super::MigrateRetryFtraceEvent),
        #[prost(message, tag = "307")]
        MmPageAlloc(super::MmPageAllocFtraceEvent),
        #[prost(message, tag = "308")]
        MmPageAllocExtfrag(super::MmPageAllocExtfragFtraceEvent),
        #[prost(message, tag = "309")]
        MmPageAllocZoneLocked(super::MmPageAllocZoneLockedFtraceEvent),
        #[prost(message, tag = "310")]
        MmPageFree(super::MmPageFreeFtraceEvent),
        #[prost(message, tag = "311")]
        MmPageFreeBatched(super::MmPageFreeBatchedFtraceEvent),
        #[prost(message, tag = "312")]
        MmPagePcpuDrain(super::MmPagePcpuDrainFtraceEvent),
        #[prost(message, tag = "313")]
        RssStat(super::RssStatFtraceEvent),
        #[prost(message, tag = "314")]
        IonHeapShrink(super::IonHeapShrinkFtraceEvent),
        #[prost(message, tag = "315")]
        IonHeapGrow(super::IonHeapGrowFtraceEvent),
        #[prost(message, tag = "316")]
        FenceInit(super::FenceInitFtraceEvent),
        #[prost(message, tag = "317")]
        FenceDestroy(super::FenceDestroyFtraceEvent),
        #[prost(message, tag = "318")]
        FenceEnableSignal(super::FenceEnableSignalFtraceEvent),
        #[prost(message, tag = "319")]
        FenceSignaled(super::FenceSignaledFtraceEvent),
        #[prost(message, tag = "320")]
        ClkEnable(super::ClkEnableFtraceEvent),
        #[prost(message, tag = "321")]
        ClkDisable(super::ClkDisableFtraceEvent),
        #[prost(message, tag = "322")]
        ClkSetRate(super::ClkSetRateFtraceEvent),
        #[prost(message, tag = "323")]
        BinderTransactionAllocBuf(super::BinderTransactionAllocBufFtraceEvent),
        #[prost(message, tag = "324")]
        SignalDeliver(super::SignalDeliverFtraceEvent),
        #[prost(message, tag = "325")]
        SignalGenerate(super::SignalGenerateFtraceEvent),
        #[prost(message, tag = "326")]
        OomScoreAdjUpdate(super::OomScoreAdjUpdateFtraceEvent),
        #[prost(message, tag = "327")]
        Generic(super::GenericFtraceEvent),
        #[prost(message, tag = "328")]
        MmEventRecord(super::MmEventRecordFtraceEvent),
        #[prost(message, tag = "329")]
        SysEnter(super::SysEnterFtraceEvent),
        #[prost(message, tag = "330")]
        SysExit(super::SysExitFtraceEvent),
        #[prost(message, tag = "331")]
        Zero(super::ZeroFtraceEvent),
        #[prost(message, tag = "332")]
        GpuFrequency(super::GpuFrequencyFtraceEvent),
        #[prost(message, tag = "333")]
        SdeTracingMarkWrite(super::SdeTracingMarkWriteFtraceEvent),
        #[prost(message, tag = "334")]
        MarkVictim(super::MarkVictimFtraceEvent),
        #[prost(message, tag = "335")]
        IonStat(super::IonStatFtraceEvent),
        #[prost(message, tag = "336")]
        IonBufferCreate(super::IonBufferCreateFtraceEvent),
        #[prost(message, tag = "337")]
        IonBufferDestroy(super::IonBufferDestroyFtraceEvent),
        #[prost(message, tag = "338")]
        ScmCallStart(super::ScmCallStartFtraceEvent),
        #[prost(message, tag = "339")]
        ScmCallEnd(super::ScmCallEndFtraceEvent),
        #[prost(message, tag = "340")]
        GpuMemTotal(super::GpuMemTotalFtraceEvent),
        #[prost(message, tag = "341")]
        ThermalTemperature(super::ThermalTemperatureFtraceEvent),
        #[prost(message, tag = "342")]
        CdevUpdate(super::CdevUpdateFtraceEvent),
        #[prost(message, tag = "343")]
        CpuhpExit(super::CpuhpExitFtraceEvent),
        #[prost(message, tag = "344")]
        CpuhpMultiEnter(super::CpuhpMultiEnterFtraceEvent),
        #[prost(message, tag = "345")]
        CpuhpEnter(super::CpuhpEnterFtraceEvent),
        #[prost(message, tag = "346")]
        CpuhpLatency(super::CpuhpLatencyFtraceEvent),
        #[prost(message, tag = "347")]
        FastrpcDmaStat(super::FastrpcDmaStatFtraceEvent),
        #[prost(message, tag = "348")]
        DpuTracingMarkWrite(super::DpuTracingMarkWriteFtraceEvent),
        #[prost(message, tag = "349")]
        G2dTracingMarkWrite(super::G2dTracingMarkWriteFtraceEvent),
        #[prost(message, tag = "350")]
        MaliTracingMarkWrite(super::MaliTracingMarkWriteFtraceEvent),
        #[prost(message, tag = "351")]
        DmaHeapStat(super::DmaHeapStatFtraceEvent),
        #[prost(message, tag = "352")]
        CpuhpPause(super::CpuhpPauseFtraceEvent),
        #[prost(message, tag = "353")]
        SchedPiSetprio(super::SchedPiSetprioFtraceEvent),
        #[prost(message, tag = "354")]
        SdeSdeEvtlog(super::SdeSdeEvtlogFtraceEvent),
        #[prost(message, tag = "355")]
        SdeSdePerfCalcCrtc(super::SdeSdePerfCalcCrtcFtraceEvent),
        #[prost(message, tag = "356")]
        SdeSdePerfCrtcUpdate(super::SdeSdePerfCrtcUpdateFtraceEvent),
        #[prost(message, tag = "357")]
        SdeSdePerfSetQosLuts(super::SdeSdePerfSetQosLutsFtraceEvent),
        #[prost(message, tag = "358")]
        SdeSdePerfUpdateBus(super::SdeSdePerfUpdateBusFtraceEvent),
        #[prost(message, tag = "359")]
        RssStatThrottled(super::RssStatThrottledFtraceEvent),
        #[prost(message, tag = "360")]
        NetifReceiveSkb(super::NetifReceiveSkbFtraceEvent),
        #[prost(message, tag = "361")]
        NetDevXmit(super::NetDevXmitFtraceEvent),
        #[prost(message, tag = "362")]
        InetSockSetState(super::InetSockSetStateFtraceEvent),
        #[prost(message, tag = "363")]
        TcpRetransmitSkb(super::TcpRetransmitSkbFtraceEvent),
        #[prost(message, tag = "364")]
        CrosEcSensorhubData(super::CrosEcSensorhubDataFtraceEvent),
        #[prost(message, tag = "365")]
        NapiGroReceiveEntry(super::NapiGroReceiveEntryFtraceEvent),
        #[prost(message, tag = "366")]
        NapiGroReceiveExit(super::NapiGroReceiveExitFtraceEvent),
        #[prost(message, tag = "367")]
        KfreeSkb(super::KfreeSkbFtraceEvent),
        #[prost(message, tag = "368")]
        KvmAccessFault(super::KvmAccessFaultFtraceEvent),
        #[prost(message, tag = "369")]
        KvmAckIrq(super::KvmAckIrqFtraceEvent),
        #[prost(message, tag = "370")]
        KvmAgeHva(super::KvmAgeHvaFtraceEvent),
        #[prost(message, tag = "371")]
        KvmAgePage(super::KvmAgePageFtraceEvent),
        #[prost(message, tag = "372")]
        KvmArmClearDebug(super::KvmArmClearDebugFtraceEvent),
        #[prost(message, tag = "373")]
        KvmArmSetDreg32(super::KvmArmSetDreg32FtraceEvent),
        #[prost(message, tag = "374")]
        KvmArmSetRegset(super::KvmArmSetRegsetFtraceEvent),
        #[prost(message, tag = "375")]
        KvmArmSetupDebug(super::KvmArmSetupDebugFtraceEvent),
        #[prost(message, tag = "376")]
        KvmEntry(super::KvmEntryFtraceEvent),
        #[prost(message, tag = "377")]
        KvmExit(super::KvmExitFtraceEvent),
        #[prost(message, tag = "378")]
        KvmFpu(super::KvmFpuFtraceEvent),
        #[prost(message, tag = "379")]
        KvmGetTimerMap(super::KvmGetTimerMapFtraceEvent),
        #[prost(message, tag = "380")]
        KvmGuestFault(super::KvmGuestFaultFtraceEvent),
        #[prost(message, tag = "381")]
        KvmHandleSysReg(super::KvmHandleSysRegFtraceEvent),
        #[prost(message, tag = "382")]
        KvmHvcArm64(super::KvmHvcArm64FtraceEvent),
        #[prost(message, tag = "383")]
        KvmIrqLine(super::KvmIrqLineFtraceEvent),
        #[prost(message, tag = "384")]
        KvmMmio(super::KvmMmioFtraceEvent),
        #[prost(message, tag = "385")]
        KvmMmioEmulate(super::KvmMmioEmulateFtraceEvent),
        #[prost(message, tag = "386")]
        KvmSetGuestDebug(super::KvmSetGuestDebugFtraceEvent),
        #[prost(message, tag = "387")]
        KvmSetIrq(super::KvmSetIrqFtraceEvent),
        #[prost(message, tag = "388")]
        KvmSetSpteHva(super::KvmSetSpteHvaFtraceEvent),
        #[prost(message, tag = "389")]
        KvmSetWayFlush(super::KvmSetWayFlushFtraceEvent),
        #[prost(message, tag = "390")]
        KvmSysAccess(super::KvmSysAccessFtraceEvent),
        #[prost(message, tag = "391")]
        KvmTestAgeHva(super::KvmTestAgeHvaFtraceEvent),
        #[prost(message, tag = "392")]
        KvmTimerEmulate(super::KvmTimerEmulateFtraceEvent),
        #[prost(message, tag = "393")]
        KvmTimerHrtimerExpire(super::KvmTimerHrtimerExpireFtraceEvent),
        #[prost(message, tag = "394")]
        KvmTimerRestoreState(super::KvmTimerRestoreStateFtraceEvent),
        #[prost(message, tag = "395")]
        KvmTimerSaveState(super::KvmTimerSaveStateFtraceEvent),
        #[prost(message, tag = "396")]
        KvmTimerUpdateIrq(super::KvmTimerUpdateIrqFtraceEvent),
        #[prost(message, tag = "397")]
        KvmToggleCache(super::KvmToggleCacheFtraceEvent),
        #[prost(message, tag = "398")]
        KvmUnmapHvaRange(super::KvmUnmapHvaRangeFtraceEvent),
        #[prost(message, tag = "399")]
        KvmUserspaceExit(super::KvmUserspaceExitFtraceEvent),
        #[prost(message, tag = "400")]
        KvmVcpuWakeup(super::KvmVcpuWakeupFtraceEvent),
        #[prost(message, tag = "401")]
        KvmWfxArm64(super::KvmWfxArm64FtraceEvent),
        #[prost(message, tag = "402")]
        TrapReg(super::TrapRegFtraceEvent),
        #[prost(message, tag = "403")]
        VgicUpdateIrqPending(super::VgicUpdateIrqPendingFtraceEvent),
        #[prost(message, tag = "404")]
        WakeupSourceActivate(super::WakeupSourceActivateFtraceEvent),
        #[prost(message, tag = "405")]
        WakeupSourceDeactivate(super::WakeupSourceDeactivateFtraceEvent),
        #[prost(message, tag = "406")]
        UfshcdCommand(super::UfshcdCommandFtraceEvent),
        #[prost(message, tag = "407")]
        UfshcdClkGating(super::UfshcdClkGatingFtraceEvent),
        #[prost(message, tag = "408")]
        Console(super::ConsoleFtraceEvent),
        #[prost(message, tag = "409")]
        DrmVblankEvent(super::DrmVblankEventFtraceEvent),
        #[prost(message, tag = "410")]
        DrmVblankEventDelivered(super::DrmVblankEventDeliveredFtraceEvent),
        #[prost(message, tag = "411")]
        DrmSchedJob(super::DrmSchedJobFtraceEvent),
        #[prost(message, tag = "412")]
        DrmRunJob(super::DrmRunJobFtraceEvent),
        #[prost(message, tag = "413")]
        DrmSchedProcessJob(super::DrmSchedProcessJobFtraceEvent),
        #[prost(message, tag = "414")]
        DmaFenceInit(super::DmaFenceInitFtraceEvent),
        #[prost(message, tag = "415")]
        DmaFenceEmit(super::DmaFenceEmitFtraceEvent),
        #[prost(message, tag = "416")]
        DmaFenceSignaled(super::DmaFenceSignaledFtraceEvent),
        #[prost(message, tag = "417")]
        DmaFenceWaitStart(super::DmaFenceWaitStartFtraceEvent),
        #[prost(message, tag = "418")]
        DmaFenceWaitEnd(super::DmaFenceWaitEndFtraceEvent),
        #[prost(message, tag = "419")]
        F2fsIostat(super::F2fsIostatFtraceEvent),
        #[prost(message, tag = "420")]
        F2fsIostatLatency(super::F2fsIostatLatencyFtraceEvent),
        #[prost(message, tag = "421")]
        SchedCpuUtilCfs(super::SchedCpuUtilCfsFtraceEvent),
        #[prost(message, tag = "422")]
        V4l2Qbuf(super::V4l2QbufFtraceEvent),
        #[prost(message, tag = "423")]
        V4l2Dqbuf(super::V4l2DqbufFtraceEvent),
        #[prost(message, tag = "424")]
        Vb2V4l2BufQueue(super::Vb2V4l2BufQueueFtraceEvent),
        #[prost(message, tag = "425")]
        Vb2V4l2BufDone(super::Vb2V4l2BufDoneFtraceEvent),
        #[prost(message, tag = "426")]
        Vb2V4l2Qbuf(super::Vb2V4l2QbufFtraceEvent),
        #[prost(message, tag = "427")]
        Vb2V4l2Dqbuf(super::Vb2V4l2DqbufFtraceEvent),
        #[prost(message, tag = "428")]
        DsiCmdFifoStatus(super::DsiCmdFifoStatusFtraceEvent),
        #[prost(message, tag = "429")]
        DsiRx(super::DsiRxFtraceEvent),
        #[prost(message, tag = "430")]
        DsiTx(super::DsiTxFtraceEvent),
        #[prost(message, tag = "431")]
        AndroidFsDatareadEnd(super::AndroidFsDatareadEndFtraceEvent),
        #[prost(message, tag = "432")]
        AndroidFsDatareadStart(super::AndroidFsDatareadStartFtraceEvent),
        #[prost(message, tag = "433")]
        AndroidFsDatawriteEnd(super::AndroidFsDatawriteEndFtraceEvent),
        #[prost(message, tag = "434")]
        AndroidFsDatawriteStart(super::AndroidFsDatawriteStartFtraceEvent),
        #[prost(message, tag = "435")]
        AndroidFsFsyncEnd(super::AndroidFsFsyncEndFtraceEvent),
        #[prost(message, tag = "436")]
        AndroidFsFsyncStart(super::AndroidFsFsyncStartFtraceEvent),
        #[prost(message, tag = "437")]
        FuncgraphEntry(super::FuncgraphEntryFtraceEvent),
        #[prost(message, tag = "438")]
        FuncgraphExit(super::FuncgraphExitFtraceEvent),
        #[prost(message, tag = "439")]
        VirtioVideoCmd(super::VirtioVideoCmdFtraceEvent),
        #[prost(message, tag = "440")]
        VirtioVideoCmdDone(super::VirtioVideoCmdDoneFtraceEvent),
        #[prost(message, tag = "441")]
        VirtioVideoResourceQueue(super::VirtioVideoResourceQueueFtraceEvent),
        #[prost(message, tag = "442")]
        VirtioVideoResourceQueueDone(super::VirtioVideoResourceQueueDoneFtraceEvent),
        #[prost(message, tag = "443")]
        MmShrinkSlabStart(super::MmShrinkSlabStartFtraceEvent),
        #[prost(message, tag = "444")]
        MmShrinkSlabEnd(super::MmShrinkSlabEndFtraceEvent),
        #[prost(message, tag = "445")]
        TrustySmc(super::TrustySmcFtraceEvent),
        #[prost(message, tag = "446")]
        TrustySmcDone(super::TrustySmcDoneFtraceEvent),
        #[prost(message, tag = "447")]
        TrustyStdCall32(super::TrustyStdCall32FtraceEvent),
        #[prost(message, tag = "448")]
        TrustyStdCall32Done(super::TrustyStdCall32DoneFtraceEvent),
        #[prost(message, tag = "449")]
        TrustyShareMemory(super::TrustyShareMemoryFtraceEvent),
        #[prost(message, tag = "450")]
        TrustyShareMemoryDone(super::TrustyShareMemoryDoneFtraceEvent),
        #[prost(message, tag = "451")]
        TrustyReclaimMemory(super::TrustyReclaimMemoryFtraceEvent),
        #[prost(message, tag = "452")]
        TrustyReclaimMemoryDone(super::TrustyReclaimMemoryDoneFtraceEvent),
        #[prost(message, tag = "453")]
        TrustyIrq(super::TrustyIrqFtraceEvent),
        #[prost(message, tag = "454")]
        TrustyIpcHandleEvent(super::TrustyIpcHandleEventFtraceEvent),
        #[prost(message, tag = "455")]
        TrustyIpcConnect(super::TrustyIpcConnectFtraceEvent),
        #[prost(message, tag = "456")]
        TrustyIpcConnectEnd(super::TrustyIpcConnectEndFtraceEvent),
        #[prost(message, tag = "457")]
        TrustyIpcWrite(super::TrustyIpcWriteFtraceEvent),
        #[prost(message, tag = "458")]
        TrustyIpcPoll(super::TrustyIpcPollFtraceEvent),
        /// removed field with id 459;
        #[prost(message, tag = "460")]
        TrustyIpcRead(super::TrustyIpcReadFtraceEvent),
        #[prost(message, tag = "461")]
        TrustyIpcReadEnd(super::TrustyIpcReadEndFtraceEvent),
        #[prost(message, tag = "462")]
        TrustyIpcRx(super::TrustyIpcRxFtraceEvent),
        /// removed field with id 463;
        #[prost(message, tag = "464")]
        TrustyEnqueueNop(super::TrustyEnqueueNopFtraceEvent),
        #[prost(message, tag = "465")]
        CmaAllocStart(super::CmaAllocStartFtraceEvent),
        #[prost(message, tag = "466")]
        CmaAllocInfo(super::CmaAllocInfoFtraceEvent),
        #[prost(message, tag = "467")]
        LwisTracingMarkWrite(super::LwisTracingMarkWriteFtraceEvent),
        #[prost(message, tag = "468")]
        VirtioGpuCmdQueue(super::VirtioGpuCmdQueueFtraceEvent),
        #[prost(message, tag = "469")]
        VirtioGpuCmdResponse(super::VirtioGpuCmdResponseFtraceEvent),
        #[prost(message, tag = "470")]
        MaliMaliKcpuCqsSet(super::MaliMaliKcpucqssetFtraceEvent),
        #[prost(message, tag = "471")]
        MaliMaliKcpuCqsWaitStart(super::MaliMaliKcpucqswaitstartFtraceEvent),
        #[prost(message, tag = "472")]
        MaliMaliKcpuCqsWaitEnd(super::MaliMaliKcpucqswaitendFtraceEvent),
        #[prost(message, tag = "473")]
        MaliMaliKcpuFenceSignal(super::MaliMaliKcpufencesignalFtraceEvent),
        #[prost(message, tag = "474")]
        MaliMaliKcpuFenceWaitStart(super::MaliMaliKcpufencewaitstartFtraceEvent),
        #[prost(message, tag = "475")]
        MaliMaliKcpuFenceWaitEnd(super::MaliMaliKcpufencewaitendFtraceEvent),
        #[prost(message, tag = "476")]
        HypEnter(super::HypEnterFtraceEvent),
        #[prost(message, tag = "477")]
        HypExit(super::HypExitFtraceEvent),
        #[prost(message, tag = "478")]
        HostHcall(super::HostHcallFtraceEvent),
        #[prost(message, tag = "479")]
        HostSmc(super::HostSmcFtraceEvent),
        #[prost(message, tag = "480")]
        HostMemAbort(super::HostMemAbortFtraceEvent),
        #[prost(message, tag = "481")]
        SuspendResumeMinimal(super::SuspendResumeMinimalFtraceEvent),
        #[prost(message, tag = "482")]
        MaliMaliCsfInterruptStart(super::MaliMaliCsfinterruptstartFtraceEvent),
        #[prost(message, tag = "483")]
        MaliMaliCsfInterruptEnd(super::MaliMaliCsfinterruptendFtraceEvent),
        #[prost(message, tag = "484")]
        SamsungTracingMarkWrite(super::SamsungTracingMarkWriteFtraceEvent),
        #[prost(message, tag = "485")]
        BinderCommand(super::BinderCommandFtraceEvent),
        #[prost(message, tag = "486")]
        BinderReturn(super::BinderReturnFtraceEvent),
        #[prost(message, tag = "487")]
        SchedSwitchWithCtrs(super::SchedSwitchWithCtrsFtraceEvent),
        #[prost(message, tag = "488")]
        GpuWorkPeriod(super::GpuWorkPeriodFtraceEvent),
        #[prost(message, tag = "489")]
        RpmStatus(super::RpmStatusFtraceEvent),
        #[prost(message, tag = "490")]
        PanelWriteGeneric(super::PanelWriteGenericFtraceEvent),
        #[prost(message, tag = "491")]
        SchedMigrateTask(super::SchedMigrateTaskFtraceEvent),
        #[prost(message, tag = "492")]
        DpuDsiCmdFifoStatus(super::DpuDsiCmdFifoStatusFtraceEvent),
        #[prost(message, tag = "493")]
        DpuDsiRx(super::DpuDsiRxFtraceEvent),
        #[prost(message, tag = "494")]
        DpuDsiTx(super::DpuDsiTxFtraceEvent),
        #[prost(message, tag = "495")]
        F2fsBackgroundGc(super::F2fsBackgroundGcFtraceEvent),
        #[prost(message, tag = "496")]
        F2fsGcBegin(super::F2fsGcBeginFtraceEvent),
        #[prost(message, tag = "497")]
        F2fsGcEnd(super::F2fsGcEndFtraceEvent),
        #[prost(message, tag = "498")]
        FastrpcDmaFree(super::FastrpcDmaFreeFtraceEvent),
        #[prost(message, tag = "499")]
        FastrpcDmaAlloc(super::FastrpcDmaAllocFtraceEvent),
        #[prost(message, tag = "500")]
        FastrpcDmaUnmap(super::FastrpcDmaUnmapFtraceEvent),
        #[prost(message, tag = "501")]
        FastrpcDmaMap(super::FastrpcDmaMapFtraceEvent),
        #[prost(message, tag = "502")]
        GoogleIccEvent(super::GoogleIccEventFtraceEvent),
        #[prost(message, tag = "503")]
        GoogleIrmEvent(super::GoogleIrmEventFtraceEvent),
        #[prost(message, tag = "504")]
        DevicePmCallbackStart(super::DevicePmCallbackStartFtraceEvent),
        #[prost(message, tag = "505")]
        DevicePmCallbackEnd(super::DevicePmCallbackEndFtraceEvent),
        #[prost(message, tag = "506")]
        ThermalExynosAcpmBulk(super::ThermalExynosAcpmBulkFtraceEvent),
        #[prost(message, tag = "507")]
        ThermalExynosAcpmHighOverhead(super::ThermalExynosAcpmHighOverheadFtraceEvent),
        #[prost(message, tag = "508")]
        DcvshFreq(super::DcvshFreqFtraceEvent),
        #[prost(message, tag = "509")]
        KgslGpuFrequency(super::KgslGpuFrequencyFtraceEvent),
        #[prost(message, tag = "510")]
        MaliMaliPmMcuHctlCoresDownScaleNotifyPend(
            super::MaliMaliPmmcuhctlcoresdownscalenotifypendFtraceEvent,
        ),
        #[prost(message, tag = "511")]
        MaliMaliPmMcuHctlCoresNotifyPend(
            super::MaliMaliPmmcuhctlcoresnotifypendFtraceEvent,
        ),
        #[prost(message, tag = "512")]
        MaliMaliPmMcuHctlCoreInactivePend(
            super::MaliMaliPmmcuhctlcoreinactivependFtraceEvent,
        ),
        #[prost(message, tag = "513")]
        MaliMaliPmMcuHctlMcuOnRecheck(super::MaliMaliPmmcuhctlmcuonrecheckFtraceEvent),
        #[prost(message, tag = "514")]
        MaliMaliPmMcuHctlShadersCoreOffPend(
            super::MaliMaliPmmcuhctlshaderscoreoffpendFtraceEvent,
        ),
        #[prost(message, tag = "515")]
        MaliMaliPmMcuHctlShadersPendOff(
            super::MaliMaliPmmcuhctlshaderspendoffFtraceEvent,
        ),
        #[prost(message, tag = "516")]
        MaliMaliPmMcuHctlShadersPendOn(super::MaliMaliPmmcuhctlshaderspendonFtraceEvent),
        #[prost(message, tag = "517")]
        MaliMaliPmMcuHctlShadersReadyOff(
            super::MaliMaliPmmcuhctlshadersreadyoffFtraceEvent,
        ),
        #[prost(message, tag = "518")]
        MaliMaliPmMcuInSleep(super::MaliMaliPmmcuinsleepFtraceEvent),
        #[prost(message, tag = "519")]
        MaliMaliPmMcuOff(super::MaliMaliPmmcuoffFtraceEvent),
        #[prost(message, tag = "520")]
        MaliMaliPmMcuOn(super::MaliMaliPmmcuonFtraceEvent),
        #[prost(message, tag = "521")]
        MaliMaliPmMcuOnCoreAttrUpdatePend(
            super::MaliMaliPmmcuoncoreattrupdatependFtraceEvent,
        ),
        #[prost(message, tag = "522")]
        MaliMaliPmMcuOnGlbReinitPend(super::MaliMaliPmmcuonglbreinitpendFtraceEvent),
        #[prost(message, tag = "523")]
        MaliMaliPmMcuOnHalt(super::MaliMaliPmmcuonhaltFtraceEvent),
        #[prost(message, tag = "524")]
        MaliMaliPmMcuOnHwcntDisable(super::MaliMaliPmmcuonhwcntdisableFtraceEvent),
        #[prost(message, tag = "525")]
        MaliMaliPmMcuOnHwcntEnable(super::MaliMaliPmmcuonhwcntenableFtraceEvent),
        #[prost(message, tag = "526")]
        MaliMaliPmMcuOnPendHalt(super::MaliMaliPmmcuonpendhaltFtraceEvent),
        #[prost(message, tag = "527")]
        MaliMaliPmMcuOnPendSleep(super::MaliMaliPmmcuonpendsleepFtraceEvent),
        #[prost(message, tag = "528")]
        MaliMaliPmMcuOnSleepInitiate(super::MaliMaliPmmcuonsleepinitiateFtraceEvent),
        #[prost(message, tag = "529")]
        MaliMaliPmMcuPendOff(super::MaliMaliPmmcupendoffFtraceEvent),
        #[prost(message, tag = "530")]
        MaliMaliPmMcuPendOnReload(super::MaliMaliPmmcupendonreloadFtraceEvent),
        #[prost(message, tag = "531")]
        MaliMaliPmMcuPowerDown(super::MaliMaliPmmcupowerdownFtraceEvent),
        #[prost(message, tag = "532")]
        MaliMaliPmMcuResetWait(super::MaliMaliPmmcuresetwaitFtraceEvent),
    }
}
/// Per-CPU kernel buffer stats for the ftrace data source gathered from
/// /sys/kernel/tracing/per_cpu/cpuX/stats.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FtraceCpuStats {
    /// CPU index.
    #[prost(uint64, optional, tag = "1")]
    pub cpu: ::core::option::Option<u64>,
    /// Number of entries currently in the kernel buffer.
    #[prost(uint64, optional, tag = "2")]
    pub entries: ::core::option::Option<u64>,
    /// Number of events lost in kernel buffers due to overwriting of old events
    /// before userspace had a chance to drain them. Valid if the buffer is in
    /// "overwrite" mode, otherwise see |dropped_events|.
    #[prost(uint64, optional, tag = "3")]
    pub overrun: ::core::option::Option<u64>,
    /// This should always be zero. If not the buffer size is way too small or
    /// something went wrong with the tracer. Quoting the kernel: "number of
    /// commits failing due to the buffer wrapping around while there are
    /// uncommitted events, such as during an interrupt storm".
    #[prost(uint64, optional, tag = "4")]
    pub commit_overrun: ::core::option::Option<u64>,
    /// Size of entries currently in the kernel buffer (see |entries|) in bytes.
    /// The field should be named "bytes", but is misnamed for historical reasons.
    /// This value has known inaccuracies before Linux v6.6:
    /// <https://github.com/torvalds/linux/commit/45d99ea>
    #[prost(uint64, optional, tag = "5")]
    pub bytes_read: ::core::option::Option<u64>,
    /// The timestamp for the oldest event still in the ring buffer.
    /// Unit: seconds for typical trace clocks (i.e. not tsc/counter).
    #[prost(double, optional, tag = "6")]
    pub oldest_event_ts: ::core::option::Option<f64>,
    /// The current timestamp.
    /// Unit: seconds for typical trace clocks (i.e. not tsc/counter).
    #[prost(double, optional, tag = "7")]
    pub now_ts: ::core::option::Option<f64>,
    /// If the kernel buffer has overwrite mode disabled, this will show the number
    /// of new events that were lost because the buffer was full. This is similar
    /// to |overrun| but only for the overwrite=false case.
    #[prost(uint64, optional, tag = "8")]
    pub dropped_events: ::core::option::Option<u64>,
    /// The number of events read (consumed) from the buffer by userspace.
    #[prost(uint64, optional, tag = "9")]
    pub read_events: ::core::option::Option<u64>,
}
/// Errors and kernel buffer stats for the ftrace data source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtraceStats {
    /// A pair of FtraceStats is written on every trace flush:
    /// * START_OF_TRACE - stats recorded at the beginning of the trace.
    /// * END_OF_TRACE - stats recorded during the flush. In other words shortly
    ///                   before this packet was written. For simple traces this
    ///                   will be once at the end of the trace.
    #[prost(enumeration = "ftrace_stats::Phase", optional, tag = "1")]
    pub phase: ::core::option::Option<i32>,
    /// Per-CPU stats (one entry for each CPU).
    #[prost(message, repeated, tag = "2")]
    pub cpu_stats: ::prost::alloc::vec::Vec<FtraceCpuStats>,
    /// When FtraceConfig.symbolize_ksyms = true, this records the number of
    /// symbols parsed from /proc/kallsyms, whether they have been seen in the
    /// trace or not. It can be used to debug kptr_restrict or security-related
    /// errors.
    /// Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
    /// initialized. When START_OF_TRACE is emitted it is not ready yet.
    #[prost(uint32, optional, tag = "3")]
    pub kernel_symbols_parsed: ::core::option::Option<u32>,
    /// The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
    #[prost(uint32, optional, tag = "4")]
    pub kernel_symbols_mem_kb: ::core::option::Option<u32>,
    /// Atrace errors (even non-fatal ones) are reported here. A typical example is
    /// one or more atrace categories not available on the device.
    #[prost(string, optional, tag = "5")]
    pub atrace_errors: ::core::option::Option<::prost::alloc::string::String>,
    /// Ftrace events requested by the config but not present on device.
    #[prost(string, repeated, tag = "6")]
    pub unknown_ftrace_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ftrace events requested by the config and present on device, but which we
    /// failed to enable due to permissions, or due to a conflicting option
    /// (currently FtraceConfig.disable_generic_events).
    #[prost(string, repeated, tag = "7")]
    pub failed_ftrace_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The data source was configured to preserve existing events in the ftrace
    /// buffer before the start of the trace.
    #[prost(bool, optional, tag = "8")]
    pub preserve_ftrace_buffer: ::core::option::Option<bool>,
    /// Unique errors encountered during reading and parsing of the raw ftrace
    /// data. Ring buffer ABI related errors will also be recorded in the
    /// affected FtraceEventBundles with a timestamp.
    /// Any traces with entries in this field should be investigated, as they
    /// indicate a bug in perfetto or the kernel.
    #[prost(enumeration = "FtraceParseStatus", repeated, packed = "false", tag = "9")]
    pub ftrace_parse_errors: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `FtraceStats`.
pub mod ftrace_stats {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Phase {
        Unspecified = 0,
        StartOfTrace = 1,
        EndOfTrace = 2,
    }
    impl Phase {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::StartOfTrace => "START_OF_TRACE",
                Self::EndOfTrace => "END_OF_TRACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "START_OF_TRACE" => Some(Self::StartOfTrace),
                "END_OF_TRACE" => Some(Self::EndOfTrace),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FtraceParseStatus {
    FtraceStatusUnspecified = 0,
    /// Not written, used for convenience of implementation:
    FtraceStatusOk = 1,
    /// Issues with reading data out of the ftrace ring buffer:
    FtraceStatusUnexpectedReadError = 2,
    FtraceStatusPartialPageRead = 3,
    /// Ring buffer binary data not matching our understanding of the layout:
    FtraceStatusAbiInvalidPageHeader = 4,
    FtraceStatusAbiShortEventHeader = 5,
    FtraceStatusAbiNullPadding = 6,
    FtraceStatusAbiShortPaddingLength = 7,
    FtraceStatusAbiInvalidPaddingLength = 8,
    FtraceStatusAbiShortTimeExtend = 9,
    FtraceStatusAbiShortTimeStamp = 10,
    FtraceStatusAbiShortDataLength = 11,
    FtraceStatusAbiZeroDataLength = 12,
    FtraceStatusAbiInvalidDataLength = 13,
    FtraceStatusAbiShortEventId = 14,
    FtraceStatusAbiEndOverflow = 15,
    /// Issues with parsing the event payload:
    FtraceStatusShortCompactEvent = 16,
    FtraceStatusInvalidEvent = 17,
}
impl FtraceParseStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FtraceStatusUnspecified => "FTRACE_STATUS_UNSPECIFIED",
            Self::FtraceStatusOk => "FTRACE_STATUS_OK",
            Self::FtraceStatusUnexpectedReadError => {
                "FTRACE_STATUS_UNEXPECTED_READ_ERROR"
            }
            Self::FtraceStatusPartialPageRead => "FTRACE_STATUS_PARTIAL_PAGE_READ",
            Self::FtraceStatusAbiInvalidPageHeader => {
                "FTRACE_STATUS_ABI_INVALID_PAGE_HEADER"
            }
            Self::FtraceStatusAbiShortEventHeader => {
                "FTRACE_STATUS_ABI_SHORT_EVENT_HEADER"
            }
            Self::FtraceStatusAbiNullPadding => "FTRACE_STATUS_ABI_NULL_PADDING",
            Self::FtraceStatusAbiShortPaddingLength => {
                "FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH"
            }
            Self::FtraceStatusAbiInvalidPaddingLength => {
                "FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH"
            }
            Self::FtraceStatusAbiShortTimeExtend => "FTRACE_STATUS_ABI_SHORT_TIME_EXTEND",
            Self::FtraceStatusAbiShortTimeStamp => "FTRACE_STATUS_ABI_SHORT_TIME_STAMP",
            Self::FtraceStatusAbiShortDataLength => "FTRACE_STATUS_ABI_SHORT_DATA_LENGTH",
            Self::FtraceStatusAbiZeroDataLength => "FTRACE_STATUS_ABI_ZERO_DATA_LENGTH",
            Self::FtraceStatusAbiInvalidDataLength => {
                "FTRACE_STATUS_ABI_INVALID_DATA_LENGTH"
            }
            Self::FtraceStatusAbiShortEventId => "FTRACE_STATUS_ABI_SHORT_EVENT_ID",
            Self::FtraceStatusAbiEndOverflow => "FTRACE_STATUS_ABI_END_OVERFLOW",
            Self::FtraceStatusShortCompactEvent => "FTRACE_STATUS_SHORT_COMPACT_EVENT",
            Self::FtraceStatusInvalidEvent => "FTRACE_STATUS_INVALID_EVENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FTRACE_STATUS_UNSPECIFIED" => Some(Self::FtraceStatusUnspecified),
            "FTRACE_STATUS_OK" => Some(Self::FtraceStatusOk),
            "FTRACE_STATUS_UNEXPECTED_READ_ERROR" => {
                Some(Self::FtraceStatusUnexpectedReadError)
            }
            "FTRACE_STATUS_PARTIAL_PAGE_READ" => Some(Self::FtraceStatusPartialPageRead),
            "FTRACE_STATUS_ABI_INVALID_PAGE_HEADER" => {
                Some(Self::FtraceStatusAbiInvalidPageHeader)
            }
            "FTRACE_STATUS_ABI_SHORT_EVENT_HEADER" => {
                Some(Self::FtraceStatusAbiShortEventHeader)
            }
            "FTRACE_STATUS_ABI_NULL_PADDING" => Some(Self::FtraceStatusAbiNullPadding),
            "FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH" => {
                Some(Self::FtraceStatusAbiShortPaddingLength)
            }
            "FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH" => {
                Some(Self::FtraceStatusAbiInvalidPaddingLength)
            }
            "FTRACE_STATUS_ABI_SHORT_TIME_EXTEND" => {
                Some(Self::FtraceStatusAbiShortTimeExtend)
            }
            "FTRACE_STATUS_ABI_SHORT_TIME_STAMP" => {
                Some(Self::FtraceStatusAbiShortTimeStamp)
            }
            "FTRACE_STATUS_ABI_SHORT_DATA_LENGTH" => {
                Some(Self::FtraceStatusAbiShortDataLength)
            }
            "FTRACE_STATUS_ABI_ZERO_DATA_LENGTH" => {
                Some(Self::FtraceStatusAbiZeroDataLength)
            }
            "FTRACE_STATUS_ABI_INVALID_DATA_LENGTH" => {
                Some(Self::FtraceStatusAbiInvalidDataLength)
            }
            "FTRACE_STATUS_ABI_SHORT_EVENT_ID" => Some(Self::FtraceStatusAbiShortEventId),
            "FTRACE_STATUS_ABI_END_OVERFLOW" => Some(Self::FtraceStatusAbiEndOverflow),
            "FTRACE_STATUS_SHORT_COMPACT_EVENT" => {
                Some(Self::FtraceStatusShortCompactEvent)
            }
            "FTRACE_STATUS_INVALID_EVENT" => Some(Self::FtraceStatusInvalidEvent),
            _ => None,
        }
    }
}
/// The result of tracing one or more ftrace data pages from a single per-cpu
/// kernel ring buffer. If collating multiple pages' worth of events, all of
/// them come from contiguous pages, with no kernel data loss in between.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtraceEventBundle {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub event: ::prost::alloc::vec::Vec<FtraceEvent>,
    /// Set to true if there was data loss between the last time we've read from
    /// the corresponding per-cpu kernel buffer, and the earliest event recorded
    /// in this bundle.
    #[prost(bool, optional, tag = "3")]
    pub lost_events: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub compact_sched: ::core::option::Option<ftrace_event_bundle::CompactSched>,
    /// traced_probes always sets the ftrace_clock to "boot". That is not available
    /// in older kernels (v3.x). In that case we fallback on "global" or "local".
    /// When we do that, we report the fallback clock in each bundle so we can do
    /// proper clock syncing at parsing time in TraceProcessor. We cannot use the
    /// TracePacket timestamp_clock_id because: (1) there is no per-packet
    /// timestamp for ftrace bundles; (2) "global" does not match CLOCK_MONOTONIC.
    /// Having a dedicated and explicit flag allows us to correct further misakes
    /// in future by looking at the kernel version.
    /// This field has been introduced in perfetto v19 / Android T (13).
    /// This field is omitted when the ftrace clock is just "boot", as that is the
    /// default assumption (and for consistency with the past).
    #[prost(enumeration = "FtraceClock", optional, tag = "5")]
    pub ftrace_clock: ::core::option::Option<i32>,
    /// The timestamp according to the ftrace clock, taken at the same instant
    /// as |boot_timestamp|. This is used to sync ftrace events when a non-boot
    /// clock is used as the ftrace clock. We don't use the ClockSnapshot packet
    /// because the ftrace global/local clocks don't match any of the clock_gettime
    /// domains and can be only read by traced_probes.
    ///
    /// Only set when |ftrace_clock| != FTRACE_CLOCK_UNSPECIFIED.
    ///
    /// Implementation note: Populated by reading the 'now ts:' field in
    /// tracefs/per_cpu/cpuX/stat.
    #[prost(int64, optional, tag = "6")]
    pub ftrace_timestamp: ::core::option::Option<i64>,
    /// The timestamp according to CLOCK_BOOTTIME, taken at the same instant as
    /// |ftrace_timestamp|. See documentation of |ftrace_timestamp| for
    /// more info.
    ///
    /// Only set when |ftrace_clock| != FTRACE_CLOCK_UNSPECIFIED.
    #[prost(int64, optional, tag = "7")]
    pub boot_timestamp: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "8")]
    pub error: ::prost::alloc::vec::Vec<ftrace_event_bundle::FtraceError>,
    /// The timestamp (ftrace clock) of the last event consumed from this per-cpu
    /// kernel buffer prior to starting this bundle. In other words: the last
    /// event in the previous bundle.
    /// Lets the trace processing find an initial timestamp after which ftrace
    /// data is known to be valid across all cpus. Of particular importance when
    /// the perfetto trace buffer is a ring buffer as well, as the overwriting of
    /// oldest bundles can skew the first valid timestamp per cpu significantly.
    /// Added in: perfetto v44.
    #[prost(uint64, optional, tag = "9")]
    pub last_read_event_timestamp: ::core::option::Option<u64>,
}
/// Nested message and enum types in `FtraceEventBundle`.
pub mod ftrace_event_bundle {
    /// Optionally-enabled compact encoding of a batch of scheduling events. Only
    /// a subset of events & their fields is recorded.
    /// All fields (except comms) are stored in a structure-of-arrays form, one
    /// entry in each repeated field per event.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompactSched {
        /// Interned table of unique strings for this bundle.
        #[prost(string, repeated, tag = "5")]
        pub intern_table: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Delta-encoded timestamps across all sched_switch events within this
        /// bundle. The first is absolute, each next one is relative to its
        /// predecessor.
        #[prost(uint64, repeated, tag = "1")]
        pub switch_timestamp: ::prost::alloc::vec::Vec<u64>,
        #[prost(int64, repeated, tag = "2")]
        pub switch_prev_state: ::prost::alloc::vec::Vec<i64>,
        #[prost(int32, repeated, tag = "3")]
        pub switch_next_pid: ::prost::alloc::vec::Vec<i32>,
        #[prost(int32, repeated, tag = "4")]
        pub switch_next_prio: ::prost::alloc::vec::Vec<i32>,
        /// One per event, index into |intern_table| corresponding to the
        /// next_comm field of the event.
        #[prost(uint32, repeated, tag = "6")]
        pub switch_next_comm_index: ::prost::alloc::vec::Vec<u32>,
        /// Delta-encoded timestamps across all sched_waking events within this
        /// bundle. The first is absolute, each next one is relative to its
        /// predecessor.
        #[prost(uint64, repeated, tag = "7")]
        pub waking_timestamp: ::prost::alloc::vec::Vec<u64>,
        #[prost(int32, repeated, tag = "8")]
        pub waking_pid: ::prost::alloc::vec::Vec<i32>,
        #[prost(int32, repeated, tag = "9")]
        pub waking_target_cpu: ::prost::alloc::vec::Vec<i32>,
        #[prost(int32, repeated, tag = "10")]
        pub waking_prio: ::prost::alloc::vec::Vec<i32>,
        /// One per event, index into |intern_table| corresponding to the
        /// comm field of the event.
        #[prost(uint32, repeated, tag = "11")]
        pub waking_comm_index: ::prost::alloc::vec::Vec<u32>,
        #[prost(uint32, repeated, tag = "12")]
        pub waking_common_flags: ::prost::alloc::vec::Vec<u32>,
    }
    /// Errors encountered during parsing of the raw ftrace data. In case of ring
    /// buffer layout errors, the parser skips the rest of the offending kernel
    /// buffer page and continues from the next page.
    /// See also FtraceStats.ftrace_parse_errors, which collates all unique errors
    /// seen within the duration of the trace (even if the affected bundles get
    /// overwritten in ring buffer mode).
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FtraceError {
        /// Timestamp of the data that we're unable to parse, in the ftrace clock
        /// domain. Currently, we use the base timestamp of the tracing page
        /// containing the bad record rather than the time of the record itself.
        #[prost(uint64, optional, tag = "1")]
        pub timestamp: ::core::option::Option<u64>,
        #[prost(enumeration = "super::FtraceParseStatus", optional, tag = "2")]
        pub status: ::core::option::Option<i32>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FtraceClock {
    /// There is no FTRACE_CLOCK_BOOT entry as that's the default assumption. When
    /// the ftrace clock is "boot", it's just omitted (so UNSPECIFIED == BOOT).
    Unspecified = 0,
    Unknown = 1,
    Global = 2,
    Local = 3,
    MonoRaw = 4,
}
impl FtraceClock {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FTRACE_CLOCK_UNSPECIFIED",
            Self::Unknown => "FTRACE_CLOCK_UNKNOWN",
            Self::Global => "FTRACE_CLOCK_GLOBAL",
            Self::Local => "FTRACE_CLOCK_LOCAL",
            Self::MonoRaw => "FTRACE_CLOCK_MONO_RAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FTRACE_CLOCK_UNSPECIFIED" => Some(Self::Unspecified),
            "FTRACE_CLOCK_UNKNOWN" => Some(Self::Unknown),
            "FTRACE_CLOCK_GLOBAL" => Some(Self::Global),
            "FTRACE_CLOCK_LOCAL" => Some(Self::Local),
            "FTRACE_CLOCK_MONO_RAW" => Some(Self::MonoRaw),
            _ => None,
        }
    }
}
/// Description of GPU counters.
/// This message is sent by a GPU counter producer to specify the counters
/// available in the hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuCounterDescriptor {
    #[prost(message, repeated, tag = "1")]
    pub specs: ::prost::alloc::vec::Vec<gpu_counter_descriptor::GpuCounterSpec>,
    #[prost(message, repeated, tag = "2")]
    pub blocks: ::prost::alloc::vec::Vec<gpu_counter_descriptor::GpuCounterBlock>,
    /// optional.  Minimum sampling period supported by the producer in
    /// nanoseconds.
    #[prost(uint64, optional, tag = "3")]
    pub min_sampling_period_ns: ::core::option::Option<u64>,
    /// optional.  Maximum sampling period supported by the producer in
    /// nanoseconds.
    #[prost(uint64, optional, tag = "4")]
    pub max_sampling_period_ns: ::core::option::Option<u64>,
    /// optional.  The producer supports counter sampling by instrumenting the
    /// command buffer.
    #[prost(bool, optional, tag = "5")]
    pub supports_instrumented_sampling: ::core::option::Option<bool>,
}
/// Nested message and enum types in `GpuCounterDescriptor`.
pub mod gpu_counter_descriptor {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GpuCounterSpec {
        #[prost(uint32, optional, tag = "1")]
        pub counter_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration = "MeasureUnit", repeated, packed = "false", tag = "7")]
        pub numerator_units: ::prost::alloc::vec::Vec<i32>,
        #[prost(enumeration = "MeasureUnit", repeated, packed = "false", tag = "8")]
        pub denominator_units: ::prost::alloc::vec::Vec<i32>,
        #[prost(bool, optional, tag = "9")]
        pub select_by_default: ::core::option::Option<bool>,
        #[prost(enumeration = "GpuCounterGroup", repeated, packed = "false", tag = "10")]
        pub groups: ::prost::alloc::vec::Vec<i32>,
        #[prost(oneof = "gpu_counter_spec::PeakValue", tags = "5, 6")]
        pub peak_value: ::core::option::Option<gpu_counter_spec::PeakValue>,
    }
    /// Nested message and enum types in `GpuCounterSpec`.
    pub mod gpu_counter_spec {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum PeakValue {
            #[prost(int64, tag = "5")]
            IntPeakValue(i64),
            #[prost(double, tag = "6")]
            DoublePeakValue(f64),
        }
    }
    /// Allow producer to group counters into block to represent counter islands.
    /// A capacity may be specified to indicate the number of counters that can be
    /// enable simultaneously in that block.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GpuCounterBlock {
        /// required. Unique ID for the counter group.
        #[prost(uint32, optional, tag = "1")]
        pub block_id: ::core::option::Option<u32>,
        /// optional. Number of counters supported by the block. No limit if unset.
        #[prost(uint32, optional, tag = "2")]
        pub block_capacity: ::core::option::Option<u32>,
        /// optional. Name of block.
        #[prost(string, optional, tag = "3")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// optional. Description for the block.
        #[prost(string, optional, tag = "4")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
        /// list of counters that are part of the block.
        #[prost(uint32, repeated, packed = "false", tag = "5")]
        pub counter_ids: ::prost::alloc::vec::Vec<u32>,
    }
    /// Logical groups for a counter.  This is used in the UI to present the
    /// related counters together.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GpuCounterGroup {
        Unclassified = 0,
        System = 1,
        Vertices = 2,
        Fragments = 3,
        Primitives = 4,
        /// Includes counters relating to caching and bandwidth.
        Memory = 5,
        Compute = 6,
    }
    impl GpuCounterGroup {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unclassified => "UNCLASSIFIED",
                Self::System => "SYSTEM",
                Self::Vertices => "VERTICES",
                Self::Fragments => "FRAGMENTS",
                Self::Primitives => "PRIMITIVES",
                Self::Memory => "MEMORY",
                Self::Compute => "COMPUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCLASSIFIED" => Some(Self::Unclassified),
                "SYSTEM" => Some(Self::System),
                "VERTICES" => Some(Self::Vertices),
                "FRAGMENTS" => Some(Self::Fragments),
                "PRIMITIVES" => Some(Self::Primitives),
                "MEMORY" => Some(Self::Memory),
                "COMPUTE" => Some(Self::Compute),
                _ => None,
            }
        }
    }
    /// next id: 41
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MeasureUnit {
        None = 0,
        Bit = 1,
        Kilobit = 2,
        Megabit = 3,
        Gigabit = 4,
        Terabit = 5,
        Petabit = 6,
        Byte = 7,
        Kilobyte = 8,
        Megabyte = 9,
        Gigabyte = 10,
        Terabyte = 11,
        Petabyte = 12,
        Hertz = 13,
        Kilohertz = 14,
        Megahertz = 15,
        Gigahertz = 16,
        Terahertz = 17,
        Petahertz = 18,
        Nanosecond = 19,
        Microsecond = 20,
        Millisecond = 21,
        Second = 22,
        Minute = 23,
        Hour = 24,
        Vertex = 25,
        Pixel = 26,
        Triangle = 27,
        Primitive = 38,
        Fragment = 39,
        Milliwatt = 28,
        Watt = 29,
        Kilowatt = 30,
        Joule = 31,
        Volt = 32,
        Ampere = 33,
        Celsius = 34,
        Fahrenheit = 35,
        Kelvin = 36,
        /// Values should be out of 100.
        Percent = 37,
        Instruction = 40,
    }
    impl MeasureUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Bit => "BIT",
                Self::Kilobit => "KILOBIT",
                Self::Megabit => "MEGABIT",
                Self::Gigabit => "GIGABIT",
                Self::Terabit => "TERABIT",
                Self::Petabit => "PETABIT",
                Self::Byte => "BYTE",
                Self::Kilobyte => "KILOBYTE",
                Self::Megabyte => "MEGABYTE",
                Self::Gigabyte => "GIGABYTE",
                Self::Terabyte => "TERABYTE",
                Self::Petabyte => "PETABYTE",
                Self::Hertz => "HERTZ",
                Self::Kilohertz => "KILOHERTZ",
                Self::Megahertz => "MEGAHERTZ",
                Self::Gigahertz => "GIGAHERTZ",
                Self::Terahertz => "TERAHERTZ",
                Self::Petahertz => "PETAHERTZ",
                Self::Nanosecond => "NANOSECOND",
                Self::Microsecond => "MICROSECOND",
                Self::Millisecond => "MILLISECOND",
                Self::Second => "SECOND",
                Self::Minute => "MINUTE",
                Self::Hour => "HOUR",
                Self::Vertex => "VERTEX",
                Self::Pixel => "PIXEL",
                Self::Triangle => "TRIANGLE",
                Self::Primitive => "PRIMITIVE",
                Self::Fragment => "FRAGMENT",
                Self::Milliwatt => "MILLIWATT",
                Self::Watt => "WATT",
                Self::Kilowatt => "KILOWATT",
                Self::Joule => "JOULE",
                Self::Volt => "VOLT",
                Self::Ampere => "AMPERE",
                Self::Celsius => "CELSIUS",
                Self::Fahrenheit => "FAHRENHEIT",
                Self::Kelvin => "KELVIN",
                Self::Percent => "PERCENT",
                Self::Instruction => "INSTRUCTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "BIT" => Some(Self::Bit),
                "KILOBIT" => Some(Self::Kilobit),
                "MEGABIT" => Some(Self::Megabit),
                "GIGABIT" => Some(Self::Gigabit),
                "TERABIT" => Some(Self::Terabit),
                "PETABIT" => Some(Self::Petabit),
                "BYTE" => Some(Self::Byte),
                "KILOBYTE" => Some(Self::Kilobyte),
                "MEGABYTE" => Some(Self::Megabyte),
                "GIGABYTE" => Some(Self::Gigabyte),
                "TERABYTE" => Some(Self::Terabyte),
                "PETABYTE" => Some(Self::Petabyte),
                "HERTZ" => Some(Self::Hertz),
                "KILOHERTZ" => Some(Self::Kilohertz),
                "MEGAHERTZ" => Some(Self::Megahertz),
                "GIGAHERTZ" => Some(Self::Gigahertz),
                "TERAHERTZ" => Some(Self::Terahertz),
                "PETAHERTZ" => Some(Self::Petahertz),
                "NANOSECOND" => Some(Self::Nanosecond),
                "MICROSECOND" => Some(Self::Microsecond),
                "MILLISECOND" => Some(Self::Millisecond),
                "SECOND" => Some(Self::Second),
                "MINUTE" => Some(Self::Minute),
                "HOUR" => Some(Self::Hour),
                "VERTEX" => Some(Self::Vertex),
                "PIXEL" => Some(Self::Pixel),
                "TRIANGLE" => Some(Self::Triangle),
                "PRIMITIVE" => Some(Self::Primitive),
                "FRAGMENT" => Some(Self::Fragment),
                "MILLIWATT" => Some(Self::Milliwatt),
                "WATT" => Some(Self::Watt),
                "KILOWATT" => Some(Self::Kilowatt),
                "JOULE" => Some(Self::Joule),
                "VOLT" => Some(Self::Volt),
                "AMPERE" => Some(Self::Ampere),
                "CELSIUS" => Some(Self::Celsius),
                "FAHRENHEIT" => Some(Self::Fahrenheit),
                "KELVIN" => Some(Self::Kelvin),
                "PERCENT" => Some(Self::Percent),
                "INSTRUCTION" => Some(Self::Instruction),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuCounterEvent {
    /// The first trace packet of each session should include counter_spec.
    #[prost(message, optional, tag = "1")]
    pub counter_descriptor: ::core::option::Option<GpuCounterDescriptor>,
    #[prost(message, repeated, tag = "2")]
    pub counters: ::prost::alloc::vec::Vec<gpu_counter_event::GpuCounter>,
    /// optional. Identifier for GPU in a multi-gpu device.
    #[prost(int32, optional, tag = "3")]
    pub gpu_id: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GpuCounterEvent`.
pub mod gpu_counter_event {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GpuCounter {
        /// required. Identifier for counter.
        #[prost(uint32, optional, tag = "1")]
        pub counter_id: ::core::option::Option<u32>,
        /// required. Value of the counter.
        #[prost(oneof = "gpu_counter::Value", tags = "2, 3")]
        pub value: ::core::option::Option<gpu_counter::Value>,
    }
    /// Nested message and enum types in `GpuCounter`.
    pub mod gpu_counter {
        /// required. Value of the counter.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(int64, tag = "2")]
            IntValue(i64),
            #[prost(double, tag = "3")]
            DoubleValue(f64),
        }
    }
}
/// Message for logging events GPU data producer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuLog {
    #[prost(enumeration = "gpu_log::Severity", optional, tag = "1")]
    pub severity: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub log_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `GpuLog`.
pub mod gpu_log {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        LogSeverityUnspecified = 0,
        LogSeverityVerbose = 1,
        LogSeverityDebug = 2,
        LogSeverityInfo = 3,
        LogSeverityWarning = 4,
        LogSeverityError = 5,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LogSeverityUnspecified => "LOG_SEVERITY_UNSPECIFIED",
                Self::LogSeverityVerbose => "LOG_SEVERITY_VERBOSE",
                Self::LogSeverityDebug => "LOG_SEVERITY_DEBUG",
                Self::LogSeverityInfo => "LOG_SEVERITY_INFO",
                Self::LogSeverityWarning => "LOG_SEVERITY_WARNING",
                Self::LogSeverityError => "LOG_SEVERITY_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOG_SEVERITY_UNSPECIFIED" => Some(Self::LogSeverityUnspecified),
                "LOG_SEVERITY_VERBOSE" => Some(Self::LogSeverityVerbose),
                "LOG_SEVERITY_DEBUG" => Some(Self::LogSeverityDebug),
                "LOG_SEVERITY_INFO" => Some(Self::LogSeverityInfo),
                "LOG_SEVERITY_WARNING" => Some(Self::LogSeverityWarning),
                "LOG_SEVERITY_ERROR" => Some(Self::LogSeverityError),
                _ => None,
            }
        }
    }
}
/// next id: 15
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuRenderStageEvent {
    /// required. Unique ID for the event.
    #[prost(uint64, optional, tag = "1")]
    pub event_id: ::core::option::Option<u64>,
    /// optional. Duration of the event in nanoseconds. If unset, this is a
    /// single time point event.
    #[prost(uint64, optional, tag = "2")]
    pub duration: ::core::option::Option<u64>,
    /// required. ID to a hardware queue description in the specifications.
    /// InternedGpuRenderStageSpecification
    #[prost(uint64, optional, tag = "13")]
    pub hw_queue_iid: ::core::option::Option<u64>,
    /// required. ID to a render stage description in the specifications.
    /// InternedGpuRenderStageSpecification
    #[prost(uint64, optional, tag = "14")]
    pub stage_iid: ::core::option::Option<u64>,
    /// optional. Identifier for GPU in a multi-gpu device.
    #[prost(int32, optional, tag = "11")]
    pub gpu_id: ::core::option::Option<i32>,
    /// required. Graphics context for the event.
    /// For OpenGL, this is the GL context.
    /// For Vulkan, this is the VkDevice.
    #[prost(uint64, optional, tag = "5")]
    pub context: ::core::option::Option<u64>,
    /// optional. The render target for this event.
    /// For OpenGL, this is the GL frame buffer handle.
    /// For Vulkan, this is the VkFrameBuffer handle.
    #[prost(uint64, optional, tag = "8")]
    pub render_target_handle: ::core::option::Option<u64>,
    /// optional. Submission ID generated by the UMD.
    /// For OpenGL, the ID should map to an API submission (e.g., glFlush,
    /// glFinish, eglSwapBufffers) event.  The set of submissions to the HW due
    /// to a single API submission should share the same ID.
    /// For Vulkan, it should map 1:1 with a vkQueueSubmit.
    #[prost(uint32, optional, tag = "10")]
    pub submission_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "6")]
    pub extra_data: ::prost::alloc::vec::Vec<gpu_render_stage_event::ExtraData>,
    /// optional. The Vulkan render pass handle.
    #[prost(uint64, optional, tag = "9")]
    pub render_pass_handle: ::core::option::Option<u64>,
    /// optional. A bit mask representing which render subpasses contributed to
    /// this render stage event.  Subpass index 0 is represented by setting the
    /// LSB of the mask.  Additional mask can be added for subpass index greater
    /// than 63.
    #[prost(uint64, repeated, packed = "false", tag = "15")]
    pub render_subpass_index_mask: ::prost::alloc::vec::Vec<u64>,
    /// optional. The Vulkan command buffer handle.
    #[prost(uint64, optional, tag = "12")]
    pub command_buffer_handle: ::core::option::Option<u64>,
    /// Deprecated.  Use hw_queue_iid and stage_iid to refer to
    /// InternedGpuRenderStageSpecification instead.
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub specifications: ::core::option::Option<gpu_render_stage_event::Specifications>,
    /// Deprecated. Use hw_queue_iid instead;
    #[deprecated]
    #[prost(int32, optional, tag = "3")]
    pub hw_queue_id: ::core::option::Option<i32>,
    /// Deprecated. Use stage_iid instead;
    #[deprecated]
    #[prost(int32, optional, tag = "4")]
    pub stage_id: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GpuRenderStageEvent`.
pub mod gpu_render_stage_event {
    /// optional. Additional data for the user. This may include attributes for
    /// the event like resource ids, shaders, etc.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExtraData {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Deprecated.  Use InternedGpuRenderStageSpecification instead.
    /// The first trace packet of each session should include a Specifications
    /// to enumerate *all* IDs that will be used. The timestamp of this packet
    /// must be earlier than all other packets. Only one packet with Specifications
    /// is expected.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Specifications {
        #[prost(message, optional, tag = "1")]
        pub context_spec: ::core::option::Option<specifications::ContextSpec>,
        /// Labels to categorize the hw Queue this event goes on.
        #[prost(message, repeated, tag = "2")]
        pub hw_queue: ::prost::alloc::vec::Vec<specifications::Description>,
        /// Labels to categorize render stage(binning, render, compute etc).
        #[prost(message, repeated, tag = "3")]
        pub stage: ::prost::alloc::vec::Vec<specifications::Description>,
    }
    /// Nested message and enum types in `Specifications`.
    pub mod specifications {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ContextSpec {
            #[prost(uint64, optional, tag = "1")]
            pub context: ::core::option::Option<u64>,
            #[prost(int32, optional, tag = "2")]
            pub pid: ::core::option::Option<i32>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Description {
            #[prost(string, optional, tag = "1")]
            pub name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "2")]
            pub description: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
}
/// The iid is the numeric value of either the GL Context or the VkDevice
/// handle.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternedGraphicsContext {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub pid: ::core::option::Option<i32>,
    #[prost(enumeration = "interned_graphics_context::Api", optional, tag = "3")]
    pub api: ::core::option::Option<i32>,
}
/// Nested message and enum types in `InternedGraphicsContext`.
pub mod interned_graphics_context {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Api {
        Undefined = 0,
        OpenGl = 1,
        Vulkan = 2,
        OpenCl = 3,
    }
    impl Api {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::OpenGl => "OPEN_GL",
                Self::Vulkan => "VULKAN",
                Self::OpenCl => "OPEN_CL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "OPEN_GL" => Some(Self::OpenGl),
                "VULKAN" => Some(Self::Vulkan),
                "OPEN_CL" => Some(Self::OpenCl),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternedGpuRenderStageSpecification {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "interned_gpu_render_stage_specification::RenderStageCategory",
        optional,
        tag = "4"
    )]
    pub category: ::core::option::Option<i32>,
}
/// Nested message and enum types in `InternedGpuRenderStageSpecification`.
pub mod interned_gpu_render_stage_specification {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RenderStageCategory {
        Other = 0,
        Graphics = 1,
        Compute = 2,
    }
    impl RenderStageCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Other => "OTHER",
                Self::Graphics => "GRAPHICS",
                Self::Compute => "COMPUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OTHER" => Some(Self::Other),
                "GRAPHICS" => Some(Self::Graphics),
                "COMPUTE" => Some(Self::Compute),
                _ => None,
            }
        }
    }
}
/// All the information that cannot be sent within a VulkanMemoryEvent message,
/// are sent as annotations to the main memory event. One example is the
/// properties of the object that consumes the allocated memory, for example, a
/// buffer or an image.
/// key_iid and string_iid are both interned strings. Original string value is
/// stored in vulkan_memory_keys from
/// protos/perfetto/trace/interned_data/interned_data.proto.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VulkanMemoryEventAnnotation {
    #[prost(uint64, optional, tag = "1")]
    pub key_iid: ::core::option::Option<u64>,
    #[prost(oneof = "vulkan_memory_event_annotation::Value", tags = "2, 3, 4")]
    pub value: ::core::option::Option<vulkan_memory_event_annotation::Value>,
}
/// Nested message and enum types in `VulkanMemoryEventAnnotation`.
pub mod vulkan_memory_event_annotation {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "2")]
        IntValue(i64),
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        #[prost(uint64, tag = "4")]
        StringIid(u64),
    }
}
/// Each VulkanMemoryEvent encompasses information regarding one single function
/// call that results in reserving, binding or freeing host or GPU memory. There
/// is a special message type, ANNOTATIONS, which is used to communicate
/// information that are not directly related to a memory event, nonetheless are
/// essential to understand the memory usage. An example is the size and memory
/// types of the memory heaps.
///
/// Next reserved id: 10 (up to 15).
/// Next id: 21.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VulkanMemoryEvent {
    #[prost(enumeration = "vulkan_memory_event::Source", optional, tag = "1")]
    pub source: ::core::option::Option<i32>,
    #[prost(enumeration = "vulkan_memory_event::Operation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub timestamp: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub pid: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "5")]
    pub memory_address: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub memory_size: ::core::option::Option<u64>,
    /// Interned string. Original string value is stored in function_names from
    /// protos/perfetto/trace/interned_data/interned_data.proto.
    #[prost(uint64, optional, tag = "7")]
    pub caller_iid: ::core::option::Option<u64>,
    #[prost(enumeration = "vulkan_memory_event::AllocationScope", optional, tag = "8")]
    pub allocation_scope: ::core::option::Option<i32>,
    /// Extra related information, e.g., create configs, etc.
    #[prost(message, repeated, tag = "9")]
    pub annotations: ::prost::alloc::vec::Vec<VulkanMemoryEventAnnotation>,
    /// Field IDs used for device memory (low sampling rate)
    #[prost(fixed64, optional, tag = "16")]
    pub device: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "17")]
    pub device_memory: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "18")]
    pub memory_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub heap: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "20")]
    pub object_handle: ::core::option::Option<u64>,
}
/// Nested message and enum types in `VulkanMemoryEvent`.
pub mod vulkan_memory_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unspecified = 0,
        Driver = 1,
        Device = 2,
        DeviceMemory = 3,
        Buffer = 4,
        Image = 5,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SOURCE_UNSPECIFIED",
                Self::Driver => "SOURCE_DRIVER",
                Self::Device => "SOURCE_DEVICE",
                Self::DeviceMemory => "SOURCE_DEVICE_MEMORY",
                Self::Buffer => "SOURCE_BUFFER",
                Self::Image => "SOURCE_IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                "SOURCE_DRIVER" => Some(Self::Driver),
                "SOURCE_DEVICE" => Some(Self::Device),
                "SOURCE_DEVICE_MEMORY" => Some(Self::DeviceMemory),
                "SOURCE_BUFFER" => Some(Self::Buffer),
                "SOURCE_IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operation {
        OpUnspecified = 0,
        /// alloc, create
        OpCreate = 1,
        /// free, destroy(non-bound)
        OpDestroy = 2,
        /// bind buffer and image
        OpBind = 3,
        /// destroy (bound)
        OpDestroyBound = 4,
        /// only annotations
        OpAnnotations = 5,
    }
    impl Operation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OpUnspecified => "OP_UNSPECIFIED",
                Self::OpCreate => "OP_CREATE",
                Self::OpDestroy => "OP_DESTROY",
                Self::OpBind => "OP_BIND",
                Self::OpDestroyBound => "OP_DESTROY_BOUND",
                Self::OpAnnotations => "OP_ANNOTATIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OP_UNSPECIFIED" => Some(Self::OpUnspecified),
                "OP_CREATE" => Some(Self::OpCreate),
                "OP_DESTROY" => Some(Self::OpDestroy),
                "OP_BIND" => Some(Self::OpBind),
                "OP_DESTROY_BOUND" => Some(Self::OpDestroyBound),
                "OP_ANNOTATIONS" => Some(Self::OpAnnotations),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AllocationScope {
        ScopeUnspecified = 0,
        ScopeCommand = 1,
        ScopeObject = 2,
        ScopeCache = 3,
        ScopeDevice = 4,
        ScopeInstance = 5,
    }
    impl AllocationScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ScopeUnspecified => "SCOPE_UNSPECIFIED",
                Self::ScopeCommand => "SCOPE_COMMAND",
                Self::ScopeObject => "SCOPE_OBJECT",
                Self::ScopeCache => "SCOPE_CACHE",
                Self::ScopeDevice => "SCOPE_DEVICE",
                Self::ScopeInstance => "SCOPE_INSTANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_UNSPECIFIED" => Some(Self::ScopeUnspecified),
                "SCOPE_COMMAND" => Some(Self::ScopeCommand),
                "SCOPE_OBJECT" => Some(Self::ScopeObject),
                "SCOPE_CACHE" => Some(Self::ScopeCache),
                "SCOPE_DEVICE" => Some(Self::ScopeDevice),
                "SCOPE_INSTANCE" => Some(Self::ScopeInstance),
                _ => None,
            }
        }
    }
}
/// Message for recording the Vulkan call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VulkanApiEvent {
    #[prost(oneof = "vulkan_api_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<vulkan_api_event::Event>,
}
/// Nested message and enum types in `VulkanApiEvent`.
pub mod vulkan_api_event {
    /// For recording vkSetDebugUtilsObjectNameEXT and
    /// vkDebugMarkerSetObjectNameEXT
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VkDebugUtilsObjectName {
        #[prost(uint32, optional, tag = "1")]
        pub pid: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "2")]
        pub vk_device: ::core::option::Option<u64>,
        /// VkObjectType.  Value must match
        /// <https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkObjectType.html.>
        #[prost(int32, optional, tag = "3")]
        pub object_type: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "4")]
        pub object: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "5")]
        pub object_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// For recording vkQueueSubmit call.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VkQueueSubmit {
        #[prost(uint64, optional, tag = "1")]
        pub duration_ns: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "2")]
        pub pid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub tid: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "4")]
        pub vk_queue: ::core::option::Option<u64>,
        #[prost(uint64, repeated, packed = "false", tag = "5")]
        pub vk_command_buffers: ::prost::alloc::vec::Vec<u64>,
        /// Submission ID.  An identifier unique to each vkQueueSubmit call.  This
        /// submission_id must match GpuRenderStageEvent.submission_id if the
        /// GpuRenderStageEvent is created due to this vkQueueSubmit.
        #[prost(uint32, optional, tag = "6")]
        pub submission_id: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        VkDebugUtilsObjectName(VkDebugUtilsObjectName),
        #[prost(message, tag = "2")]
        VkQueueSubmit(VkQueueSubmit),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// An individual histogram sample logged via Chrome's UMA metrics system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeHistogramSample {
    /// MD5 hash of the metric name. Either |name_hash| or |name|/|name_iid| or
    /// both must be present.
    #[prost(uint64, optional, tag = "1")]
    pub name_hash: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub sample: ::core::option::Option<i64>,
    /// Interned HistogramName. Only one of |name|, |name_iid| can be set.
    #[prost(uint64, optional, tag = "4")]
    pub name_iid: ::core::option::Option<u64>,
}
/// Proto representation of untyped key/value annotations provided in TRACE_EVENT
/// macros. Users of the Perfetto SDK should prefer to use the
/// perfetto::TracedValue API to fill these protos, rather than filling them
/// manually.
///
/// Debug annotations are intended for debug use and are not considered a stable
/// API of the trace contents. Trace-based metrics that use debug annotation
/// values are prone to breakage, so please rely on typed TrackEvent fields for
/// these instead.
///
/// DebugAnnotations support nested arrays and dictionaries. Each entry is
/// encoded as a single DebugAnnotation message. Only dictionary entries
/// set the "name" field. The TrackEvent message forms an implicit root
/// dictionary.
///
/// Example TrackEvent with nested annotations:
///    track_event {
///      debug_annotations {
///        name: "foo"
///        dict_entries {
///          name: "a"
///          bool_value: true
///        }
///        dict_entries {
///          name: "b"
///          int_value: 123
///        }
///      }
///      debug_annotations {
///        name: "bar"
///        array_values {
///          string_value: "hello"
///        }
///        array_values {
///          string_value: "world"
///        }
///      }
///    }
///
/// Next ID: 18.
/// Reserved ID: 15
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugAnnotation {
    #[prost(bytes = "vec", optional, tag = "14")]
    pub proto_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "11")]
    pub dict_entries: ::prost::alloc::vec::Vec<DebugAnnotation>,
    #[prost(message, repeated, tag = "12")]
    pub array_values: ::prost::alloc::vec::Vec<DebugAnnotation>,
    /// Name fields are set only for dictionary entries.
    #[prost(oneof = "debug_annotation::NameField", tags = "1, 10")]
    pub name_field: ::core::option::Option<debug_annotation::NameField>,
    #[prost(oneof = "debug_annotation::Value", tags = "2, 3, 4, 5, 7, 8, 9, 6, 17")]
    pub value: ::core::option::Option<debug_annotation::Value>,
    /// Used to embed arbitrary proto messages (which are also typically used to
    /// represent typed TrackEvent arguments). |proto_type_name| or
    /// |proto_type_name_iid| are storing the full name of the proto messages (e.g.
    /// .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
    /// proto messages. See |TracedValue::WriteProto| for more details.
    #[prost(oneof = "debug_annotation::ProtoTypeDescriptor", tags = "16, 13")]
    pub proto_type_descriptor: ::core::option::Option<
        debug_annotation::ProtoTypeDescriptor,
    >,
}
/// Nested message and enum types in `DebugAnnotation`.
pub mod debug_annotation {
    /// Deprecated legacy way to use nested values. Only kept for
    /// backwards-compatibility in TraceProcessor. May be removed in the future -
    /// code filling protos should use |dict_entries| and |array_values| instead.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NestedValue {
        #[prost(enumeration = "nested_value::NestedType", optional, tag = "1")]
        pub nested_type: ::core::option::Option<i32>,
        #[prost(string, repeated, tag = "2")]
        pub dict_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub dict_values: ::prost::alloc::vec::Vec<NestedValue>,
        #[prost(message, repeated, tag = "4")]
        pub array_values: ::prost::alloc::vec::Vec<NestedValue>,
        #[prost(int64, optional, tag = "5")]
        pub int_value: ::core::option::Option<i64>,
        #[prost(double, optional, tag = "6")]
        pub double_value: ::core::option::Option<f64>,
        #[prost(bool, optional, tag = "7")]
        pub bool_value: ::core::option::Option<bool>,
        #[prost(string, optional, tag = "8")]
        pub string_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `NestedValue`.
    pub mod nested_value {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum NestedType {
            /// leaf value.
            Unspecified = 0,
            Dict = 1,
            Array = 2,
        }
        impl NestedType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Dict => "DICT",
                    Self::Array => "ARRAY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "DICT" => Some(Self::Dict),
                    "ARRAY" => Some(Self::Array),
                    _ => None,
                }
            }
        }
    }
    /// Name fields are set only for dictionary entries.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NameField {
        /// interned DebugAnnotationName.
        #[prost(uint64, tag = "1")]
        NameIid(u64),
        /// non-interned variant.
        #[prost(string, tag = "10")]
        Name(::prost::alloc::string::String),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(uint64, tag = "3")]
        UintValue(u64),
        #[prost(int64, tag = "4")]
        IntValue(i64),
        #[prost(double, tag = "5")]
        DoubleValue(f64),
        /// Pointers are stored in a separate type as the JSON output treats them
        /// differently from other uint64 values.
        #[prost(uint64, tag = "7")]
        PointerValue(u64),
        /// Deprecated. Use dict_entries / array_values instead.
        #[prost(message, tag = "8")]
        NestedValue(NestedValue),
        /// Legacy instrumentation may not support conversion of nested data to
        /// NestedValue yet.
        #[prost(string, tag = "9")]
        LegacyJsonValue(::prost::alloc::string::String),
        /// interned and non-interned variants of strings.
        #[prost(string, tag = "6")]
        StringValue(::prost::alloc::string::String),
        /// Corresponds to |debug_annotation_string_values| field in InternedData.
        #[prost(uint64, tag = "17")]
        StringValueIid(u64),
    }
    /// Used to embed arbitrary proto messages (which are also typically used to
    /// represent typed TrackEvent arguments). |proto_type_name| or
    /// |proto_type_name_iid| are storing the full name of the proto messages (e.g.
    /// .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
    /// proto messages. See |TracedValue::WriteProto| for more details.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ProtoTypeDescriptor {
        #[prost(string, tag = "16")]
        ProtoTypeName(::prost::alloc::string::String),
        /// interned DebugAnnotationValueTypeName.
        #[prost(uint64, tag = "13")]
        ProtoTypeNameIid(u64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugAnnotationName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// See the |proto_type_descriptor| comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugAnnotationValueTypeName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LogMessage {
    /// interned SourceLocation.
    #[prost(uint64, optional, tag = "1")]
    pub source_location_iid: ::core::option::Option<u64>,
    /// interned LogMessageBody.
    #[prost(uint64, optional, tag = "2")]
    pub body_iid: ::core::option::Option<u64>,
    #[prost(enumeration = "log_message::Priority", optional, tag = "3")]
    pub prio: ::core::option::Option<i32>,
}
/// Nested message and enum types in `LogMessage`.
pub mod log_message {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Priority {
        PrioUnspecified = 0,
        PrioUnused = 1,
        PrioVerbose = 2,
        PrioDebug = 3,
        PrioInfo = 4,
        PrioWarn = 5,
        PrioError = 6,
        PrioFatal = 7,
    }
    impl Priority {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PrioUnspecified => "PRIO_UNSPECIFIED",
                Self::PrioUnused => "PRIO_UNUSED",
                Self::PrioVerbose => "PRIO_VERBOSE",
                Self::PrioDebug => "PRIO_DEBUG",
                Self::PrioInfo => "PRIO_INFO",
                Self::PrioWarn => "PRIO_WARN",
                Self::PrioError => "PRIO_ERROR",
                Self::PrioFatal => "PRIO_FATAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIO_UNSPECIFIED" => Some(Self::PrioUnspecified),
                "PRIO_UNUSED" => Some(Self::PrioUnused),
                "PRIO_VERBOSE" => Some(Self::PrioVerbose),
                "PRIO_DEBUG" => Some(Self::PrioDebug),
                "PRIO_INFO" => Some(Self::PrioInfo),
                "PRIO_WARN" => Some(Self::PrioWarn),
                "PRIO_ERROR" => Some(Self::PrioError),
                "PRIO_FATAL" => Some(Self::PrioFatal),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogMessageBody {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
}
/// TrackEvent arguments describing the execution of a task.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskExecution {
    /// Source location that the task was posted from.
    /// interned SourceLocation.
    #[prost(uint64, optional, tag = "1")]
    pub posted_from_iid: ::core::option::Option<u64>,
}
/// A list of processes connected to the tracing service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeActiveProcesses {
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub pid: ::prost::alloc::vec::Vec<i32>,
}
/// Trace event arguments for application state changes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeApplicationStateInfo {
    #[prost(
        enumeration = "chrome_application_state_info::ChromeApplicationState",
        optional,
        tag = "1"
    )]
    pub application_state: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ChromeApplicationStateInfo`.
pub mod chrome_application_state_info {
    /// Enum definition taken from:
    /// <https://source.chromium.org/chromium/chromium/src/+/master:base/android/application_status_listener.h>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChromeApplicationState {
        ApplicationStateUnknown = 0,
        ApplicationStateHasRunningActivities = 1,
        ApplicationStateHasPausedActivities = 2,
        ApplicationStateHasStoppedActivities = 3,
        ApplicationStateHasDestroyedActivities = 4,
    }
    impl ChromeApplicationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ApplicationStateUnknown => "APPLICATION_STATE_UNKNOWN",
                Self::ApplicationStateHasRunningActivities => {
                    "APPLICATION_STATE_HAS_RUNNING_ACTIVITIES"
                }
                Self::ApplicationStateHasPausedActivities => {
                    "APPLICATION_STATE_HAS_PAUSED_ACTIVITIES"
                }
                Self::ApplicationStateHasStoppedActivities => {
                    "APPLICATION_STATE_HAS_STOPPED_ACTIVITIES"
                }
                Self::ApplicationStateHasDestroyedActivities => {
                    "APPLICATION_STATE_HAS_DESTROYED_ACTIVITIES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPLICATION_STATE_UNKNOWN" => Some(Self::ApplicationStateUnknown),
                "APPLICATION_STATE_HAS_RUNNING_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasRunningActivities)
                }
                "APPLICATION_STATE_HAS_PAUSED_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasPausedActivities)
                }
                "APPLICATION_STATE_HAS_STOPPED_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasStoppedActivities)
                }
                "APPLICATION_STATE_HAS_DESTROYED_ACTIVITIES" => {
                    Some(Self::ApplicationStateHasDestroyedActivities)
                }
                _ => None,
            }
        }
    }
}
/// A source location, represented as a native symbol.
/// This is similar to `message Frame` from
/// protos/perfetto/trace/profiling/profile_common.proto, but for abitrary
/// source code locations (for example in track event args), not stack frames.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnsymbolizedSourceLocation {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub mapping_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub rel_pc: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceLocation {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub file_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub line_number: ::core::option::Option<u32>,
}
/// Next id: 18
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeCompositorSchedulerState {
    #[prost(message, optional, tag = "1")]
    pub state_machine: ::core::option::Option<ChromeCompositorStateMachine>,
    #[prost(bool, optional, tag = "2")]
    pub observing_begin_frame_source: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub begin_impl_frame_deadline_task: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub pending_begin_frame_task: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub skipped_last_frame_missed_exceeded_deadline: ::core::option::Option<bool>,
    #[prost(enumeration = "ChromeCompositorSchedulerAction", optional, tag = "7")]
    pub inside_action: ::core::option::Option<i32>,
    #[prost(
        enumeration = "chrome_compositor_scheduler_state::BeginImplFrameDeadlineMode",
        optional,
        tag = "8"
    )]
    pub deadline_mode: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "9")]
    pub deadline_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub deadline_scheduled_at_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub now_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "12")]
    pub now_to_deadline_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "13")]
    pub now_to_deadline_scheduled_at_delta_us: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "14")]
    pub begin_impl_frame_args: ::core::option::Option<BeginImplFrameArgs>,
    #[prost(message, optional, tag = "15")]
    pub begin_frame_observer_state: ::core::option::Option<BeginFrameObserverState>,
    #[prost(message, optional, tag = "16")]
    pub begin_frame_source_state: ::core::option::Option<BeginFrameSourceState>,
    #[prost(message, optional, tag = "17")]
    pub compositor_timing_history: ::core::option::Option<CompositorTimingHistory>,
}
/// Nested message and enum types in `ChromeCompositorSchedulerState`.
pub mod chrome_compositor_scheduler_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BeginImplFrameDeadlineMode {
        DeadlineModeUnspecified = 0,
        DeadlineModeNone = 1,
        DeadlineModeImmediate = 2,
        DeadlineModeRegular = 3,
        DeadlineModeLate = 4,
        DeadlineModeBlocked = 5,
    }
    impl BeginImplFrameDeadlineMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DeadlineModeUnspecified => "DEADLINE_MODE_UNSPECIFIED",
                Self::DeadlineModeNone => "DEADLINE_MODE_NONE",
                Self::DeadlineModeImmediate => "DEADLINE_MODE_IMMEDIATE",
                Self::DeadlineModeRegular => "DEADLINE_MODE_REGULAR",
                Self::DeadlineModeLate => "DEADLINE_MODE_LATE",
                Self::DeadlineModeBlocked => "DEADLINE_MODE_BLOCKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEADLINE_MODE_UNSPECIFIED" => Some(Self::DeadlineModeUnspecified),
                "DEADLINE_MODE_NONE" => Some(Self::DeadlineModeNone),
                "DEADLINE_MODE_IMMEDIATE" => Some(Self::DeadlineModeImmediate),
                "DEADLINE_MODE_REGULAR" => Some(Self::DeadlineModeRegular),
                "DEADLINE_MODE_LATE" => Some(Self::DeadlineModeLate),
                "DEADLINE_MODE_BLOCKED" => Some(Self::DeadlineModeBlocked),
                _ => None,
            }
        }
    }
}
/// Describes the current values stored in the Chrome Compositor state machine.
/// Next id: 3
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeCompositorStateMachine {
    #[prost(message, optional, tag = "1")]
    pub major_state: ::core::option::Option<chrome_compositor_state_machine::MajorState>,
    #[prost(message, optional, tag = "2")]
    pub minor_state: ::core::option::Option<chrome_compositor_state_machine::MinorState>,
}
/// Nested message and enum types in `ChromeCompositorStateMachine`.
pub mod chrome_compositor_state_machine {
    /// Next id: 6
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MajorState {
        #[prost(
            enumeration = "super::ChromeCompositorSchedulerAction",
            optional,
            tag = "1"
        )]
        pub next_action: ::core::option::Option<i32>,
        #[prost(enumeration = "major_state::BeginImplFrameState", optional, tag = "2")]
        pub begin_impl_frame_state: ::core::option::Option<i32>,
        #[prost(enumeration = "major_state::BeginMainFrameState", optional, tag = "3")]
        pub begin_main_frame_state: ::core::option::Option<i32>,
        #[prost(
            enumeration = "major_state::LayerTreeFrameSinkState",
            optional,
            tag = "4"
        )]
        pub layer_tree_frame_sink_state: ::core::option::Option<i32>,
        #[prost(
            enumeration = "major_state::ForcedRedrawOnTimeoutState",
            optional,
            tag = "5"
        )]
        pub forced_redraw_state: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `MajorState`.
    pub mod major_state {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BeginImplFrameState {
            BeginImplFrameUnspecified = 0,
            BeginImplFrameIdle = 1,
            BeginImplFrameInsideBeginFrame = 2,
            BeginImplFrameInsideDeadline = 3,
        }
        impl BeginImplFrameState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BeginImplFrameUnspecified => "BEGIN_IMPL_FRAME_UNSPECIFIED",
                    Self::BeginImplFrameIdle => "BEGIN_IMPL_FRAME_IDLE",
                    Self::BeginImplFrameInsideBeginFrame => {
                        "BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME"
                    }
                    Self::BeginImplFrameInsideDeadline => {
                        "BEGIN_IMPL_FRAME_INSIDE_DEADLINE"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BEGIN_IMPL_FRAME_UNSPECIFIED" => {
                        Some(Self::BeginImplFrameUnspecified)
                    }
                    "BEGIN_IMPL_FRAME_IDLE" => Some(Self::BeginImplFrameIdle),
                    "BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME" => {
                        Some(Self::BeginImplFrameInsideBeginFrame)
                    }
                    "BEGIN_IMPL_FRAME_INSIDE_DEADLINE" => {
                        Some(Self::BeginImplFrameInsideDeadline)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BeginMainFrameState {
            BeginMainFrameUnspecified = 0,
            BeginMainFrameIdle = 1,
            BeginMainFrameSent = 2,
            BeginMainFrameReadyToCommit = 3,
        }
        impl BeginMainFrameState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::BeginMainFrameUnspecified => "BEGIN_MAIN_FRAME_UNSPECIFIED",
                    Self::BeginMainFrameIdle => "BEGIN_MAIN_FRAME_IDLE",
                    Self::BeginMainFrameSent => "BEGIN_MAIN_FRAME_SENT",
                    Self::BeginMainFrameReadyToCommit => {
                        "BEGIN_MAIN_FRAME_READY_TO_COMMIT"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BEGIN_MAIN_FRAME_UNSPECIFIED" => {
                        Some(Self::BeginMainFrameUnspecified)
                    }
                    "BEGIN_MAIN_FRAME_IDLE" => Some(Self::BeginMainFrameIdle),
                    "BEGIN_MAIN_FRAME_SENT" => Some(Self::BeginMainFrameSent),
                    "BEGIN_MAIN_FRAME_READY_TO_COMMIT" => {
                        Some(Self::BeginMainFrameReadyToCommit)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LayerTreeFrameSinkState {
            LayerTreeFrameUnspecified = 0,
            LayerTreeFrameNone = 1,
            LayerTreeFrameActive = 2,
            LayerTreeFrameCreating = 3,
            LayerTreeFrameWaitingForFirstCommit = 4,
            LayerTreeFrameWaitingForFirstActivation = 5,
        }
        impl LayerTreeFrameSinkState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::LayerTreeFrameUnspecified => "LAYER_TREE_FRAME_UNSPECIFIED",
                    Self::LayerTreeFrameNone => "LAYER_TREE_FRAME_NONE",
                    Self::LayerTreeFrameActive => "LAYER_TREE_FRAME_ACTIVE",
                    Self::LayerTreeFrameCreating => "LAYER_TREE_FRAME_CREATING",
                    Self::LayerTreeFrameWaitingForFirstCommit => {
                        "LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT"
                    }
                    Self::LayerTreeFrameWaitingForFirstActivation => {
                        "LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LAYER_TREE_FRAME_UNSPECIFIED" => {
                        Some(Self::LayerTreeFrameUnspecified)
                    }
                    "LAYER_TREE_FRAME_NONE" => Some(Self::LayerTreeFrameNone),
                    "LAYER_TREE_FRAME_ACTIVE" => Some(Self::LayerTreeFrameActive),
                    "LAYER_TREE_FRAME_CREATING" => Some(Self::LayerTreeFrameCreating),
                    "LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT" => {
                        Some(Self::LayerTreeFrameWaitingForFirstCommit)
                    }
                    "LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION" => {
                        Some(Self::LayerTreeFrameWaitingForFirstActivation)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ForcedRedrawOnTimeoutState {
            ForcedRedrawUnspecified = 0,
            ForcedRedrawIdle = 1,
            ForcedRedrawWaitingForCommit = 2,
            ForcedRedrawWaitingForActivation = 3,
            ForcedRedrawWaitingForDraw = 4,
        }
        impl ForcedRedrawOnTimeoutState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ForcedRedrawUnspecified => "FORCED_REDRAW_UNSPECIFIED",
                    Self::ForcedRedrawIdle => "FORCED_REDRAW_IDLE",
                    Self::ForcedRedrawWaitingForCommit => {
                        "FORCED_REDRAW_WAITING_FOR_COMMIT"
                    }
                    Self::ForcedRedrawWaitingForActivation => {
                        "FORCED_REDRAW_WAITING_FOR_ACTIVATION"
                    }
                    Self::ForcedRedrawWaitingForDraw => "FORCED_REDRAW_WAITING_FOR_DRAW",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FORCED_REDRAW_UNSPECIFIED" => Some(Self::ForcedRedrawUnspecified),
                    "FORCED_REDRAW_IDLE" => Some(Self::ForcedRedrawIdle),
                    "FORCED_REDRAW_WAITING_FOR_COMMIT" => {
                        Some(Self::ForcedRedrawWaitingForCommit)
                    }
                    "FORCED_REDRAW_WAITING_FOR_ACTIVATION" => {
                        Some(Self::ForcedRedrawWaitingForActivation)
                    }
                    "FORCED_REDRAW_WAITING_FOR_DRAW" => {
                        Some(Self::ForcedRedrawWaitingForDraw)
                    }
                    _ => None,
                }
            }
        }
    }
    /// Next id: 47
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MinorState {
        #[prost(int32, optional, tag = "1")]
        pub commit_count: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub current_frame_number: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub last_frame_number_submit_performed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub last_frame_number_draw_performed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub last_frame_number_begin_main_frame_sent: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "6")]
        pub did_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "7")]
        pub did_send_begin_main_frame_for_current_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "8")]
        pub did_notify_begin_main_frame_not_expected_until: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "9")]
        pub did_notify_begin_main_frame_not_expected_soon: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "10")]
        pub wants_begin_main_frame_not_expected: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "11")]
        pub did_commit_during_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "12")]
        pub did_invalidate_layer_tree_frame_sink: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "13")]
        pub did_perform_impl_side_invalidaion: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "14")]
        pub did_prepare_tiles: ::core::option::Option<bool>,
        #[prost(int32, optional, tag = "15")]
        pub consecutive_checkerboard_animations: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "16")]
        pub pending_submit_frames: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "17")]
        pub submit_frames_with_current_layer_tree_frame_sink: ::core::option::Option<
            i32,
        >,
        #[prost(bool, optional, tag = "18")]
        pub needs_redraw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "19")]
        pub needs_prepare_tiles: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "20")]
        pub needs_begin_main_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "21")]
        pub needs_one_begin_impl_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "22")]
        pub visible: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "23")]
        pub begin_frame_source_paused: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "24")]
        pub can_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "25")]
        pub resourceless_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "26")]
        pub has_pending_tree: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "27")]
        pub pending_tree_is_ready_for_activation: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "28")]
        pub active_tree_needs_first_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "29")]
        pub active_tree_is_ready_to_draw: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "30")]
        pub did_create_and_initialize_first_layer_tree_frame_sink: ::core::option::Option<
            bool,
        >,
        #[prost(enumeration = "minor_state::TreePriority", optional, tag = "31")]
        pub tree_priority: ::core::option::Option<i32>,
        #[prost(enumeration = "minor_state::ScrollHandlerState", optional, tag = "32")]
        pub scroll_handler_state: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "33")]
        pub critical_begin_main_frame_to_activate_is_fast: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "34")]
        pub main_thread_missed_last_deadline: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "36")]
        pub video_needs_begin_frames: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "37")]
        pub defer_begin_main_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "38")]
        pub last_commit_had_no_updates: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "39")]
        pub did_draw_in_last_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "40")]
        pub did_submit_in_last_frame: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "41")]
        pub needs_impl_side_invalidation: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "42")]
        pub current_pending_tree_is_impl_side: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "43")]
        pub previous_pending_tree_was_impl_side: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "44")]
        pub processing_animation_worklets_for_active_tree: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "45")]
        pub processing_animation_worklets_for_pending_tree: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "46")]
        pub processing_paint_worklets_for_pending_tree: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `MinorState`.
    pub mod minor_state {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TreePriority {
            Unspecified = 0,
            SamePriorityForBothTrees = 1,
            SmoothnessTakesPriority = 2,
            NewContentTakesPriority = 3,
        }
        impl TreePriority {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TREE_PRIORITY_UNSPECIFIED",
                    Self::SamePriorityForBothTrees => {
                        "TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES"
                    }
                    Self::SmoothnessTakesPriority => {
                        "TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY"
                    }
                    Self::NewContentTakesPriority => {
                        "TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TREE_PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES" => {
                        Some(Self::SamePriorityForBothTrees)
                    }
                    "TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY" => {
                        Some(Self::SmoothnessTakesPriority)
                    }
                    "TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY" => {
                        Some(Self::NewContentTakesPriority)
                    }
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ScrollHandlerState {
            ScrollHandlerUnspecified = 0,
            ScrollAffectsScrollHandler = 1,
            ScrollDoesNotAffectScrollHandler = 2,
        }
        impl ScrollHandlerState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ScrollHandlerUnspecified => "SCROLL_HANDLER_UNSPECIFIED",
                    Self::ScrollAffectsScrollHandler => "SCROLL_AFFECTS_SCROLL_HANDLER",
                    Self::ScrollDoesNotAffectScrollHandler => {
                        "SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCROLL_HANDLER_UNSPECIFIED" => Some(Self::ScrollHandlerUnspecified),
                    "SCROLL_AFFECTS_SCROLL_HANDLER" => {
                        Some(Self::ScrollAffectsScrollHandler)
                    }
                    "SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER" => {
                        Some(Self::ScrollDoesNotAffectScrollHandler)
                    }
                    _ => None,
                }
            }
        }
    }
}
/// Next id: 13
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginFrameArgs {
    #[prost(enumeration = "begin_frame_args::BeginFrameArgsType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub source_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub sequence_number: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "4")]
    pub frame_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub deadline_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub interval_delta_us: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "7")]
    pub on_critical_path: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub animate_only: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "12")]
    pub frames_throttled_since_last: ::core::option::Option<i64>,
    #[prost(oneof = "begin_frame_args::CreatedFrom", tags = "9, 10")]
    pub created_from: ::core::option::Option<begin_frame_args::CreatedFrom>,
}
/// Nested message and enum types in `BeginFrameArgs`.
pub mod begin_frame_args {
    /// JSON format has a "type" field that was always just "BeginFrameArgs" we
    /// drop this in the proto representation, and instead make the JSON format
    /// "subtype" field become the type field.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BeginFrameArgsType {
        Unspecified = 0,
        Invalid = 1,
        Normal = 2,
        Missed = 3,
    }
    impl BeginFrameArgsType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED",
                Self::Invalid => "BEGIN_FRAME_ARGS_TYPE_INVALID",
                Self::Normal => "BEGIN_FRAME_ARGS_TYPE_NORMAL",
                Self::Missed => "BEGIN_FRAME_ARGS_TYPE_MISSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BEGIN_FRAME_ARGS_TYPE_INVALID" => Some(Self::Invalid),
                "BEGIN_FRAME_ARGS_TYPE_NORMAL" => Some(Self::Normal),
                "BEGIN_FRAME_ARGS_TYPE_MISSED" => Some(Self::Missed),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CreatedFrom {
        /// The interned SourceLocation.
        #[prost(uint64, tag = "9")]
        SourceLocationIid(u64),
        /// The SourceLocation that this args was created from.
        /// TODO(nuskos): Eventually we will support interning inside of
        /// TypedArgument TraceEvents and then we shouldn't need this SourceLocation
        /// since we can emit it as part of the InternedData message. When we can
        /// remove this |source_location|.
        #[prost(message, tag = "10")]
        SourceLocation(super::SourceLocation),
    }
}
/// Next id: 7
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginImplFrameArgs {
    #[prost(int64, optional, tag = "1")]
    pub updated_at_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub finished_at_us: ::core::option::Option<i64>,
    #[prost(enumeration = "begin_impl_frame_args::State", optional, tag = "3")]
    pub state: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub timestamps_in_us: ::core::option::Option<begin_impl_frame_args::TimestampsInUs>,
    #[prost(oneof = "begin_impl_frame_args::Args", tags = "4, 5")]
    pub args: ::core::option::Option<begin_impl_frame_args::Args>,
}
/// Nested message and enum types in `BeginImplFrameArgs`.
pub mod begin_impl_frame_args {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TimestampsInUs {
        #[prost(int64, optional, tag = "1")]
        pub interval_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "2")]
        pub now_to_deadline_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "3")]
        pub frame_time_to_now_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub frame_time_to_deadline_delta: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "5")]
        pub now: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "6")]
        pub frame_time: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "7")]
        pub deadline: ::core::option::Option<i64>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        BeginFrameFinished = 0,
        BeginFrameUsing = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BeginFrameFinished => "BEGIN_FRAME_FINISHED",
                Self::BeginFrameUsing => "BEGIN_FRAME_USING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BEGIN_FRAME_FINISHED" => Some(Self::BeginFrameFinished),
                "BEGIN_FRAME_USING" => Some(Self::BeginFrameUsing),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Args {
        /// Only set if |state| is BEGIN_FRAME_FINISHED.
        #[prost(message, tag = "4")]
        CurrentArgs(super::BeginFrameArgs),
        /// Only set if |state| is BEGIN_FRAME_USING.
        #[prost(message, tag = "5")]
        LastArgs(super::BeginFrameArgs),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginFrameObserverState {
    #[prost(int64, optional, tag = "1")]
    pub dropped_begin_frame_args: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub last_begin_frame_args: ::core::option::Option<BeginFrameArgs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginFrameSourceState {
    #[prost(uint32, optional, tag = "1")]
    pub source_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub paused: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "3")]
    pub num_observers: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub last_begin_frame_args: ::core::option::Option<BeginFrameArgs>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompositorTimingHistory {
    #[prost(int64, optional, tag = "1")]
    pub begin_main_frame_queue_critical_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub begin_main_frame_queue_not_critical_estimate_delta_us: ::core::option::Option<
        i64,
    >,
    #[prost(int64, optional, tag = "3")]
    pub begin_main_frame_start_to_ready_to_commit_estimate_delta_us: ::core::option::Option<
        i64,
    >,
    #[prost(int64, optional, tag = "4")]
    pub commit_to_ready_to_activate_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub prepare_tiles_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub activate_estimate_delta_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub draw_estimate_delta_us: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChromeCompositorSchedulerAction {
    CcSchedulerActionUnspecified = 0,
    CcSchedulerActionNone = 1,
    CcSchedulerActionSendBeginMainFrame = 2,
    CcSchedulerActionCommit = 3,
    CcSchedulerActionActivateSyncTree = 4,
    CcSchedulerActionDrawIfPossible = 5,
    CcSchedulerActionDrawForced = 6,
    CcSchedulerActionDrawAbort = 7,
    CcSchedulerActionBeginLayerTreeFrameSinkCreation = 8,
    CcSchedulerActionPrepareTiles = 9,
    CcSchedulerActionInvalidateLayerTreeFrameSink = 10,
    CcSchedulerActionPerformImplSideInvalidation = 11,
    CcSchedulerActionNotifyBeginMainFrameNotExpectedUntil = 12,
    CcSchedulerActionNotifyBeginMainFrameNotExpectedSoon = 13,
}
impl ChromeCompositorSchedulerAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CcSchedulerActionUnspecified => "CC_SCHEDULER_ACTION_UNSPECIFIED",
            Self::CcSchedulerActionNone => "CC_SCHEDULER_ACTION_NONE",
            Self::CcSchedulerActionSendBeginMainFrame => {
                "CC_SCHEDULER_ACTION_SEND_BEGIN_MAIN_FRAME"
            }
            Self::CcSchedulerActionCommit => "CC_SCHEDULER_ACTION_COMMIT",
            Self::CcSchedulerActionActivateSyncTree => {
                "CC_SCHEDULER_ACTION_ACTIVATE_SYNC_TREE"
            }
            Self::CcSchedulerActionDrawIfPossible => {
                "CC_SCHEDULER_ACTION_DRAW_IF_POSSIBLE"
            }
            Self::CcSchedulerActionDrawForced => "CC_SCHEDULER_ACTION_DRAW_FORCED",
            Self::CcSchedulerActionDrawAbort => "CC_SCHEDULER_ACTION_DRAW_ABORT",
            Self::CcSchedulerActionBeginLayerTreeFrameSinkCreation => {
                "CC_SCHEDULER_ACTION_BEGIN_LAYER_TREE_FRAME_SINK_CREATION"
            }
            Self::CcSchedulerActionPrepareTiles => "CC_SCHEDULER_ACTION_PREPARE_TILES",
            Self::CcSchedulerActionInvalidateLayerTreeFrameSink => {
                "CC_SCHEDULER_ACTION_INVALIDATE_LAYER_TREE_FRAME_SINK"
            }
            Self::CcSchedulerActionPerformImplSideInvalidation => {
                "CC_SCHEDULER_ACTION_PERFORM_IMPL_SIDE_INVALIDATION"
            }
            Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedUntil => {
                "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL"
            }
            Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedSoon => {
                "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CC_SCHEDULER_ACTION_UNSPECIFIED" => Some(Self::CcSchedulerActionUnspecified),
            "CC_SCHEDULER_ACTION_NONE" => Some(Self::CcSchedulerActionNone),
            "CC_SCHEDULER_ACTION_SEND_BEGIN_MAIN_FRAME" => {
                Some(Self::CcSchedulerActionSendBeginMainFrame)
            }
            "CC_SCHEDULER_ACTION_COMMIT" => Some(Self::CcSchedulerActionCommit),
            "CC_SCHEDULER_ACTION_ACTIVATE_SYNC_TREE" => {
                Some(Self::CcSchedulerActionActivateSyncTree)
            }
            "CC_SCHEDULER_ACTION_DRAW_IF_POSSIBLE" => {
                Some(Self::CcSchedulerActionDrawIfPossible)
            }
            "CC_SCHEDULER_ACTION_DRAW_FORCED" => Some(Self::CcSchedulerActionDrawForced),
            "CC_SCHEDULER_ACTION_DRAW_ABORT" => Some(Self::CcSchedulerActionDrawAbort),
            "CC_SCHEDULER_ACTION_BEGIN_LAYER_TREE_FRAME_SINK_CREATION" => {
                Some(Self::CcSchedulerActionBeginLayerTreeFrameSinkCreation)
            }
            "CC_SCHEDULER_ACTION_PREPARE_TILES" => {
                Some(Self::CcSchedulerActionPrepareTiles)
            }
            "CC_SCHEDULER_ACTION_INVALIDATE_LAYER_TREE_FRAME_SINK" => {
                Some(Self::CcSchedulerActionInvalidateLayerTreeFrameSink)
            }
            "CC_SCHEDULER_ACTION_PERFORM_IMPL_SIDE_INVALIDATION" => {
                Some(Self::CcSchedulerActionPerformImplSideInvalidation)
            }
            "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL" => {
                Some(Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedUntil)
            }
            "CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON" => {
                Some(Self::CcSchedulerActionNotifyBeginMainFrameNotExpectedSoon)
            }
            _ => None,
        }
    }
}
/// Details about ContentSettings trace events.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeContentSettingsEventInfo {
    /// The number of user defined hostname patterns for content settings at
    /// browser start. Similar to UMA histogram
    /// 'ContentSettings.NumberOfExceptions'.
    #[prost(uint32, optional, tag = "1")]
    pub number_of_exceptions: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeFrameReporter {
    #[prost(enumeration = "chrome_frame_reporter::State", optional, tag = "1")]
    pub state: ::core::option::Option<i32>,
    /// The reason is set only if |state| is not |STATE_UPDATED_ALL|.
    #[prost(enumeration = "chrome_frame_reporter::FrameDropReason", optional, tag = "2")]
    pub reason: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3")]
    pub frame_source: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub frame_sequence: ::core::option::Option<u64>,
    /// If this is a droped frame (i.e. if |state| is set to |STATE_DROPPED| or
    /// |STATE_PRESENTED_PARTIAL|), then indicates whether this frame impacts
    /// smoothness.
    #[prost(bool, optional, tag = "5")]
    pub affects_smoothness: ::core::option::Option<bool>,
    /// The type of active scroll.
    #[prost(enumeration = "chrome_frame_reporter::ScrollState", optional, tag = "6")]
    pub scroll_state: ::core::option::Option<i32>,
    /// If any main thread animation is active during this frame.
    #[prost(bool, optional, tag = "7")]
    pub has_main_animation: ::core::option::Option<bool>,
    /// If any compositor thread animation is active during this frame.
    #[prost(bool, optional, tag = "8")]
    pub has_compositor_animation: ::core::option::Option<bool>,
    /// If any touch-driven UX (not scroll) is active during this frame.
    #[prost(bool, optional, tag = "9")]
    pub has_smooth_input_main: ::core::option::Option<bool>,
    /// Whether the frame contained any missing content (i.e. whether there was
    /// checkerboarding in the frame).
    #[prost(bool, optional, tag = "10")]
    pub has_missing_content: ::core::option::Option<bool>,
    /// The id of layer_tree_host that the frame has been produced for.
    #[prost(uint64, optional, tag = "11")]
    pub layer_tree_host_id: ::core::option::Option<u64>,
    /// If total latency of PipelineReporter exceeds a certain limit.
    #[prost(bool, optional, tag = "12")]
    pub has_high_latency: ::core::option::Option<bool>,
    /// Indicate if the frame is "FORKED" (i.e. a PipelineReporter event starts at
    /// the same frame sequence as another PipelineReporter) or "BACKFILL"
    /// (i.e. dropped frames when there are no partial compositor updates).
    #[prost(enumeration = "chrome_frame_reporter::FrameType", optional, tag = "13")]
    pub frame_type: ::core::option::Option<i32>,
    /// The breakdown stage of PipelineReporter that is most likely accountable for
    /// high latency.
    #[prost(string, repeated, tag = "14")]
    pub high_latency_contribution_stage: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `ChromeFrameReporter`.
pub mod chrome_frame_reporter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The frame did not have any updates to present.
        NoUpdateDesired = 0,
        /// The frame presented all the desired updates (i.e. any updates requested
        /// from both the compositor thread and main-threads were handled).
        PresentedAll = 1,
        /// The frame was presented with some updates, but also missed some updates
        /// (e.g. missed updates from the main-thread, but included updates from the
        /// compositor thread).
        PresentedPartial = 2,
        /// The frame was dropped, i.e. some updates were desired for the frame, but
        /// was not presented.
        Dropped = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoUpdateDesired => "STATE_NO_UPDATE_DESIRED",
                Self::PresentedAll => "STATE_PRESENTED_ALL",
                Self::PresentedPartial => "STATE_PRESENTED_PARTIAL",
                Self::Dropped => "STATE_DROPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_NO_UPDATE_DESIRED" => Some(Self::NoUpdateDesired),
                "STATE_PRESENTED_ALL" => Some(Self::PresentedAll),
                "STATE_PRESENTED_PARTIAL" => Some(Self::PresentedPartial),
                "STATE_DROPPED" => Some(Self::Dropped),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameDropReason {
        ReasonUnspecified = 0,
        /// Frame was dropped by the display-compositor.
        /// The display-compositor may drop a frame some times (e.g. the frame missed
        /// the deadline, or was blocked on surface-sync, etc.)
        ReasonDisplayCompositor = 1,
        /// Frame was dropped because of the main-thread.
        /// The main-thread may cause a frame to be dropped, e.g. if the main-thread
        /// is running expensive javascript, or doing a lot of layout updates, etc.
        ReasonMainThread = 2,
        /// Frame was dropped by the client compositor.
        /// The client compositor can drop some frames too (e.g. attempting to
        /// recover latency, missing the deadline, etc.).
        ReasonClientCompositor = 3,
    }
    impl FrameDropReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ReasonUnspecified => "REASON_UNSPECIFIED",
                Self::ReasonDisplayCompositor => "REASON_DISPLAY_COMPOSITOR",
                Self::ReasonMainThread => "REASON_MAIN_THREAD",
                Self::ReasonClientCompositor => "REASON_CLIENT_COMPOSITOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::ReasonUnspecified),
                "REASON_DISPLAY_COMPOSITOR" => Some(Self::ReasonDisplayCompositor),
                "REASON_MAIN_THREAD" => Some(Self::ReasonMainThread),
                "REASON_CLIENT_COMPOSITOR" => Some(Self::ReasonClientCompositor),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScrollState {
        ScrollNone = 0,
        ScrollMainThread = 1,
        ScrollCompositorThread = 2,
        /// Used when it can't be determined whether a scroll is in progress or not.
        ScrollUnknown = 3,
    }
    impl ScrollState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ScrollNone => "SCROLL_NONE",
                Self::ScrollMainThread => "SCROLL_MAIN_THREAD",
                Self::ScrollCompositorThread => "SCROLL_COMPOSITOR_THREAD",
                Self::ScrollUnknown => "SCROLL_UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCROLL_NONE" => Some(Self::ScrollNone),
                "SCROLL_MAIN_THREAD" => Some(Self::ScrollMainThread),
                "SCROLL_COMPOSITOR_THREAD" => Some(Self::ScrollCompositorThread),
                "SCROLL_UNKNOWN" => Some(Self::ScrollUnknown),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameType {
        Forked = 0,
        Backfill = 1,
    }
    impl FrameType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Forked => "FORKED",
                Self::Backfill => "BACKFILL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORKED" => Some(Self::Forked),
                "BACKFILL" => Some(Self::Backfill),
                _ => None,
            }
        }
    }
}
/// Details about one of Chrome's keyed services associated with the event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeKeyedService {
    /// Name of the service, e.g. "MediaRouter", "PreviewsService", etc. (in
    /// Chrome, these are static strings known at compile time).
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeLatencyInfo {
    #[prost(int64, optional, tag = "1")]
    pub trace_id: ::core::option::Option<i64>,
    #[prost(enumeration = "chrome_latency_info::Step", optional, tag = "2")]
    pub step: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub frame_tree_node_id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub component_info: ::prost::alloc::vec::Vec<chrome_latency_info::ComponentInfo>,
    #[prost(bool, optional, tag = "5")]
    pub is_coalesced: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "6")]
    pub gesture_scroll_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub touch_id: ::core::option::Option<i64>,
}
/// Nested message and enum types in `ChromeLatencyInfo`.
pub mod chrome_latency_info {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ComponentInfo {
        #[prost(enumeration = "LatencyComponentType", optional, tag = "1")]
        pub component_type: ::core::option::Option<i32>,
        /// Microsecond timestamp in CLOCK_MONOTONIC domain
        #[prost(uint64, optional, tag = "2")]
        pub time_us: ::core::option::Option<u64>,
    }
    /// NEXT ID: 12
    /// All step are optional but the enum is ordered (not by number) below in the
    /// order we expect them to appear if they are emitted in trace in a blocking
    /// fashion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Step {
        Unspecified = 0,
        /// Emitted on the browser main thread.
        SendInputEventUi = 3,
        /// Happens on the renderer's compositor.
        HandleInputEventImpl = 5,
        DidHandleInputAndOverscroll = 8,
        /// Occurs on the Renderer's main thread.
        HandleInputEventMain = 4,
        MainThreadScrollUpdate = 2,
        HandleInputEventMainCommit = 1,
        /// Could be emitted on both the renderer's main OR compositor.
        HandledInputEventMainOrImpl = 9,
        /// Optionally sometimes HANDLED_INPUT_EVENT_MAIN_OR_IMPL will proxy to the
        /// renderer's compositor and this will be emitted.
        HandledInputEventImpl = 10,
        /// Renderer's compositor.
        SwapBuffers = 6,
        /// Happens on the VizCompositor in the GPU process.
        DrawAndSwap = 7,
        /// Happens on the GPU main thread after the swap has completed.
        ///
        /// See above for NEXT ID, enum steps are not ordered by tag number.
        FinishedSwapBuffers = 11,
    }
    impl Step {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STEP_UNSPECIFIED",
                Self::SendInputEventUi => "STEP_SEND_INPUT_EVENT_UI",
                Self::HandleInputEventImpl => "STEP_HANDLE_INPUT_EVENT_IMPL",
                Self::DidHandleInputAndOverscroll => {
                    "STEP_DID_HANDLE_INPUT_AND_OVERSCROLL"
                }
                Self::HandleInputEventMain => "STEP_HANDLE_INPUT_EVENT_MAIN",
                Self::MainThreadScrollUpdate => "STEP_MAIN_THREAD_SCROLL_UPDATE",
                Self::HandleInputEventMainCommit => "STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT",
                Self::HandledInputEventMainOrImpl => {
                    "STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL"
                }
                Self::HandledInputEventImpl => "STEP_HANDLED_INPUT_EVENT_IMPL",
                Self::SwapBuffers => "STEP_SWAP_BUFFERS",
                Self::DrawAndSwap => "STEP_DRAW_AND_SWAP",
                Self::FinishedSwapBuffers => "STEP_FINISHED_SWAP_BUFFERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STEP_UNSPECIFIED" => Some(Self::Unspecified),
                "STEP_SEND_INPUT_EVENT_UI" => Some(Self::SendInputEventUi),
                "STEP_HANDLE_INPUT_EVENT_IMPL" => Some(Self::HandleInputEventImpl),
                "STEP_DID_HANDLE_INPUT_AND_OVERSCROLL" => {
                    Some(Self::DidHandleInputAndOverscroll)
                }
                "STEP_HANDLE_INPUT_EVENT_MAIN" => Some(Self::HandleInputEventMain),
                "STEP_MAIN_THREAD_SCROLL_UPDATE" => Some(Self::MainThreadScrollUpdate),
                "STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT" => {
                    Some(Self::HandleInputEventMainCommit)
                }
                "STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL" => {
                    Some(Self::HandledInputEventMainOrImpl)
                }
                "STEP_HANDLED_INPUT_EVENT_IMPL" => Some(Self::HandledInputEventImpl),
                "STEP_SWAP_BUFFERS" => Some(Self::SwapBuffers),
                "STEP_DRAW_AND_SWAP" => Some(Self::DrawAndSwap),
                "STEP_FINISHED_SWAP_BUFFERS" => Some(Self::FinishedSwapBuffers),
                _ => None,
            }
        }
    }
    /// This enum is a copy of LatencyComponentType enum in Chrome, located in
    /// ui/latency/latency_info.h, modulo added UNKNOWN value per protobuf
    /// practices.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LatencyComponentType {
        ComponentUnspecified = 0,
        ComponentInputEventLatencyBeginRwh = 1,
        ComponentInputEventLatencyScrollUpdateOriginal = 2,
        ComponentInputEventLatencyFirstScrollUpdateOriginal = 3,
        ComponentInputEventLatencyOriginal = 4,
        ComponentInputEventLatencyUi = 5,
        ComponentInputEventLatencyRendererMain = 6,
        ComponentInputEventLatencyRenderingScheduledMain = 7,
        ComponentInputEventLatencyRenderingScheduledImpl = 8,
        ComponentInputEventLatencyScrollUpdateLastEvent = 9,
        ComponentInputEventLatencyAckRwh = 10,
        ComponentInputEventLatencyRendererSwap = 11,
        ComponentDisplayCompositorReceivedFrame = 12,
        ComponentInputEventGpuSwapBuffer = 13,
        ComponentInputEventLatencyFrameSwap = 14,
    }
    impl LatencyComponentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ComponentUnspecified => "COMPONENT_UNSPECIFIED",
                Self::ComponentInputEventLatencyBeginRwh => {
                    "COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH"
                }
                Self::ComponentInputEventLatencyScrollUpdateOriginal => {
                    "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL"
                }
                Self::ComponentInputEventLatencyFirstScrollUpdateOriginal => {
                    "COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL"
                }
                Self::ComponentInputEventLatencyOriginal => {
                    "COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL"
                }
                Self::ComponentInputEventLatencyUi => "COMPONENT_INPUT_EVENT_LATENCY_UI",
                Self::ComponentInputEventLatencyRendererMain => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN"
                }
                Self::ComponentInputEventLatencyRenderingScheduledMain => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN"
                }
                Self::ComponentInputEventLatencyRenderingScheduledImpl => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL"
                }
                Self::ComponentInputEventLatencyScrollUpdateLastEvent => {
                    "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT"
                }
                Self::ComponentInputEventLatencyAckRwh => {
                    "COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH"
                }
                Self::ComponentInputEventLatencyRendererSwap => {
                    "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP"
                }
                Self::ComponentDisplayCompositorReceivedFrame => {
                    "COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME"
                }
                Self::ComponentInputEventGpuSwapBuffer => {
                    "COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER"
                }
                Self::ComponentInputEventLatencyFrameSwap => {
                    "COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPONENT_UNSPECIFIED" => Some(Self::ComponentUnspecified),
                "COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH" => {
                    Some(Self::ComponentInputEventLatencyBeginRwh)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL" => {
                    Some(Self::ComponentInputEventLatencyScrollUpdateOriginal)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL" => {
                    Some(Self::ComponentInputEventLatencyFirstScrollUpdateOriginal)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL" => {
                    Some(Self::ComponentInputEventLatencyOriginal)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_UI" => {
                    Some(Self::ComponentInputEventLatencyUi)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN" => {
                    Some(Self::ComponentInputEventLatencyRendererMain)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN" => {
                    Some(Self::ComponentInputEventLatencyRenderingScheduledMain)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL" => {
                    Some(Self::ComponentInputEventLatencyRenderingScheduledImpl)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT" => {
                    Some(Self::ComponentInputEventLatencyScrollUpdateLastEvent)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH" => {
                    Some(Self::ComponentInputEventLatencyAckRwh)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP" => {
                    Some(Self::ComponentInputEventLatencyRendererSwap)
                }
                "COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME" => {
                    Some(Self::ComponentDisplayCompositorReceivedFrame)
                }
                "COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER" => {
                    Some(Self::ComponentInputEventGpuSwapBuffer)
                }
                "COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP" => {
                    Some(Self::ComponentInputEventLatencyFrameSwap)
                }
                _ => None,
            }
        }
    }
}
/// Details about a legacy Chrome IPC message that is either sent by the event.
/// TODO(eseckler): Also use this message on the receiving side?
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeLegacyIpc {
    /// Corresponds to the message class type defined in Chrome's IPCMessageStart
    /// enum, e.g. FrameMsgStart,
    #[prost(enumeration = "chrome_legacy_ipc::MessageClass", optional, tag = "1")]
    pub message_class: ::core::option::Option<i32>,
    /// Line number of the message definition. See Chrome's IPC_MESSAGE_ID and
    /// IPC_MESSAGE_START macros.
    #[prost(uint32, optional, tag = "2")]
    pub message_line: ::core::option::Option<u32>,
}
/// Nested message and enum types in `ChromeLegacyIpc`.
pub mod chrome_legacy_ipc {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageClass {
        ClassUnspecified = 0,
        ClassAutomation = 1,
        ClassFrame = 2,
        ClassPage = 3,
        ClassView = 4,
        ClassWidget = 5,
        ClassInput = 6,
        ClassTest = 7,
        ClassWorker = 8,
        ClassNacl = 9,
        ClassGpuChannel = 10,
        ClassMedia = 11,
        ClassPpapi = 12,
        ClassChrome = 13,
        ClassDrag = 14,
        ClassPrint = 15,
        ClassExtension = 16,
        ClassTextInputClient = 17,
        ClassBlinkTest = 18,
        ClassAccessibility = 19,
        ClassPrerender = 20,
        ClassChromoting = 21,
        ClassBrowserPlugin = 22,
        ClassAndroidWebView = 23,
        ClassNaclHost = 24,
        ClassEncryptedMedia = 25,
        ClassCast = 26,
        ClassGinJavaBridge = 27,
        ClassChromeUtilityPrinting = 28,
        ClassOzoneGpu = 29,
        ClassWebTest = 30,
        ClassNetworkHints = 31,
        ClassExtensionsGuestView = 32,
        ClassGuestView = 33,
        ClassMediaPlayerDelegate = 34,
        ClassExtensionWorker = 35,
        ClassSubresourceFilter = 36,
        ClassUnfreezableFrame = 37,
    }
    impl MessageClass {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ClassUnspecified => "CLASS_UNSPECIFIED",
                Self::ClassAutomation => "CLASS_AUTOMATION",
                Self::ClassFrame => "CLASS_FRAME",
                Self::ClassPage => "CLASS_PAGE",
                Self::ClassView => "CLASS_VIEW",
                Self::ClassWidget => "CLASS_WIDGET",
                Self::ClassInput => "CLASS_INPUT",
                Self::ClassTest => "CLASS_TEST",
                Self::ClassWorker => "CLASS_WORKER",
                Self::ClassNacl => "CLASS_NACL",
                Self::ClassGpuChannel => "CLASS_GPU_CHANNEL",
                Self::ClassMedia => "CLASS_MEDIA",
                Self::ClassPpapi => "CLASS_PPAPI",
                Self::ClassChrome => "CLASS_CHROME",
                Self::ClassDrag => "CLASS_DRAG",
                Self::ClassPrint => "CLASS_PRINT",
                Self::ClassExtension => "CLASS_EXTENSION",
                Self::ClassTextInputClient => "CLASS_TEXT_INPUT_CLIENT",
                Self::ClassBlinkTest => "CLASS_BLINK_TEST",
                Self::ClassAccessibility => "CLASS_ACCESSIBILITY",
                Self::ClassPrerender => "CLASS_PRERENDER",
                Self::ClassChromoting => "CLASS_CHROMOTING",
                Self::ClassBrowserPlugin => "CLASS_BROWSER_PLUGIN",
                Self::ClassAndroidWebView => "CLASS_ANDROID_WEB_VIEW",
                Self::ClassNaclHost => "CLASS_NACL_HOST",
                Self::ClassEncryptedMedia => "CLASS_ENCRYPTED_MEDIA",
                Self::ClassCast => "CLASS_CAST",
                Self::ClassGinJavaBridge => "CLASS_GIN_JAVA_BRIDGE",
                Self::ClassChromeUtilityPrinting => "CLASS_CHROME_UTILITY_PRINTING",
                Self::ClassOzoneGpu => "CLASS_OZONE_GPU",
                Self::ClassWebTest => "CLASS_WEB_TEST",
                Self::ClassNetworkHints => "CLASS_NETWORK_HINTS",
                Self::ClassExtensionsGuestView => "CLASS_EXTENSIONS_GUEST_VIEW",
                Self::ClassGuestView => "CLASS_GUEST_VIEW",
                Self::ClassMediaPlayerDelegate => "CLASS_MEDIA_PLAYER_DELEGATE",
                Self::ClassExtensionWorker => "CLASS_EXTENSION_WORKER",
                Self::ClassSubresourceFilter => "CLASS_SUBRESOURCE_FILTER",
                Self::ClassUnfreezableFrame => "CLASS_UNFREEZABLE_FRAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLASS_UNSPECIFIED" => Some(Self::ClassUnspecified),
                "CLASS_AUTOMATION" => Some(Self::ClassAutomation),
                "CLASS_FRAME" => Some(Self::ClassFrame),
                "CLASS_PAGE" => Some(Self::ClassPage),
                "CLASS_VIEW" => Some(Self::ClassView),
                "CLASS_WIDGET" => Some(Self::ClassWidget),
                "CLASS_INPUT" => Some(Self::ClassInput),
                "CLASS_TEST" => Some(Self::ClassTest),
                "CLASS_WORKER" => Some(Self::ClassWorker),
                "CLASS_NACL" => Some(Self::ClassNacl),
                "CLASS_GPU_CHANNEL" => Some(Self::ClassGpuChannel),
                "CLASS_MEDIA" => Some(Self::ClassMedia),
                "CLASS_PPAPI" => Some(Self::ClassPpapi),
                "CLASS_CHROME" => Some(Self::ClassChrome),
                "CLASS_DRAG" => Some(Self::ClassDrag),
                "CLASS_PRINT" => Some(Self::ClassPrint),
                "CLASS_EXTENSION" => Some(Self::ClassExtension),
                "CLASS_TEXT_INPUT_CLIENT" => Some(Self::ClassTextInputClient),
                "CLASS_BLINK_TEST" => Some(Self::ClassBlinkTest),
                "CLASS_ACCESSIBILITY" => Some(Self::ClassAccessibility),
                "CLASS_PRERENDER" => Some(Self::ClassPrerender),
                "CLASS_CHROMOTING" => Some(Self::ClassChromoting),
                "CLASS_BROWSER_PLUGIN" => Some(Self::ClassBrowserPlugin),
                "CLASS_ANDROID_WEB_VIEW" => Some(Self::ClassAndroidWebView),
                "CLASS_NACL_HOST" => Some(Self::ClassNaclHost),
                "CLASS_ENCRYPTED_MEDIA" => Some(Self::ClassEncryptedMedia),
                "CLASS_CAST" => Some(Self::ClassCast),
                "CLASS_GIN_JAVA_BRIDGE" => Some(Self::ClassGinJavaBridge),
                "CLASS_CHROME_UTILITY_PRINTING" => Some(Self::ClassChromeUtilityPrinting),
                "CLASS_OZONE_GPU" => Some(Self::ClassOzoneGpu),
                "CLASS_WEB_TEST" => Some(Self::ClassWebTest),
                "CLASS_NETWORK_HINTS" => Some(Self::ClassNetworkHints),
                "CLASS_EXTENSIONS_GUEST_VIEW" => Some(Self::ClassExtensionsGuestView),
                "CLASS_GUEST_VIEW" => Some(Self::ClassGuestView),
                "CLASS_MEDIA_PLAYER_DELEGATE" => Some(Self::ClassMediaPlayerDelegate),
                "CLASS_EXTENSION_WORKER" => Some(Self::ClassExtensionWorker),
                "CLASS_SUBRESOURCE_FILTER" => Some(Self::ClassSubresourceFilter),
                "CLASS_UNFREEZABLE_FRAME" => Some(Self::ClassUnfreezableFrame),
                _ => None,
            }
        }
    }
}
/// Details about Chrome message pump events
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeMessagePump {
    /// True if there are sent messages in the queue.
    #[prost(bool, optional, tag = "1")]
    pub sent_messages_in_queue: ::core::option::Option<bool>,
    /// Interned SourceLocation of IO handler that MessagePumpForIO is about to
    /// invoke.
    #[prost(uint64, optional, tag = "2")]
    pub io_handler_location_iid: ::core::option::Option<u64>,
}
/// Contains information to identify mojo handling events. The trace events in
/// mojo are common for all mojo interfaces and this information is used to
/// identify who is the caller or callee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeMojoEventInfo {
    /// Contains the interface name or the file name of the creator of a mojo
    /// handle watcher, recorded when an event if notified to the watcher. The code
    /// that runs within the track event belongs to the interface.
    #[prost(string, optional, tag = "1")]
    pub watcher_notify_interface_tag: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// The hash of the IPC message that is being handled.
    #[prost(uint32, optional, tag = "2")]
    pub ipc_hash: ::core::option::Option<u32>,
    /// A static string representing the mojo interface name of the message that is
    /// being handled.
    #[prost(string, optional, tag = "3")]
    pub mojo_interface_tag: ::core::option::Option<::prost::alloc::string::String>,
    /// Refers to an interned UnsymbolizedSourceLocation.
    /// The UnsymbolizedSourceLocation contains the interface method that's being
    /// handled, represented as a native symbol.
    /// The native symbol can be symbolized after the trace is recorded.
    /// Not using a symbolized source location for official Chromium builds to
    /// reduce binary size - emitting file/function names as strings into the
    /// trace requires storing them in the binary, which causes a significant
    /// binary size bloat for Chromium.
    #[prost(uint64, optional, tag = "4")]
    pub mojo_interface_method_iid: ::core::option::Option<u64>,
    /// Indicate whether this is a message or reply.
    #[prost(bool, optional, tag = "5")]
    pub is_reply: ::core::option::Option<bool>,
    /// The payload size of the message being sent through mojo messages.
    #[prost(uint64, optional, tag = "6")]
    pub payload_size: ::core::option::Option<u64>,
    /// Represents the size of the message. Includes all headers and user payload.
    #[prost(uint64, optional, tag = "7")]
    pub data_num_bytes: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeRendererSchedulerState {
    #[prost(enumeration = "ChromeRailMode", optional, tag = "1")]
    pub rail_mode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_backgrounded: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_hidden: ::core::option::Option<bool>,
}
/// RAIL Mode is an indication of the kind of work that a Renderer is currently
/// performing which is in turn used to prioritise work accordingly.
/// A fuller description of these modes can be found <https://web.dev/rail/>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChromeRailMode {
    RailModeNone = 0,
    RailModeResponse = 1,
    RailModeAnimation = 2,
    RailModeIdle = 3,
    RailModeLoad = 4,
}
impl ChromeRailMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RailModeNone => "RAIL_MODE_NONE",
            Self::RailModeResponse => "RAIL_MODE_RESPONSE",
            Self::RailModeAnimation => "RAIL_MODE_ANIMATION",
            Self::RailModeIdle => "RAIL_MODE_IDLE",
            Self::RailModeLoad => "RAIL_MODE_LOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RAIL_MODE_NONE" => Some(Self::RailModeNone),
            "RAIL_MODE_RESPONSE" => Some(Self::RailModeResponse),
            "RAIL_MODE_ANIMATION" => Some(Self::RailModeAnimation),
            "RAIL_MODE_IDLE" => Some(Self::RailModeIdle),
            "RAIL_MODE_LOAD" => Some(Self::RailModeLoad),
            _ => None,
        }
    }
}
/// Details about a UI interaction initiated by the user, such as opening or
/// closing a tab or a context menu.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeUserEvent {
    /// Name of the action, e.g. "NewTab", "ShowBookmarkManager", etc. (in
    /// Chrome, these are usually static strings known at compile time, or
    /// concatenations of multiple such static strings).
    #[prost(string, optional, tag = "1")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    /// MD5 hash of the action string.
    #[prost(uint64, optional, tag = "2")]
    pub action_hash: ::core::option::Option<u64>,
}
/// Details about HWNDMessageHandler trace events.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeWindowHandleEventInfo {
    #[prost(uint32, optional, tag = "1")]
    pub dpi: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub message_id: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "3")]
    pub hwnd_ptr: ::core::option::Option<u64>,
}
/// Event insights emitted by the Pixel modem.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PixelModemEventInsight {
    /// Opaque string containing arguments from the modem.
    #[prost(string, optional, tag = "1")]
    pub detokenized_message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Screenshot {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub jpg_image: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
/// which describe activity on a track, such as a thread or asynchronous event
/// track. The track is specified using separate TrackDescriptor messages and
/// referred to via the track's UUID.
///
/// A simple TrackEvent packet specifies a timestamp, category, name and type:
/// ```protobuf
///    trace_packet {
///      timestamp: 1000
///      track_event {
///        categories: \["my_cat"\]
///        name: "my_event"
///        type: TYPE_INSTANT
///       }
///     }
/// ```
///
/// To associate an event with a custom track (e.g. a thread), the track is
/// defined in a separate packet and referred to from the TrackEvent by its UUID:
/// ```protobuf
///    trace_packet {
///      track_descriptor {
///        track_uuid: 1234
///        name: "my_track"
///
///        // Optionally, associate the track with a thread.
///        thread_descriptor {
///          pid: 10
///          tid: 10
///          ..
///        }
///      }
///    }
/// ```
///
/// A pair of TYPE_SLICE_BEGIN and _END events form a slice on the track:
///
/// ```protobuf
///    trace_packet {
///      timestamp: 1200
///      track_event {
///        track_uuid: 1234
///        categories: \["my_cat"\]
///        name: "my_slice"
///        type: TYPE_SLICE_BEGIN
///      }
///    }
///    trace_packet {
///      timestamp: 1400
///      track_event {
///        track_uuid: 1234
///        type: TYPE_SLICE_END
///      }
///    }
/// ```
/// TrackEvents also support optimizations to reduce data repetition and encoded
/// data size, e.g. through data interning (names, categories, ...) and delta
/// encoding of timestamps/counters. For details, see the InternedData message.
/// Further, default values for attributes of events on the same sequence (e.g.
/// their default track association) can be emitted as part of a
/// TrackEventDefaults message.
///
/// Next reserved id: 13 (up to 15). Next id: 52.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackEvent {
    /// Names of categories of the event. In the client library, categories are a
    /// way to turn groups of individual events on or off.
    /// interned EventCategoryName.
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub category_iids: ::prost::alloc::vec::Vec<u64>,
    /// non-interned variant.
    #[prost(string, repeated, tag = "22")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "track_event::Type", optional, tag = "9")]
    pub r#type: ::core::option::Option<i32>,
    /// Identifies the track of the event. The default value may be overridden
    /// using TrackEventDefaults, e.g., to specify the track of the TraceWriter's
    /// sequence (in most cases sequence = one thread). If no value is specified
    /// here or in TrackEventDefaults, the TrackEvent will be associated with an
    /// implicit trace-global track (uuid 0). See TrackDescriptor::uuid.
    #[prost(uint64, optional, tag = "11")]
    pub track_uuid: ::core::option::Option<u64>,
    /// To encode counter values more efficiently, we support attaching additional
    /// counter values to a TrackEvent of any type. All values will share the same
    /// timestamp specified in the TracePacket. The value at
    /// extra_counter_values\[N\] is for the counter track referenced by
    /// extra_counter_track_uuids\[N\].
    ///
    /// |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
    /// should always be equal or more uuids than values. It is valid to set more
    /// uuids (e.g. via defaults) than values. If uuids are specified in
    /// TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
    /// default uuid list.
    ///
    /// For example, this allows snapshotting the thread time clock at each
    /// thread-track BEGIN and END event to capture the cpu time delta of a slice.
    #[prost(uint64, repeated, packed = "false", tag = "31")]
    pub extra_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
    #[prost(int64, repeated, packed = "false", tag = "12")]
    pub extra_counter_values: ::prost::alloc::vec::Vec<i64>,
    /// Counter snapshots using floating point instead of integer values.
    #[prost(uint64, repeated, packed = "false", tag = "45")]
    pub extra_double_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
    #[prost(double, repeated, packed = "false", tag = "46")]
    pub extra_double_counter_values: ::prost::alloc::vec::Vec<f64>,
    /// IDs of flows originating, passing through, or ending at this event.
    /// Flow IDs are global within a trace.
    ///
    /// A flow connects a sequence of TrackEvents within or across tracks, e.g.
    /// an input event may be handled on one thread but cause another event on
    /// a different thread - a flow between the two events can associate them.
    ///
    /// The direction of the flows between events is inferred from the events'
    /// timestamps. The earliest event with the same flow ID becomes the source
    /// of the flow. Any events thereafter are intermediate steps of the flow,
    /// until the flow terminates at the last event with the flow ID.
    ///
    /// Flows can also be explicitly terminated (see |terminating_flow_ids|), so
    /// that the same ID can later be reused for another flow.
    /// DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
    #[deprecated]
    #[prost(uint64, repeated, packed = "false", tag = "36")]
    pub flow_ids_old: ::prost::alloc::vec::Vec<u64>,
    /// TODO(b/204341740): replace "flow_ids_old" with "flow_ids" to reduce memory
    /// consumption.
    #[prost(fixed64, repeated, packed = "false", tag = "47")]
    pub flow_ids: ::prost::alloc::vec::Vec<u64>,
    /// List of flow ids which should terminate on this event, otherwise same as
    /// |flow_ids|.
    /// Any one flow ID should be either listed as part of |flow_ids| OR
    /// |terminating_flow_ids|, not both.
    /// DEPRECATED. Only kept for backwards compatibility.  Use
    /// |terminating_flow_ids|.
    #[deprecated]
    #[prost(uint64, repeated, packed = "false", tag = "42")]
    pub terminating_flow_ids_old: ::prost::alloc::vec::Vec<u64>,
    /// TODO(b/204341740): replace "terminating_flow_ids_old" with
    /// "terminating_flow_ids" to reduce memory consumption.
    #[prost(fixed64, repeated, packed = "false", tag = "48")]
    pub terminating_flow_ids: ::prost::alloc::vec::Vec<u64>,
    /// Unstable key/value annotations shown in the trace viewer but not intended
    /// for metrics use.
    #[prost(message, repeated, tag = "4")]
    pub debug_annotations: ::prost::alloc::vec::Vec<DebugAnnotation>,
    /// Typed event arguments:
    #[prost(message, optional, tag = "5")]
    pub task_execution: ::core::option::Option<TaskExecution>,
    #[prost(message, optional, tag = "21")]
    pub log_message: ::core::option::Option<LogMessage>,
    #[prost(message, optional, tag = "24")]
    pub cc_scheduler_state: ::core::option::Option<ChromeCompositorSchedulerState>,
    #[prost(message, optional, tag = "25")]
    pub chrome_user_event: ::core::option::Option<ChromeUserEvent>,
    #[prost(message, optional, tag = "26")]
    pub chrome_keyed_service: ::core::option::Option<ChromeKeyedService>,
    #[prost(message, optional, tag = "27")]
    pub chrome_legacy_ipc: ::core::option::Option<ChromeLegacyIpc>,
    #[prost(message, optional, tag = "28")]
    pub chrome_histogram_sample: ::core::option::Option<ChromeHistogramSample>,
    #[prost(message, optional, tag = "29")]
    pub chrome_latency_info: ::core::option::Option<ChromeLatencyInfo>,
    #[prost(message, optional, tag = "32")]
    pub chrome_frame_reporter: ::core::option::Option<ChromeFrameReporter>,
    #[prost(message, optional, tag = "39")]
    pub chrome_application_state_info: ::core::option::Option<
        ChromeApplicationStateInfo,
    >,
    #[prost(message, optional, tag = "40")]
    pub chrome_renderer_scheduler_state: ::core::option::Option<
        ChromeRendererSchedulerState,
    >,
    #[prost(message, optional, tag = "41")]
    pub chrome_window_handle_event_info: ::core::option::Option<
        ChromeWindowHandleEventInfo,
    >,
    #[prost(message, optional, tag = "43")]
    pub chrome_content_settings_event_info: ::core::option::Option<
        ChromeContentSettingsEventInfo,
    >,
    #[prost(message, optional, tag = "49")]
    pub chrome_active_processes: ::core::option::Option<ChromeActiveProcesses>,
    #[prost(message, optional, tag = "50")]
    pub screenshot: ::core::option::Option<Screenshot>,
    #[prost(message, optional, tag = "51")]
    pub pixel_modem_event_insight: ::core::option::Option<PixelModemEventInsight>,
    #[prost(message, optional, tag = "35")]
    pub chrome_message_pump: ::core::option::Option<ChromeMessagePump>,
    #[prost(message, optional, tag = "38")]
    pub chrome_mojo_event_info: ::core::option::Option<ChromeMojoEventInfo>,
    #[prost(message, optional, tag = "6")]
    pub legacy_event: ::core::option::Option<track_event::LegacyEvent>,
    /// Optional name of the event for its display in trace viewer. May be left
    /// unspecified for events with typed arguments.
    ///
    /// Note that metrics should not rely on event names, as they are prone to
    /// changing. Instead, they should use typed arguments to identify the events
    /// they are interested in.
    #[prost(oneof = "track_event::NameField", tags = "10, 23")]
    pub name_field: ::core::option::Option<track_event::NameField>,
    /// A new value for a counter track. |track_uuid| should refer to a track with
    /// a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
    /// efficient encoding of counter values that are sampled at the beginning/end
    /// of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
    /// Counter values can optionally be encoded in as delta values (positive or
    /// negative) on each packet sequence (see CounterIncrementalBase).
    #[prost(oneof = "track_event::CounterValueField", tags = "30, 44")]
    pub counter_value_field: ::core::option::Option<track_event::CounterValueField>,
    /// This field is used only if the source location represents the function that
    /// executes during this event.
    #[prost(oneof = "track_event::SourceLocationField", tags = "33, 34")]
    pub source_location_field: ::core::option::Option<track_event::SourceLocationField>,
    /// Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
    /// TracePacket instead.
    ///
    /// Timestamp in microseconds (usually CLOCK_MONOTONIC).
    #[prost(oneof = "track_event::Timestamp", tags = "1, 16")]
    pub timestamp: ::core::option::Option<track_event::Timestamp>,
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread time instead.
    ///
    /// CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
    /// microseconds.
    #[prost(oneof = "track_event::ThreadTime", tags = "2, 17")]
    pub thread_time: ::core::option::Option<track_event::ThreadTime>,
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread instruction count instead.
    ///
    /// Value of the instruction counter for the current thread.
    #[prost(oneof = "track_event::ThreadInstructionCount", tags = "8, 20")]
    pub thread_instruction_count: ::core::option::Option<
        track_event::ThreadInstructionCount,
    >,
}
/// Nested message and enum types in `TrackEvent`.
pub mod track_event {
    /// Apart from {category, time, thread time, tid, pid}, other legacy trace
    /// event attributes are initially simply proxied for conversion to a JSON
    /// trace. We intend to gradually transition these attributes to similar native
    /// features in TrackEvent (e.g. async + flow events), or deprecate them
    /// without replacement where transition is unsuitable.
    ///
    /// Next reserved id: 16 (up to 16).
    /// Next id: 20.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LegacyEvent {
        /// Deprecated, use TrackEvent::name(_iid) instead.
        /// interned EventName.
        #[prost(uint64, optional, tag = "1")]
        pub name_iid: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub phase: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "3")]
        pub duration_us: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub thread_duration_us: ::core::option::Option<i64>,
        /// Elapsed retired instruction count during the event.
        #[prost(int64, optional, tag = "15")]
        pub thread_instruction_delta: ::core::option::Option<i64>,
        /// Additional optional scope for |id|.
        #[prost(string, optional, tag = "7")]
        pub id_scope: ::core::option::Option<::prost::alloc::string::String>,
        /// Consider the thread timestamps for async BEGIN/END event pairs as valid.
        #[prost(bool, optional, tag = "9")]
        pub use_async_tts: ::core::option::Option<bool>,
        /// Idenfifies a flow. Flow events with the same bind_id are connected.
        #[prost(uint64, optional, tag = "8")]
        pub bind_id: ::core::option::Option<u64>,
        /// Use the enclosing slice as binding point for a flow end event instead of
        /// the next slice. Flow start/step events always bind to the enclosing
        /// slice.
        #[prost(bool, optional, tag = "12")]
        pub bind_to_enclosing: ::core::option::Option<bool>,
        #[prost(enumeration = "legacy_event::FlowDirection", optional, tag = "13")]
        pub flow_direction: ::core::option::Option<i32>,
        #[prost(enumeration = "legacy_event::InstantEventScope", optional, tag = "14")]
        pub instant_event_scope: ::core::option::Option<i32>,
        /// Override the pid/tid if the writer needs to emit events on behalf of
        /// another process/thread. This should be the exception. Normally, the
        /// pid+tid from ThreadDescriptor is used.
        #[prost(int32, optional, tag = "18")]
        pub pid_override: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "19")]
        pub tid_override: ::core::option::Option<i32>,
        #[prost(oneof = "legacy_event::Id", tags = "6, 10, 11")]
        pub id: ::core::option::Option<legacy_event::Id>,
    }
    /// Nested message and enum types in `LegacyEvent`.
    pub mod legacy_event {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FlowDirection {
            FlowUnspecified = 0,
            FlowIn = 1,
            FlowOut = 2,
            FlowInout = 3,
        }
        impl FlowDirection {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::FlowUnspecified => "FLOW_UNSPECIFIED",
                    Self::FlowIn => "FLOW_IN",
                    Self::FlowOut => "FLOW_OUT",
                    Self::FlowInout => "FLOW_INOUT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FLOW_UNSPECIFIED" => Some(Self::FlowUnspecified),
                    "FLOW_IN" => Some(Self::FlowIn),
                    "FLOW_OUT" => Some(Self::FlowOut),
                    "FLOW_INOUT" => Some(Self::FlowInout),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum InstantEventScope {
            ScopeUnspecified = 0,
            ScopeGlobal = 1,
            ScopeProcess = 2,
            ScopeThread = 3,
        }
        impl InstantEventScope {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ScopeUnspecified => "SCOPE_UNSPECIFIED",
                    Self::ScopeGlobal => "SCOPE_GLOBAL",
                    Self::ScopeProcess => "SCOPE_PROCESS",
                    Self::ScopeThread => "SCOPE_THREAD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCOPE_UNSPECIFIED" => Some(Self::ScopeUnspecified),
                    "SCOPE_GLOBAL" => Some(Self::ScopeGlobal),
                    "SCOPE_PROCESS" => Some(Self::ScopeProcess),
                    "SCOPE_THREAD" => Some(Self::ScopeThread),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Id {
            #[prost(uint64, tag = "6")]
            UnscopedId(u64),
            #[prost(uint64, tag = "10")]
            LocalId(u64),
            #[prost(uint64, tag = "11")]
            GlobalId(u64),
        }
    }
    /// Type of the TrackEvent (required if |phase| in LegacyEvent is not set).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        /// Slice events are events that have a begin and end timestamp, i.e. a
        /// duration. They can be nested similar to a callstack: If, on the same
        /// track, event B begins after event A, but before A ends, B is a child
        /// event of A and will be drawn as a nested event underneath A in the UI.
        /// Note that child events should always end before their parents (e.g. B
        /// before A).
        ///
        /// Each slice event is formed by a pair of BEGIN + END events. The END event
        /// does not need to repeat any TrackEvent fields it has in common with its
        /// corresponding BEGIN event. Arguments and debug annotations of the BEGIN +
        /// END pair will be merged during trace import.
        ///
        /// Note that we deliberately chose not to support COMPLETE events (which
        /// would specify a duration directly) since clients would need to delay
        /// writing them until the slice is completed, which can result in reordered
        /// events in the trace and loss of unfinished events at the end of a trace.
        SliceBegin = 1,
        SliceEnd = 2,
        /// Instant events are nestable events without duration. They can be children
        /// of slice events on the same track.
        Instant = 3,
        /// Event that provides a value for a counter track. |track_uuid| should
        /// refer to a counter track and |counter_value| set to the new value. Note
        /// that most other TrackEvent fields (e.g. categories, name, ..) are not
        /// supported for TYPE_COUNTER events. See also CounterDescriptor.
        Counter = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::SliceBegin => "TYPE_SLICE_BEGIN",
                Self::SliceEnd => "TYPE_SLICE_END",
                Self::Instant => "TYPE_INSTANT",
                Self::Counter => "TYPE_COUNTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_SLICE_BEGIN" => Some(Self::SliceBegin),
                "TYPE_SLICE_END" => Some(Self::SliceEnd),
                "TYPE_INSTANT" => Some(Self::Instant),
                "TYPE_COUNTER" => Some(Self::Counter),
                _ => None,
            }
        }
    }
    /// Optional name of the event for its display in trace viewer. May be left
    /// unspecified for events with typed arguments.
    ///
    /// Note that metrics should not rely on event names, as they are prone to
    /// changing. Instead, they should use typed arguments to identify the events
    /// they are interested in.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NameField {
        /// interned EventName.
        #[prost(uint64, tag = "10")]
        NameIid(u64),
        /// non-interned variant.
        #[prost(string, tag = "23")]
        Name(::prost::alloc::string::String),
    }
    /// A new value for a counter track. |track_uuid| should refer to a track with
    /// a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
    /// efficient encoding of counter values that are sampled at the beginning/end
    /// of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
    /// Counter values can optionally be encoded in as delta values (positive or
    /// negative) on each packet sequence (see CounterIncrementalBase).
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum CounterValueField {
        #[prost(int64, tag = "30")]
        CounterValue(i64),
        #[prost(double, tag = "44")]
        DoubleCounterValue(f64),
    }
    /// This field is used only if the source location represents the function that
    /// executes during this event.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceLocationField {
        /// Non-interned field.
        #[prost(message, tag = "33")]
        SourceLocation(super::SourceLocation),
        /// Interned field.
        #[prost(uint64, tag = "34")]
        SourceLocationIid(u64),
    }
    /// Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
    /// TracePacket instead.
    ///
    /// Timestamp in microseconds (usually CLOCK_MONOTONIC).
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Timestamp {
        /// Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
        /// calculate the absolute timestamp value, sum up all delta values of the
        /// preceding TrackEvents since the last ThreadDescriptor and add the sum to
        /// the |reference_timestamp| in ThreadDescriptor. This value should always
        /// be positive.
        #[prost(int64, tag = "1")]
        TimestampDeltaUs(i64),
        /// Absolute value (e.g. a manually specified timestamp in the macro).
        /// This is a one-off value that does not affect delta timestamp computation
        /// in subsequent TrackEvents.
        #[prost(int64, tag = "16")]
        TimestampAbsoluteUs(i64),
    }
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread time instead.
    ///
    /// CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
    /// microseconds.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ThreadTime {
        /// Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
        /// calculate the absolute timestamp value, sum up all delta values of the
        /// preceding TrackEvents since the last ThreadDescriptor and add the sum to
        /// the |reference_timestamp| in ThreadDescriptor. This value should always
        /// be positive.
        #[prost(int64, tag = "2")]
        ThreadTimeDeltaUs(i64),
        /// This is a one-off absolute value that does not affect delta timestamp
        /// computation in subsequent TrackEvents.
        #[prost(int64, tag = "17")]
        ThreadTimeAbsoluteUs(i64),
    }
    /// Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
    /// encode thread instruction count instead.
    ///
    /// Value of the instruction counter for the current thread.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ThreadInstructionCount {
        /// Same encoding as |thread_time| field above.
        #[prost(int64, tag = "8")]
        ThreadInstructionCountDelta(i64),
        #[prost(int64, tag = "20")]
        ThreadInstructionCountAbsolute(i64),
    }
}
/// Default values for fields of all TrackEvents on the same packet sequence.
/// Should be emitted as part of TracePacketDefaults whenever incremental state
/// is cleared. It's defined here because field IDs should match those of the
/// corresponding fields in TrackEvent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackEventDefaults {
    #[prost(uint64, optional, tag = "11")]
    pub track_uuid: ::core::option::Option<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "31")]
    pub extra_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "45")]
    pub extra_double_counter_track_uuids: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCategory {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventName {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// The interning fields in this file can refer to 2 different intern tables,
/// depending on the message they are used in. If the interned fields are present
/// in ProfilePacket proto, then the intern tables included in the ProfilePacket
/// should be used. If the intered fields are present in the
/// StreamingProfilePacket proto, then the intern tables included in all of the
/// previous InternedData message with same sequence ID should be used.
/// TODO(fmayer): Move to the intern tables to a common location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternedString {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub str: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// A symbol field that is emitted after the trace is written. These tables would
/// be appended as the last packets in the trace that the profiler will use, so
/// that the actual trace need not be rewritten to symbolize the profiles.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfiledFrameSymbols {
    /// Use the frame id as the interning key for the symbols.
    #[prost(uint64, optional, tag = "1")]
    pub frame_iid: ::core::option::Option<u64>,
    /// key to InternedString
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub function_name_id: ::prost::alloc::vec::Vec<u64>,
    /// key to InternedString
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub file_name_id: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub line_number: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Line {
    #[prost(string, optional, tag = "1")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub source_file_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub line_number: ::core::option::Option<u32>,
}
/// Symbols for a given address in a module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressSymbols {
    #[prost(uint64, optional, tag = "1")]
    pub address: ::core::option::Option<u64>,
    /// Source lines that correspond to this address.
    ///
    /// These are repeated because when inlining happens, multiple functions'
    /// frames can be at a single address. Imagine function Foo calling the
    /// std::vector<int> constructor, which gets inlined at 0xf00. We then get
    /// both Foo and the std::vector<int> constructor when we symbolize the
    /// address.
    #[prost(message, repeated, tag = "2")]
    pub lines: ::prost::alloc::vec::Vec<Line>,
}
/// Symbols for addresses seen in a module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleSymbols {
    /// Fully qualified path to the mapping.
    /// E.g. /system/lib64/libc.so.
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    /// .note.gnu.build-id on Linux (not hex encoded).
    /// uuid on MacOS.
    /// Module GUID on Windows.
    #[prost(string, optional, tag = "2")]
    pub build_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub address_symbols: ::prost::alloc::vec::Vec<AddressSymbols>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mapping {
    /// Interning key.
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    /// Interning key.
    #[prost(uint64, optional, tag = "2")]
    pub build_id: ::core::option::Option<u64>,
    /// This is not set on Android 10.
    #[prost(uint64, optional, tag = "8")]
    pub exact_offset: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub start_offset: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub start: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub end: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub load_bias: ::core::option::Option<u64>,
    /// E.g. \["system", "lib64", "libc.so"\]
    /// id of string.
    #[prost(uint64, repeated, packed = "false", tag = "7")]
    pub path_string_ids: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Frame {
    /// Interning key
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    /// E.g. "fopen"
    /// id of string.
    #[prost(uint64, optional, tag = "2")]
    pub function_name_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub mapping_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub rel_pc: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Callstack {
    #[prost(uint64, optional, tag = "1")]
    pub iid: ::core::option::Option<u64>,
    /// Frames of this callstack. Bottom frame first.
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub frame_ids: ::prost::alloc::vec::Vec<u64>,
}
/// Message that contains new entries for the interning indices of a packet
/// sequence.
///
/// The writer will usually emit new entries in the same TracePacket that first
/// refers to them (since the last reset of interning state). They may also be
/// emitted proactively in advance of referring to them in later packets.
///
/// Next reserved id: 8 (up to 15).
/// Next id: 42.
///
/// TODO(eseckler): Replace iid fields inside interned messages with
/// map<iid, message> type fields in InternedData.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternedData {
    /// Each field's message type needs to specify an |iid| field, which is the ID
    /// of the entry in the field's interning index. Each field constructs its own
    /// index, thus interning IDs are scoped to the tracing session and field
    /// (usually as a counter for efficient var-int encoding), and optionally to
    /// the incremental state generation of the packet sequence.
    #[prost(message, repeated, tag = "1")]
    pub event_categories: ::prost::alloc::vec::Vec<EventCategory>,
    #[prost(message, repeated, tag = "2")]
    pub event_names: ::prost::alloc::vec::Vec<EventName>,
    #[prost(message, repeated, tag = "3")]
    pub debug_annotation_names: ::prost::alloc::vec::Vec<DebugAnnotationName>,
    #[prost(message, repeated, tag = "27")]
    pub debug_annotation_value_type_names: ::prost::alloc::vec::Vec<
        DebugAnnotationValueTypeName,
    >,
    #[prost(message, repeated, tag = "4")]
    pub source_locations: ::prost::alloc::vec::Vec<SourceLocation>,
    #[prost(message, repeated, tag = "28")]
    pub unsymbolized_source_locations: ::prost::alloc::vec::Vec<
        UnsymbolizedSourceLocation,
    >,
    #[prost(message, repeated, tag = "20")]
    pub log_message_body: ::prost::alloc::vec::Vec<LogMessageBody>,
    #[prost(message, repeated, tag = "25")]
    pub histogram_names: ::prost::alloc::vec::Vec<HistogramName>,
    /// Build IDs of exectuable files.
    #[prost(message, repeated, tag = "16")]
    pub build_ids: ::prost::alloc::vec::Vec<InternedString>,
    /// Paths to executable files.
    #[prost(message, repeated, tag = "17")]
    pub mapping_paths: ::prost::alloc::vec::Vec<InternedString>,
    /// Paths to source files.
    #[prost(message, repeated, tag = "18")]
    pub source_paths: ::prost::alloc::vec::Vec<InternedString>,
    /// Names of functions used in frames below.
    #[prost(message, repeated, tag = "5")]
    pub function_names: ::prost::alloc::vec::Vec<InternedString>,
    /// Symbols that were added to this trace after the fact.
    #[prost(message, repeated, tag = "21")]
    pub profiled_frame_symbols: ::prost::alloc::vec::Vec<ProfiledFrameSymbols>,
    /// Executable files mapped into processes.
    #[prost(message, repeated, tag = "19")]
    pub mappings: ::prost::alloc::vec::Vec<Mapping>,
    /// Frames of callstacks of a program.
    #[prost(message, repeated, tag = "6")]
    pub frames: ::prost::alloc::vec::Vec<Frame>,
    /// A callstack of a program.
    #[prost(message, repeated, tag = "7")]
    pub callstacks: ::prost::alloc::vec::Vec<Callstack>,
    /// Additional Vulkan information sent in a VulkanMemoryEvent message
    #[prost(message, repeated, tag = "22")]
    pub vulkan_memory_keys: ::prost::alloc::vec::Vec<InternedString>,
    /// Graphics context of a render stage event.  This represent the GL
    /// context for an OpenGl app or the VkDevice for a Vulkan app.
    #[prost(message, repeated, tag = "23")]
    pub graphics_contexts: ::prost::alloc::vec::Vec<InternedGraphicsContext>,
    /// Description of a GPU hardware queue or render stage.
    #[prost(message, repeated, tag = "24")]
    pub gpu_specifications: ::prost::alloc::vec::Vec<
        InternedGpuRenderStageSpecification,
    >,
    /// This is set when FtraceConfig.symbolize_ksyms = true.
    /// The id of each symbol the number that will be reported in ftrace events
    /// like sched_block_reason.caller and is obtained from a monotonic counter.
    /// The same symbol can have different indexes in different bundles.
    /// This is is NOT the real address. This is to avoid disclosing KASLR through
    /// traces.
    #[prost(message, repeated, tag = "26")]
    pub kernel_symbols: ::prost::alloc::vec::Vec<InternedString>,
    /// Interned string values in the DebugAnnotation proto.
    #[prost(message, repeated, tag = "29")]
    pub debug_annotation_string_values: ::prost::alloc::vec::Vec<InternedString>,
    /// Interned packet context for android.network_packets.
    #[prost(message, repeated, tag = "30")]
    pub packet_context: ::prost::alloc::vec::Vec<NetworkPacketContext>,
    /// Interned name of a js function. We only intern js functions as there is a
    /// lot of duplication for them, but less so for other strings in the V8 data
    /// source.
    #[prost(message, repeated, tag = "31")]
    pub v8_js_function_name: ::prost::alloc::vec::Vec<InternedV8String>,
    /// Js functions can be emitted multiple times for various compilation tiers,
    /// so it makes sense to deduplicate all this.
    #[prost(message, repeated, tag = "32")]
    pub v8_js_function: ::prost::alloc::vec::Vec<InternedV8JsFunction>,
    /// Interned JS script (there is one associated with each JS function)
    #[prost(message, repeated, tag = "33")]
    pub v8_js_script: ::prost::alloc::vec::Vec<InternedV8JsScript>,
    /// Interned Wasm script (there is one associated with each Wasm function)
    #[prost(message, repeated, tag = "34")]
    pub v8_wasm_script: ::prost::alloc::vec::Vec<InternedV8WasmScript>,
    /// Every V8 event is associated with an isolate, intern the isolate to remove
    /// duplication.
    #[prost(message, repeated, tag = "35")]
    pub v8_isolate: ::prost::alloc::vec::Vec<InternedV8Isolate>,
    /// Interned protolog strings args.
    #[prost(message, repeated, tag = "36")]
    pub protolog_string_args: ::prost::alloc::vec::Vec<InternedString>,
    /// Interned protolog stacktraces.
    #[prost(message, repeated, tag = "37")]
    pub protolog_stacktrace: ::prost::alloc::vec::Vec<InternedString>,
    /// viewcapture
    #[prost(message, repeated, tag = "38")]
    pub viewcapture_package_name: ::prost::alloc::vec::Vec<InternedString>,
    #[prost(message, repeated, tag = "39")]
    pub viewcapture_window_name: ::prost::alloc::vec::Vec<InternedString>,
    #[prost(message, repeated, tag = "40")]
    pub viewcapture_view_id: ::prost::alloc::vec::Vec<InternedString>,
    #[prost(message, repeated, tag = "41")]
    pub viewcapture_class_name: ::prost::alloc::vec::Vec<InternedString>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryTrackerSnapshot {
    /// Unique ID that represents the global memory dump.
    #[prost(uint64, optional, tag = "1")]
    pub global_dump_id: ::core::option::Option<u64>,
    #[prost(enumeration = "memory_tracker_snapshot::LevelOfDetail", optional, tag = "2")]
    pub level_of_detail: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub process_memory_dumps: ::prost::alloc::vec::Vec<
        memory_tracker_snapshot::ProcessSnapshot,
    >,
}
/// Nested message and enum types in `MemoryTrackerSnapshot`.
pub mod memory_tracker_snapshot {
    /// Memory snapshot of a process. The snapshot contains memory data that is
    /// from 2 different sources, namely system stats and instrumentation stats.
    /// The system memory usage stats come from the OS based on standard API
    /// available in the platform to query memory usage. The instrumentation stats
    /// are added by instrumenting specific piece of code which tracks memory
    /// allocations and deallocations made by a small sub-system within the
    /// application.
    /// The system stats of the global memory snapshot are recorded as part of
    /// ProcessStats and SmapsPacket fields in trace packet with the same
    /// timestamp.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessSnapshot {
        /// Process ID of the process
        #[prost(int32, optional, tag = "1")]
        pub pid: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "2")]
        pub allocator_dumps: ::prost::alloc::vec::Vec<process_snapshot::MemoryNode>,
        #[prost(message, repeated, tag = "3")]
        pub memory_edges: ::prost::alloc::vec::Vec<process_snapshot::MemoryEdge>,
    }
    /// Nested message and enum types in `ProcessSnapshot`.
    pub mod process_snapshot {
        /// A single node in the memory graph.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MemoryNode {
            /// Unique ID of the node across all processes involved in the global
            /// memory dump. The ID is only unique within this particular global dump
            /// identified by GlobalMemoryDumpPacket.global_dump_id.
            #[prost(uint64, optional, tag = "1")]
            pub id: ::core::option::Option<u64>,
            /// Absolute name is a unique name for the memory node within the process
            /// with ProcessMemoryDump.pid. The name can contain multiple parts
            /// separated by '/', which traces the edges of the node from the root
            /// node.
            /// Eg: "partition_allocator/array_buffers/buffer1" refers to the child
            /// node "buffer1" in a graph structure of:
            ///    root -> partition_allocator -> array_buffers -> buffer1.
            #[prost(string, optional, tag = "2")]
            pub absolute_name: ::core::option::Option<::prost::alloc::string::String>,
            /// A weak node means that the instrumentation that added the current node
            /// is unsure about the existence of the actual memory. Unless a "strong"
            /// (non-weak is default) node that has an edge to the current node exists
            /// in the current global dump, the current node will be discarded.
            #[prost(bool, optional, tag = "3")]
            pub weak: ::core::option::Option<bool>,
            /// Size of the node in bytes, used to compute the effective size of the
            /// nodes without double counting.
            #[prost(uint64, optional, tag = "4")]
            pub size_bytes: ::core::option::Option<u64>,
            #[prost(message, repeated, tag = "5")]
            pub entries: ::prost::alloc::vec::Vec<memory_node::MemoryNodeEntry>,
        }
        /// Nested message and enum types in `MemoryNode`.
        pub mod memory_node {
            /// Entries in the memory node that contain statistics and additional
            /// debuggable information about the memory. The size of the node is
            /// tracked separately in the |size_bytes| field.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct MemoryNodeEntry {
                #[prost(string, optional, tag = "1")]
                pub name: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(enumeration = "memory_node_entry::Units", optional, tag = "2")]
                pub units: ::core::option::Option<i32>,
                /// Contains either one of uint64 or string value.
                #[prost(uint64, optional, tag = "3")]
                pub value_uint64: ::core::option::Option<u64>,
                #[prost(string, optional, tag = "4")]
                pub value_string: ::core::option::Option<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `MemoryNodeEntry`.
            pub mod memory_node_entry {
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Units {
                    Unspecified = 0,
                    Bytes = 1,
                    Count = 2,
                }
                impl Units {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "UNSPECIFIED",
                            Self::Bytes => "BYTES",
                            Self::Count => "COUNT",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "UNSPECIFIED" => Some(Self::Unspecified),
                            "BYTES" => Some(Self::Bytes),
                            "COUNT" => Some(Self::Count),
                            _ => None,
                        }
                    }
                }
            }
        }
        /// A directed edge that connects any 2 nodes in the graph above. These are
        /// in addition to the inherent edges added due to the tree structure of the
        /// node's absolute names.
        /// Node with id |source_id| owns the node with id |target_id|, and has the
        /// effect of attributing the memory usage of target to source. |importance|
        /// is optional and relevant only for the cases of co-ownership, where it
        /// acts as a z-index: the owner with the highest importance will be
        /// attributed target's memory.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MemoryEdge {
            #[prost(uint64, optional, tag = "1")]
            pub source_id: ::core::option::Option<u64>,
            #[prost(uint64, optional, tag = "2")]
            pub target_id: ::core::option::Option<u64>,
            #[prost(uint32, optional, tag = "3")]
            pub importance: ::core::option::Option<u32>,
            #[prost(bool, optional, tag = "4")]
            pub overridable: ::core::option::Option<bool>,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LevelOfDetail {
        DetailFull = 0,
        DetailLight = 1,
        DetailBackground = 2,
    }
    impl LevelOfDetail {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DetailFull => "DETAIL_FULL",
                Self::DetailLight => "DETAIL_LIGHT",
                Self::DetailBackground => "DETAIL_BACKGROUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DETAIL_FULL" => Some(Self::DetailFull),
                "DETAIL_LIGHT" => Some(Self::DetailLight),
                "DETAIL_BACKGROUND" => Some(Self::DetailBackground),
                _ => None,
            }
        }
    }
}
/// Used to trace the execution of perfetto itself.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerfettoMetatrace {
    /// Only when using |event_id|.
    #[prost(uint64, optional, tag = "3")]
    pub event_duration_ns: ::core::option::Option<u64>,
    /// Only when using |counter_id|.
    #[prost(int32, optional, tag = "4")]
    pub counter_value: ::core::option::Option<i32>,
    /// ID of the thread that emitted the event.
    #[prost(uint32, optional, tag = "5")]
    pub thread_id: ::core::option::Option<u32>,
    /// If true the meta-tracing ring buffer had overruns and hence some data is
    /// missing from this point.
    #[prost(bool, optional, tag = "6")]
    pub has_overruns: ::core::option::Option<bool>,
    /// Args for the event.
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<perfetto_metatrace::Arg>,
    #[prost(message, repeated, tag = "10")]
    pub interned_strings: ::prost::alloc::vec::Vec<perfetto_metatrace::InternedString>,
    /// See base/metatrace_events.h for definitions.
    #[prost(oneof = "perfetto_metatrace::RecordType", tags = "1, 2, 8, 11, 9")]
    pub record_type: ::core::option::Option<perfetto_metatrace::RecordType>,
}
/// Nested message and enum types in `PerfettoMetatrace`.
pub mod perfetto_metatrace {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Arg {
        #[prost(oneof = "arg::KeyOrInternedKey", tags = "1, 3")]
        pub key_or_interned_key: ::core::option::Option<arg::KeyOrInternedKey>,
        #[prost(oneof = "arg::ValueOrInternedValue", tags = "2, 4")]
        pub value_or_interned_value: ::core::option::Option<arg::ValueOrInternedValue>,
    }
    /// Nested message and enum types in `Arg`.
    pub mod arg {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum KeyOrInternedKey {
            #[prost(string, tag = "1")]
            Key(::prost::alloc::string::String),
            #[prost(uint64, tag = "3")]
            KeyIid(u64),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ValueOrInternedValue {
            #[prost(string, tag = "2")]
            Value(::prost::alloc::string::String),
            #[prost(uint64, tag = "4")]
            ValueIid(u64),
        }
    }
    /// Interned strings corresponding to the |event_name_iid|, |key_iid| and
    /// |value_iid| above.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InternedString {
        #[prost(uint64, optional, tag = "1")]
        pub iid: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// See base/metatrace_events.h for definitions.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RecordType {
        #[prost(uint32, tag = "1")]
        EventId(u32),
        #[prost(uint32, tag = "2")]
        CounterId(u32),
        /// For trace processor metatracing.
        #[prost(string, tag = "8")]
        EventName(::prost::alloc::string::String),
        #[prost(uint64, tag = "11")]
        EventNameIid(u64),
        #[prost(string, tag = "9")]
        CounterName(::prost::alloc::string::String),
    }
}
/// Events emitted by the tracing service.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TracingServiceEvent {
    /// When each of the following booleans are set to true, they report the
    /// point in time (through TracePacket's timestamp) where the condition
    /// they describe happened.
    /// The order of the booleans below matches the timestamp ordering
    /// they would generally be expected to have.
    #[prost(oneof = "tracing_service_event::EventType", tags = "2, 1, 3, 4, 5, 6")]
    pub event_type: ::core::option::Option<tracing_service_event::EventType>,
}
/// Nested message and enum types in `TracingServiceEvent`.
pub mod tracing_service_event {
    /// When each of the following booleans are set to true, they report the
    /// point in time (through TracePacket's timestamp) where the condition
    /// they describe happened.
    /// The order of the booleans below matches the timestamp ordering
    /// they would generally be expected to have.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum EventType {
        /// Emitted when we start tracing and specifically, this will be before any
        /// producer is notified about the existence of this trace. This is always
        /// emitted before the all_data_sources_started event. This event is also
        /// guaranteed to be seen (byte-offset wise) before any data packets from
        /// producers.
        #[prost(bool, tag = "2")]
        TracingStarted(bool),
        /// Emitted after all data sources saw the start event and ACKed it.
        /// This identifies the point in time when it's safe to assume that all data
        /// sources have been recording events.
        #[prost(bool, tag = "1")]
        AllDataSourcesStarted(bool),
        /// Emitted when all data sources have been flushed successfully or with an
        /// error (including timeouts). This can generally happen many times over the
        /// course of the trace.
        #[prost(bool, tag = "3")]
        AllDataSourcesFlushed(bool),
        /// Emitted when reading back the central tracing buffers has been completed.
        /// If |write_into_file| is specified, this can happen many times over the
        /// course of the trace.
        #[prost(bool, tag = "4")]
        ReadTracingBuffersCompleted(bool),
        /// Emitted after tracing has been disabled and specifically, this will be
        /// after all packets from producers have been included in the central
        /// tracing buffer.
        #[prost(bool, tag = "5")]
        TracingDisabled(bool),
        /// Emitted if perfetto --save-for-bugreport was invoked while the current
        /// tracing session was running and it had the highest bugreport_score. In
        /// this case the original consumer will see a nearly empty trace, because
        /// the contents are routed onto the bugreport file. This event flags the
        /// situation explicitly. Traces that contain this marker should be discarded
        /// by test infrastructures / pipelines.
        /// Deprecated since Android U, where --save-for-bugreport uses
        /// non-destructive cloning.
        #[prost(bool, tag = "6")]
        SeizedForBugreport(bool),
    }
}
/// Energy consumer based on aidl class:
/// android.hardware.power.stats.EnergyConsumer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidEnergyConsumer {
    /// Unique ID of this energy consumer.  Matches the ID in a
    /// AndroidEnergyEstimationBreakdown.
    #[prost(int32, optional, tag = "1")]
    pub energy_consumer_id: ::core::option::Option<i32>,
    /// For a group of energy consumers of the same logical type, sorting by
    /// ordinal gives their physical order. Ordinals must be consecutive integers
    /// starting from 0.
    #[prost(int32, optional, tag = "2")]
    pub ordinal: ::core::option::Option<i32>,
    /// Type of this energy consumer.
    #[prost(string, optional, tag = "3")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// Unique name of this energy consumer. Vendor/device specific. Opaque to
    /// framework.
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidEnergyConsumerDescriptor {
    #[prost(message, repeated, tag = "1")]
    pub energy_consumers: ::prost::alloc::vec::Vec<AndroidEnergyConsumer>,
}
/// Energy data retrieve using the ODPM(On Device Power Monitor) API.
/// This proto represents the aidl class:
/// android.hardware.power.stats.EnergyConsumerResult.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidEnergyEstimationBreakdown {
    /// The first trace packet of each session should include a energy consumer
    /// descriptor.
    #[prost(message, optional, tag = "1")]
    pub energy_consumer_descriptor: ::core::option::Option<
        AndroidEnergyConsumerDescriptor,
    >,
    /// ID of the AndroidEnergyConsumer associated with this result.  Matches
    /// the energy_consumer_id in the AndroidEnergyConsumerDescriptor that
    /// should be sent at the beginning of a trace.
    #[prost(int32, optional, tag = "2")]
    pub energy_consumer_id: ::core::option::Option<i32>,
    /// Total accumulated energy since boot in microwatt-seconds (uWs)
    #[prost(int64, optional, tag = "3")]
    pub energy_uws: ::core::option::Option<i64>,
    /// Optional attributed energy per Android ID / Linux UID for this
    /// EnergyConsumer. Sum total of attributed energy must be less than or equal
    /// to total accumulated energy.
    #[prost(message, repeated, tag = "4")]
    pub per_uid_breakdown: ::prost::alloc::vec::Vec<
        android_energy_estimation_breakdown::EnergyUidBreakdown,
    >,
}
/// Nested message and enum types in `AndroidEnergyEstimationBreakdown`.
pub mod android_energy_estimation_breakdown {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EnergyUidBreakdown {
        /// Android ID/Linux UID, the accumulated energy is attributed to.
        #[prost(int32, optional, tag = "1")]
        pub uid: ::core::option::Option<i32>,
        /// Accumulated energy since boot in microwatt-seconds (uWs).
        #[prost(int64, optional, tag = "2")]
        pub energy_uws: ::core::option::Option<i64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityStateResidency {
    /// This is only emitted at the beginning of the trace.
    #[prost(message, repeated, tag = "1")]
    pub power_entity_state: ::prost::alloc::vec::Vec<
        entity_state_residency::PowerEntityState,
    >,
    #[prost(message, repeated, tag = "2")]
    pub residency: ::prost::alloc::vec::Vec<entity_state_residency::StateResidency>,
}
/// Nested message and enum types in `EntityStateResidency`.
pub mod entity_state_residency {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PowerEntityState {
        /// Index corresponding to the entity
        #[prost(int32, optional, tag = "1")]
        pub entity_index: ::core::option::Option<i32>,
        /// Index corresponding to the state
        #[prost(int32, optional, tag = "2")]
        pub state_index: ::core::option::Option<i32>,
        /// Name of the entity. This is device-specific, determined by the PowerStats
        /// HAL, and cannot be configured by the user. An example would be
        /// "Bluetooth".
        #[prost(string, optional, tag = "3")]
        pub entity_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Name of the state. This is device-specific, determined by the PowerStats
        /// HAL, and cannot be configured by the user. An example would be
        /// "Active".
        #[prost(string, optional, tag = "4")]
        pub state_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StateResidency {
        /// Index corresponding to PowerEntityState.entity_index
        #[prost(int32, optional, tag = "1")]
        pub entity_index: ::core::option::Option<i32>,
        /// Index corresponding to PowerEntityState.state_index
        #[prost(int32, optional, tag = "2")]
        pub state_index: ::core::option::Option<i32>,
        /// Time since boot that this entity has been in this state
        #[prost(uint64, optional, tag = "3")]
        pub total_time_in_state_ms: ::core::option::Option<u64>,
        /// Total number of times since boot that the entity has entered this state
        #[prost(uint64, optional, tag = "4")]
        pub total_state_entry_count: ::core::option::Option<u64>,
        /// Timestamp of the last time the entity entered this state
        #[prost(uint64, optional, tag = "5")]
        pub last_entry_timestamp_ms: ::core::option::Option<u64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatteryCounters {
    /// Battery capacity in microampere-hours(Ah). Also known as Coulomb counter.
    #[prost(int64, optional, tag = "1")]
    pub charge_counter_uah: ::core::option::Option<i64>,
    /// Remaining battery capacity percentage of total capacity
    #[prost(float, optional, tag = "2")]
    pub capacity_percent: ::core::option::Option<f32>,
    /// Instantaneous battery current in microamperes(A).
    /// Negative values indicate current being drained from the battery and
    /// positive values indicate current feeding the battery from a charge source
    /// (USB).
    ///
    /// See <https://perfetto.dev/docs/data-sources/battery-counters> for more info.
    #[prost(int64, optional, tag = "3")]
    pub current_ua: ::core::option::Option<i64>,
    /// Instantaneous battery current in microamperes(A).
    #[prost(int64, optional, tag = "4")]
    pub current_avg_ua: ::core::option::Option<i64>,
    /// Battery name, emitted only on multiple batteries.
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Battery capacity in microwatt-hours(Wh).
    #[prost(int64, optional, tag = "6")]
    pub energy_counter_uwh: ::core::option::Option<i64>,
    /// Battery voltage in microvolts(V).
    #[prost(int64, optional, tag = "7")]
    pub voltage_uv: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PowerRails {
    /// This is only emitted at the beginning of the trace.
    #[prost(message, repeated, tag = "1")]
    pub rail_descriptor: ::prost::alloc::vec::Vec<power_rails::RailDescriptor>,
    #[prost(message, repeated, tag = "2")]
    pub energy_data: ::prost::alloc::vec::Vec<power_rails::EnergyData>,
}
/// Nested message and enum types in `PowerRails`.
pub mod power_rails {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RailDescriptor {
        /// Index corresponding to the rail
        #[prost(uint32, optional, tag = "1")]
        pub index: ::core::option::Option<u32>,
        /// Name of the rail
        #[prost(string, optional, tag = "2")]
        pub rail_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Name of the subsystem to which this rail belongs
        #[prost(string, optional, tag = "3")]
        pub subsys_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Hardware sampling rate (Hz).
        #[prost(uint32, optional, tag = "4")]
        pub sampling_rate: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EnergyData {
        /// Index corresponding to RailDescriptor.index
        #[prost(uint32, optional, tag = "1")]
        pub index: ::core::option::Option<u32>,
        /// Time since device boot(CLOCK_BOOTTIME) in milli-seconds.
        #[prost(uint64, optional, tag = "2")]
        pub timestamp_ms: ::core::option::Option<u64>,
        /// Accumulated energy since device boot in microwatt-seconds (uWs).
        #[prost(uint64, optional, tag = "3")]
        pub energy: ::core::option::Option<u64>,
    }
}
/// Deliberate empty message. See comment on StatsdAtom#atom below.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Atom {}
/// One or more statsd atoms. This must continue to match:
/// perfetto/protos/third_party/statsd/shell_data.proto
/// So that we can efficiently add data from statsd directly to the
/// trace.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsdAtom {
    /// Atom should be filled with an Atom proto from:
    /// <https://cs.android.com/android/platform/superproject/main/+/main:frameworks/proto_logging/stats/atoms.proto?q=f:stats%2Fatoms.proto$%20message%5C%20Atom>
    /// We don't reference Atom directly here since we don't want to import
    /// Atom.proto and all its transitive dependencies into Perfetto.
    /// atom and timestamp_nanos have the same cardinality
    #[prost(message, repeated, tag = "1")]
    pub atom: ::prost::alloc::vec::Vec<Atom>,
    #[prost(int64, repeated, packed = "false", tag = "2")]
    pub timestamp_nanos: ::prost::alloc::vec::Vec<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObfuscatedMember {
    /// This is the obfuscated field name relative to the class containing the
    /// ObfuscatedMember.
    #[prost(string, optional, tag = "1")]
    pub obfuscated_name: ::core::option::Option<::prost::alloc::string::String>,
    /// If this is fully qualified (i.e. contains a '.') this is the deobfuscated
    /// field name including its class. Otherwise, this is this the unqualified
    /// deobfuscated field name relative to the class containing this
    /// ObfuscatedMember.
    #[prost(string, optional, tag = "2")]
    pub deobfuscated_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObfuscatedClass {
    #[prost(string, optional, tag = "1")]
    pub obfuscated_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub deobfuscated_name: ::core::option::Option<::prost::alloc::string::String>,
    /// fields.
    #[prost(message, repeated, tag = "3")]
    pub obfuscated_members: ::prost::alloc::vec::Vec<ObfuscatedMember>,
    #[prost(message, repeated, tag = "4")]
    pub obfuscated_methods: ::prost::alloc::vec::Vec<ObfuscatedMember>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeobfuscationMapping {
    #[prost(string, optional, tag = "1")]
    pub package_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub version_code: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "3")]
    pub obfuscated_classes: ::prost::alloc::vec::Vec<ObfuscatedClass>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeapGraphRoot {
    /// Objects retained by this root.
    #[prost(uint64, repeated, tag = "1")]
    pub object_ids: ::prost::alloc::vec::Vec<u64>,
    #[prost(enumeration = "heap_graph_root::Type", optional, tag = "2")]
    pub root_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `HeapGraphRoot`.
pub mod heap_graph_root {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        RootUnknown = 0,
        RootJniGlobal = 1,
        RootJniLocal = 2,
        RootJavaFrame = 3,
        RootNativeStack = 4,
        RootStickyClass = 5,
        RootThreadBlock = 6,
        RootMonitorUsed = 7,
        RootThreadObject = 8,
        RootInternedString = 9,
        RootFinalizing = 10,
        RootDebugger = 11,
        RootReferenceCleanup = 12,
        RootVmInternal = 13,
        RootJniMonitor = 14,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RootUnknown => "ROOT_UNKNOWN",
                Self::RootJniGlobal => "ROOT_JNI_GLOBAL",
                Self::RootJniLocal => "ROOT_JNI_LOCAL",
                Self::RootJavaFrame => "ROOT_JAVA_FRAME",
                Self::RootNativeStack => "ROOT_NATIVE_STACK",
                Self::RootStickyClass => "ROOT_STICKY_CLASS",
                Self::RootThreadBlock => "ROOT_THREAD_BLOCK",
                Self::RootMonitorUsed => "ROOT_MONITOR_USED",
                Self::RootThreadObject => "ROOT_THREAD_OBJECT",
                Self::RootInternedString => "ROOT_INTERNED_STRING",
                Self::RootFinalizing => "ROOT_FINALIZING",
                Self::RootDebugger => "ROOT_DEBUGGER",
                Self::RootReferenceCleanup => "ROOT_REFERENCE_CLEANUP",
                Self::RootVmInternal => "ROOT_VM_INTERNAL",
                Self::RootJniMonitor => "ROOT_JNI_MONITOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROOT_UNKNOWN" => Some(Self::RootUnknown),
                "ROOT_JNI_GLOBAL" => Some(Self::RootJniGlobal),
                "ROOT_JNI_LOCAL" => Some(Self::RootJniLocal),
                "ROOT_JAVA_FRAME" => Some(Self::RootJavaFrame),
                "ROOT_NATIVE_STACK" => Some(Self::RootNativeStack),
                "ROOT_STICKY_CLASS" => Some(Self::RootStickyClass),
                "ROOT_THREAD_BLOCK" => Some(Self::RootThreadBlock),
                "ROOT_MONITOR_USED" => Some(Self::RootMonitorUsed),
                "ROOT_THREAD_OBJECT" => Some(Self::RootThreadObject),
                "ROOT_INTERNED_STRING" => Some(Self::RootInternedString),
                "ROOT_FINALIZING" => Some(Self::RootFinalizing),
                "ROOT_DEBUGGER" => Some(Self::RootDebugger),
                "ROOT_REFERENCE_CLEANUP" => Some(Self::RootReferenceCleanup),
                "ROOT_VM_INTERNAL" => Some(Self::RootVmInternal),
                "ROOT_JNI_MONITOR" => Some(Self::RootJniMonitor),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeapGraphType {
    /// TODO(fmayer): Consider removing this and using the index in the repeaed
    /// field to save space.
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub location_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub class_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Size of objects of this type.
    #[prost(uint64, optional, tag = "4")]
    pub object_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub superclass_id: ::core::option::Option<u64>,
    /// Indices for InternedData.field_names for the names of the fields of
    /// instances of this class. This does NOT include the fields from
    /// superclasses. The consumer of this data needs to walk all super
    /// classes to get a full lists of fields. Objects always write the
    /// fields in order of most specific class to the furthest up superclass.
    #[prost(uint64, repeated, tag = "6")]
    pub reference_field_id: ::prost::alloc::vec::Vec<u64>,
    #[prost(enumeration = "heap_graph_type::Kind", optional, tag = "7")]
    pub kind: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "8")]
    pub classloader_id: ::core::option::Option<u64>,
}
/// Nested message and enum types in `HeapGraphType`.
pub mod heap_graph_type {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unknown = 0,
        Normal = 1,
        Noreferences = 2,
        String = 3,
        Array = 4,
        Class = 5,
        Classloader = 6,
        Dexcache = 7,
        SoftReference = 8,
        WeakReference = 9,
        FinalizerReference = 10,
        PhantomReference = 11,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "KIND_UNKNOWN",
                Self::Normal => "KIND_NORMAL",
                Self::Noreferences => "KIND_NOREFERENCES",
                Self::String => "KIND_STRING",
                Self::Array => "KIND_ARRAY",
                Self::Class => "KIND_CLASS",
                Self::Classloader => "KIND_CLASSLOADER",
                Self::Dexcache => "KIND_DEXCACHE",
                Self::SoftReference => "KIND_SOFT_REFERENCE",
                Self::WeakReference => "KIND_WEAK_REFERENCE",
                Self::FinalizerReference => "KIND_FINALIZER_REFERENCE",
                Self::PhantomReference => "KIND_PHANTOM_REFERENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNKNOWN" => Some(Self::Unknown),
                "KIND_NORMAL" => Some(Self::Normal),
                "KIND_NOREFERENCES" => Some(Self::Noreferences),
                "KIND_STRING" => Some(Self::String),
                "KIND_ARRAY" => Some(Self::Array),
                "KIND_CLASS" => Some(Self::Class),
                "KIND_CLASSLOADER" => Some(Self::Classloader),
                "KIND_DEXCACHE" => Some(Self::Dexcache),
                "KIND_SOFT_REFERENCE" => Some(Self::SoftReference),
                "KIND_WEAK_REFERENCE" => Some(Self::WeakReference),
                "KIND_FINALIZER_REFERENCE" => Some(Self::FinalizerReference),
                "KIND_PHANTOM_REFERENCE" => Some(Self::PhantomReference),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeapGraphObject {
    /// Index for InternedData.types for the name of the type of this object.
    #[prost(uint64, optional, tag = "2")]
    pub type_id: ::core::option::Option<u64>,
    /// Bytes occupied by this objects.
    #[prost(uint64, optional, tag = "3")]
    pub self_size: ::core::option::Option<u64>,
    /// Add this to all non-zero values in reference_object_id. This is used to
    /// get more compact varint encoding.
    ///
    /// The name is confusing, but this has always been used as a base for
    /// reference_object_id. The field should be named reference_object_id_base.
    #[prost(uint64, optional, tag = "6")]
    pub reference_field_id_base: ::core::option::Option<u64>,
    /// Indices for InternedData.field_names for the name of the field referring
    /// to the object. For Android S+ and for instances of normal classes (e.g.
    /// not instances of java.lang.Class or arrays), this is instead set in the
    /// corresponding HeapGraphType, and this is left empty.
    #[prost(uint64, repeated, tag = "4")]
    pub reference_field_id: ::prost::alloc::vec::Vec<u64>,
    /// Ids of the Object that is referred to.
    #[prost(uint64, repeated, tag = "5")]
    pub reference_object_id: ::prost::alloc::vec::Vec<u64>,
    /// If this object is an instance of `libcore.util.NativeAllocationRegistry`,
    /// the value of the `size` field.
    ///
    /// N.B. This is not the native size of this object.
    #[prost(int64, optional, tag = "8")]
    pub native_allocation_registry_size_field: ::core::option::Option<i64>,
    #[prost(oneof = "heap_graph_object::Identifier", tags = "1, 7")]
    pub identifier: ::core::option::Option<heap_graph_object::Identifier>,
}
/// Nested message and enum types in `HeapGraphObject`.
pub mod heap_graph_object {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(uint64, tag = "1")]
        Id(u64),
        #[prost(uint64, tag = "7")]
        IdDelta(u64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeapGraph {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    /// This contains all objects at the time this dump was taken. Some of these
    /// will be live, some of those unreachable (garbage). To find the live
    /// objects, the client needs to build the transitive closure of objects
    /// reachable from |roots|.
    /// All objects not contained within that transitive closure are garbage that
    /// has not yet been collected.
    #[prost(message, repeated, tag = "2")]
    pub objects: ::prost::alloc::vec::Vec<HeapGraphObject>,
    /// Roots at the time this dump was taken.
    /// All live objects are reachable from the roots. All other objects are
    /// garbage.
    #[prost(message, repeated, tag = "7")]
    pub roots: ::prost::alloc::vec::Vec<HeapGraphRoot>,
    /// Types used in HeapGraphObjects.
    #[prost(message, repeated, tag = "9")]
    pub types: ::prost::alloc::vec::Vec<HeapGraphType>,
    /// Field names for references in managed heap graph.
    #[prost(message, repeated, tag = "4")]
    pub field_names: ::prost::alloc::vec::Vec<InternedString>,
    /// Paths of files used in managed heap graph.
    #[prost(message, repeated, tag = "8")]
    pub location_names: ::prost::alloc::vec::Vec<InternedString>,
    #[prost(bool, optional, tag = "5")]
    pub continued: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "6")]
    pub index: ::core::option::Option<u64>,
}
/// The packet emitted by heapprofd for each heap snapshot. A snapshot can
/// involve more than one ProfilePacket if the snapshot is big (when |continued|
/// is true). The cardinality and grouping is as follows:
/// A ProfilePacket contains:
///   - 1+ per-process heap snapshots (ProcessHeapSamples). Normally there is only
///     one heap per process (the main malloc/free heap), but there can be more if
///     the process is using the heapprofd API to profile custom allocators.
///   - Globally interned strings, mappings and frames (to allow de-duplicating
///     frames/mapping in common between different processes).
/// A ProcessHeapSamples contains:
///   - The process and heap identifier.
///   - A number of HeapSample, one for each callsite that had some alloc/frees.
///   - Statistics about heapprofd internals (e.g., sampling/unwinding timings).
/// A HeapSample contains statistics about callsites:
///   - Total number of bytes allocated and freed from that callsite.
///   - Total number of alloc/free calls sampled.
///   - Stats at the local maximum when dump_at_max = true.
/// See <https://perfetto.dev/docs/data-sources/native-heap-profiler> for more.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfilePacket {
    /// The following interning tables are only used in Android version Q.
    /// In newer versions, these tables are in InternedData
    /// (see protos/perfetto/trace/interned_data) and are shared across
    /// multiple ProfilePackets.
    /// For backwards compatibility, consumers need to first look up interned
    /// data in the tables within the ProfilePacket, and then, if they are empty,
    /// look up in the InternedData instead.
    #[prost(message, repeated, tag = "1")]
    pub strings: ::prost::alloc::vec::Vec<InternedString>,
    #[prost(message, repeated, tag = "4")]
    pub mappings: ::prost::alloc::vec::Vec<Mapping>,
    #[prost(message, repeated, tag = "2")]
    pub frames: ::prost::alloc::vec::Vec<Frame>,
    #[prost(message, repeated, tag = "3")]
    pub callstacks: ::prost::alloc::vec::Vec<Callstack>,
    #[prost(message, repeated, tag = "5")]
    pub process_dumps: ::prost::alloc::vec::Vec<profile_packet::ProcessHeapSamples>,
    /// If this is true, the next ProfilePacket in this package_sequence_id is a
    /// continuation of this one.
    /// To get all samples for a process, accummulate its
    /// ProcessHeapSamples.samples until you see continued=false.
    #[prost(bool, optional, tag = "6")]
    pub continued: ::core::option::Option<bool>,
    /// Index of this ProfilePacket on its package_sequence_id. Can be used
    /// to detect dropped data.
    /// Verify these are consecutive.
    #[prost(uint64, optional, tag = "7")]
    pub index: ::core::option::Option<u64>,
}
/// Nested message and enum types in `ProfilePacket`.
pub mod profile_packet {
    /// Next ID: 9
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct HeapSample {
        #[prost(uint64, optional, tag = "1")]
        pub callstack_id: ::core::option::Option<u64>,
        /// bytes allocated at this callstack.
        #[prost(uint64, optional, tag = "2")]
        pub self_allocated: ::core::option::Option<u64>,
        /// bytes allocated at this callstack that have been freed.
        #[prost(uint64, optional, tag = "3")]
        pub self_freed: ::core::option::Option<u64>,
        /// Bytes allocated by this callstack but not freed at the time the malloc
        /// heap usage of this process was maximal. This is only set if dump_at_max
        /// is true in HeapprofdConfig. In that case, self_allocated, self_freed and
        /// self_idle will not be set.
        #[prost(uint64, optional, tag = "8")]
        pub self_max: ::core::option::Option<u64>,
        /// Number of allocations that were sampled at this callstack but not freed
        /// at the time the malloc heap usage of this process was maximal. This is
        /// only set if dump_at_max is true in HeapprofdConfig. In that case,
        /// self_allocated, self_freed and self_idle will not be set.
        #[prost(uint64, optional, tag = "9")]
        pub self_max_count: ::core::option::Option<u64>,
        /// timestamp \[opt\]
        #[prost(uint64, optional, tag = "4")]
        pub timestamp: ::core::option::Option<u64>,
        /// Number of allocations that were sampled at this callstack.
        #[prost(uint64, optional, tag = "5")]
        pub alloc_count: ::core::option::Option<u64>,
        /// Number of allocations that were sampled at this callstack that have been
        /// freed.
        #[prost(uint64, optional, tag = "6")]
        pub free_count: ::core::option::Option<u64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Histogram {
        #[prost(message, repeated, tag = "1")]
        pub buckets: ::prost::alloc::vec::Vec<histogram::Bucket>,
    }
    /// Nested message and enum types in `Histogram`.
    pub mod histogram {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Bucket {
            /// This bucket counts values from the previous bucket's (or -infinity if
            /// this is the first bucket) upper_limit (inclusive) to this upper_limit
            /// (exclusive).
            #[prost(uint64, optional, tag = "1")]
            pub upper_limit: ::core::option::Option<u64>,
            /// This is the highest bucket. This is set instead of the upper_limit. Any
            /// values larger or equal to the previous bucket's upper_limit are counted
            /// in this bucket.
            #[prost(bool, optional, tag = "2")]
            pub max_bucket: ::core::option::Option<bool>,
            /// Number of values that fall into this range.
            #[prost(uint64, optional, tag = "3")]
            pub count: ::core::option::Option<u64>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessStats {
        #[prost(uint64, optional, tag = "1")]
        pub unwinding_errors: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "2")]
        pub heap_samples: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "3")]
        pub map_reparses: ::core::option::Option<u64>,
        #[prost(message, optional, tag = "4")]
        pub unwinding_time_us: ::core::option::Option<Histogram>,
        #[prost(uint64, optional, tag = "5")]
        pub total_unwinding_time_us: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "6")]
        pub client_spinlock_blocked_us: ::core::option::Option<u64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessHeapSamples {
        #[prost(uint64, optional, tag = "1")]
        pub pid: ::core::option::Option<u64>,
        /// This process was profiled from startup.
        /// If false, this process was already running when profiling started.
        #[prost(bool, optional, tag = "3")]
        pub from_startup: ::core::option::Option<bool>,
        /// This process was not profiled because a concurrent session was active.
        /// If this is true, samples will be empty.
        #[prost(bool, optional, tag = "4")]
        pub rejected_concurrent: ::core::option::Option<bool>,
        /// This process disconnected while it was profiled.
        /// If false, the process outlived the profiling session.
        #[prost(bool, optional, tag = "6")]
        pub disconnected: ::core::option::Option<bool>,
        /// If disconnected, this disconnect was caused by the client overrunning
        /// the buffer.
        /// Equivalent to client_error == CLIENT_ERROR_HIT_TIMEOUT
        /// on new S builds.
        #[prost(bool, optional, tag = "7")]
        pub buffer_overran: ::core::option::Option<bool>,
        #[prost(enumeration = "process_heap_samples::ClientError", optional, tag = "14")]
        pub client_error: ::core::option::Option<i32>,
        /// If disconnected, this disconnected was caused by the shared memory
        /// buffer being corrupted. THIS IS ALWAYS A BUG IN HEAPPROFD OR CLIENT
        /// MEMORY CORRUPTION.
        #[prost(bool, optional, tag = "8")]
        pub buffer_corrupted: ::core::option::Option<bool>,
        /// If disconnected, this disconnect was caused by heapprofd exceeding
        /// guardrails during this profiling session.
        #[prost(bool, optional, tag = "10")]
        pub hit_guardrail: ::core::option::Option<bool>,
        #[prost(string, optional, tag = "11")]
        pub heap_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag = "12")]
        pub sampling_interval_bytes: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "13")]
        pub orig_sampling_interval_bytes: ::core::option::Option<u64>,
        /// Timestamp of the state of the target process that this dump represents.
        /// This can be different to the timestamp of the TracePackets for various
        /// reasons:
        /// * If disconnected is set above, this is the timestamp of last state
        ///    heapprofd had of the process before it disconnected.
        /// * Otherwise, if the rate of events produced by the process is high,
        ///    heapprofd might be behind.
        ///
        /// TODO(fmayer): This is MONOTONIC_COARSE. Refactor ClockSnapshot::Clock
        ///                to have a type enum that we can reuse here.
        #[prost(uint64, optional, tag = "9")]
        pub timestamp: ::core::option::Option<u64>,
        /// Metadata about heapprofd.
        #[prost(message, optional, tag = "5")]
        pub stats: ::core::option::Option<ProcessStats>,
        #[prost(message, repeated, tag = "2")]
        pub samples: ::prost::alloc::vec::Vec<HeapSample>,
    }
    /// Nested message and enum types in `ProcessHeapSamples`.
    pub mod process_heap_samples {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ClientError {
            None = 0,
            HitTimeout = 1,
            InvalidStackBounds = 2,
        }
        impl ClientError {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "CLIENT_ERROR_NONE",
                    Self::HitTimeout => "CLIENT_ERROR_HIT_TIMEOUT",
                    Self::InvalidStackBounds => "CLIENT_ERROR_INVALID_STACK_BOUNDS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CLIENT_ERROR_NONE" => Some(Self::None),
                    "CLIENT_ERROR_HIT_TIMEOUT" => Some(Self::HitTimeout),
                    "CLIENT_ERROR_INVALID_STACK_BOUNDS" => Some(Self::InvalidStackBounds),
                    _ => None,
                }
            }
        }
    }
}
/// Packet emitted by heapprofd when stream_allocations = true. Only for local
/// testing. Doesn't report the callsite.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingAllocation {
    /// TODO(fmayer): Add callstack.
    #[prost(uint64, repeated, packed = "false", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub size: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub sample_size: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed = "false", tag = "4")]
    pub clock_monotonic_coarse_timestamp: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "5")]
    pub heap_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, repeated, packed = "false", tag = "6")]
    pub sequence_number: ::prost::alloc::vec::Vec<u64>,
}
/// Packet emitted by heapprofd when stream_allocations = true. Only for local
/// testing. Doesn't report the callsite.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingFree {
    /// TODO(fmayer): Add callstack.
    #[prost(uint64, repeated, packed = "false", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub heap_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub sequence_number: ::prost::alloc::vec::Vec<u64>,
}
/// Packet emitted by the chromium in-process signal-based callstack sampler.
/// Represents a series of individual stack samples (sampled at discrete points
/// in time), rather than aggregated over an interval.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingProfilePacket {
    /// Index into InternedData.callstacks
    #[prost(uint64, repeated, packed = "false", tag = "1")]
    pub callstack_iid: ::prost::alloc::vec::Vec<u64>,
    /// TODO(eseckler): ThreadDescriptor-based timestamps are deprecated. Replace
    /// this with ClockSnapshot-based delta encoding instead.
    #[prost(int64, repeated, packed = "false", tag = "2")]
    pub timestamp_delta_us: ::prost::alloc::vec::Vec<i64>,
    #[prost(int32, optional, tag = "3")]
    pub process_priority: ::core::option::Option<i32>,
}
/// Namespace for the contained enums.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Profiling {}
/// Nested message and enum types in `Profiling`.
pub mod profiling {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CpuMode {
        ModeUnknown = 0,
        ModeKernel = 1,
        ModeUser = 2,
        /// The following values aren't expected, but included for completeness:
        ModeHypervisor = 3,
        ModeGuestKernel = 4,
        ModeGuestUser = 5,
    }
    impl CpuMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ModeUnknown => "MODE_UNKNOWN",
                Self::ModeKernel => "MODE_KERNEL",
                Self::ModeUser => "MODE_USER",
                Self::ModeHypervisor => "MODE_HYPERVISOR",
                Self::ModeGuestKernel => "MODE_GUEST_KERNEL",
                Self::ModeGuestUser => "MODE_GUEST_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNKNOWN" => Some(Self::ModeUnknown),
                "MODE_KERNEL" => Some(Self::ModeKernel),
                "MODE_USER" => Some(Self::ModeUser),
                "MODE_HYPERVISOR" => Some(Self::ModeHypervisor),
                "MODE_GUEST_KERNEL" => Some(Self::ModeGuestKernel),
                "MODE_GUEST_USER" => Some(Self::ModeGuestUser),
                _ => None,
            }
        }
    }
    /// Enumeration of libunwindstack's error codes.
    /// NB: the integral representations of the two enums are different.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackUnwindError {
        UnwindErrorUnknown = 0,
        UnwindErrorNone = 1,
        UnwindErrorMemoryInvalid = 2,
        UnwindErrorUnwindInfo = 3,
        UnwindErrorUnsupported = 4,
        UnwindErrorInvalidMap = 5,
        UnwindErrorMaxFramesExceeded = 6,
        UnwindErrorRepeatedFrame = 7,
        UnwindErrorInvalidElf = 8,
        UnwindErrorSystemCall = 9,
        UnwindErrorThreadTimeout = 10,
        UnwindErrorThreadDoesNotExist = 11,
        UnwindErrorBadArch = 12,
        UnwindErrorMapsParse = 13,
        UnwindErrorInvalidParameter = 14,
        UnwindErrorPtraceCall = 15,
    }
    impl StackUnwindError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnwindErrorUnknown => "UNWIND_ERROR_UNKNOWN",
                Self::UnwindErrorNone => "UNWIND_ERROR_NONE",
                Self::UnwindErrorMemoryInvalid => "UNWIND_ERROR_MEMORY_INVALID",
                Self::UnwindErrorUnwindInfo => "UNWIND_ERROR_UNWIND_INFO",
                Self::UnwindErrorUnsupported => "UNWIND_ERROR_UNSUPPORTED",
                Self::UnwindErrorInvalidMap => "UNWIND_ERROR_INVALID_MAP",
                Self::UnwindErrorMaxFramesExceeded => "UNWIND_ERROR_MAX_FRAMES_EXCEEDED",
                Self::UnwindErrorRepeatedFrame => "UNWIND_ERROR_REPEATED_FRAME",
                Self::UnwindErrorInvalidElf => "UNWIND_ERROR_INVALID_ELF",
                Self::UnwindErrorSystemCall => "UNWIND_ERROR_SYSTEM_CALL",
                Self::UnwindErrorThreadTimeout => "UNWIND_ERROR_THREAD_TIMEOUT",
                Self::UnwindErrorThreadDoesNotExist => {
                    "UNWIND_ERROR_THREAD_DOES_NOT_EXIST"
                }
                Self::UnwindErrorBadArch => "UNWIND_ERROR_BAD_ARCH",
                Self::UnwindErrorMapsParse => "UNWIND_ERROR_MAPS_PARSE",
                Self::UnwindErrorInvalidParameter => "UNWIND_ERROR_INVALID_PARAMETER",
                Self::UnwindErrorPtraceCall => "UNWIND_ERROR_PTRACE_CALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNWIND_ERROR_UNKNOWN" => Some(Self::UnwindErrorUnknown),
                "UNWIND_ERROR_NONE" => Some(Self::UnwindErrorNone),
                "UNWIND_ERROR_MEMORY_INVALID" => Some(Self::UnwindErrorMemoryInvalid),
                "UNWIND_ERROR_UNWIND_INFO" => Some(Self::UnwindErrorUnwindInfo),
                "UNWIND_ERROR_UNSUPPORTED" => Some(Self::UnwindErrorUnsupported),
                "UNWIND_ERROR_INVALID_MAP" => Some(Self::UnwindErrorInvalidMap),
                "UNWIND_ERROR_MAX_FRAMES_EXCEEDED" => {
                    Some(Self::UnwindErrorMaxFramesExceeded)
                }
                "UNWIND_ERROR_REPEATED_FRAME" => Some(Self::UnwindErrorRepeatedFrame),
                "UNWIND_ERROR_INVALID_ELF" => Some(Self::UnwindErrorInvalidElf),
                "UNWIND_ERROR_SYSTEM_CALL" => Some(Self::UnwindErrorSystemCall),
                "UNWIND_ERROR_THREAD_TIMEOUT" => Some(Self::UnwindErrorThreadTimeout),
                "UNWIND_ERROR_THREAD_DOES_NOT_EXIST" => {
                    Some(Self::UnwindErrorThreadDoesNotExist)
                }
                "UNWIND_ERROR_BAD_ARCH" => Some(Self::UnwindErrorBadArch),
                "UNWIND_ERROR_MAPS_PARSE" => Some(Self::UnwindErrorMapsParse),
                "UNWIND_ERROR_INVALID_PARAMETER" => {
                    Some(Self::UnwindErrorInvalidParameter)
                }
                "UNWIND_ERROR_PTRACE_CALL" => Some(Self::UnwindErrorPtraceCall),
                _ => None,
            }
        }
    }
}
/// Packet emitted by the traced_perf sampling performance profiler, which
/// gathers data via the perf_event_open syscall. Each packet contains an
/// individual sample with a counter value, and optionally a
/// callstack.
///
/// Timestamps are within the root packet. The config can specify the clock, or
/// the implementation will default to CLOCK_MONOTONIC_RAW. Within the Android R
/// timeframe, the default was CLOCK_BOOTTIME.
///
/// There are several distinct views of this message:
/// * indication of kernel buffer data loss (kernel_records_lost set)
/// * indication of skipped samples (sample_skipped_reason set)
/// * notable event in the sampling implementation (producer_event set)
/// * normal sample (timebase_count set, typically also callstack_iid)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerfSample {
    #[prost(uint32, optional, tag = "1")]
    pub cpu: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub tid: ::core::option::Option<u32>,
    /// Execution state that the process was sampled at.
    #[prost(enumeration = "profiling::CpuMode", optional, tag = "5")]
    pub cpu_mode: ::core::option::Option<i32>,
    /// Value of the timebase counter (since the event was configured, no deltas).
    #[prost(uint64, optional, tag = "6")]
    pub timebase_count: ::core::option::Option<u64>,
    /// Unwound callstack. Might be partial, in which case a synthetic "error"
    /// frame is appended, and |unwind_error| is set accordingly.
    #[prost(uint64, optional, tag = "4")]
    pub callstack_iid: ::core::option::Option<u64>,
    /// If set, indicates that this message is not a sample, but rather an
    /// indication of data loss in the ring buffer allocated for |cpu|. Such data
    /// loss occurs when the kernel has insufficient ring buffer capacity to write
    /// a record (which gets discarded). A record in this context is an individual
    /// ring buffer entry, and counts more than just sample records.
    ///
    /// The |timestamp| of the packet corresponds to the time that the producer
    /// wrote the packet for trace-sorting purposes alone, and should not be
    /// interpreted relative to the sample timestamps. This field is sufficient to
    /// detect that *some* kernel data loss happened within the trace, but not the
    /// specific time bounds of that loss (which would require tracking precedessor
    /// & successor timestamps, which is not deemed necessary at the moment).
    #[prost(uint64, optional, tag = "17")]
    pub kernel_records_lost: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "19")]
    pub producer_event: ::core::option::Option<perf_sample::ProducerEvent>,
    /// If set, stack unwinding was incomplete due to an error.
    /// Unset values should be treated as UNWIND_ERROR_NONE.
    #[prost(oneof = "perf_sample::OptionalUnwindError", tags = "16")]
    pub optional_unwind_error: ::core::option::Option<perf_sample::OptionalUnwindError>,
    #[prost(oneof = "perf_sample::OptionalSampleSkippedReason", tags = "18")]
    pub optional_sample_skipped_reason: ::core::option::Option<
        perf_sample::OptionalSampleSkippedReason,
    >,
}
/// Nested message and enum types in `PerfSample`.
pub mod perf_sample {
    /// A notable event within the sampling implementation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ProducerEvent {
        #[prost(oneof = "producer_event::OptionalSourceStopReason", tags = "1")]
        pub optional_source_stop_reason: ::core::option::Option<
            producer_event::OptionalSourceStopReason,
        >,
    }
    /// Nested message and enum types in `ProducerEvent`.
    pub mod producer_event {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DataSourceStopReason {
            ProfilerStopUnknown = 0,
            ProfilerStopGuardrail = 1,
        }
        impl DataSourceStopReason {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ProfilerStopUnknown => "PROFILER_STOP_UNKNOWN",
                    Self::ProfilerStopGuardrail => "PROFILER_STOP_GUARDRAIL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PROFILER_STOP_UNKNOWN" => Some(Self::ProfilerStopUnknown),
                    "PROFILER_STOP_GUARDRAIL" => Some(Self::ProfilerStopGuardrail),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum OptionalSourceStopReason {
            #[prost(enumeration = "DataSourceStopReason", tag = "1")]
            SourceStopReason(i32),
        }
    }
    /// If set, indicates that the profiler encountered a sample that was relevant,
    /// but was skipped.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SampleSkipReason {
        ProfilerSkipUnknown = 0,
        ProfilerSkipReadStage = 1,
        ProfilerSkipUnwindStage = 2,
        ProfilerSkipUnwindEnqueue = 3,
    }
    impl SampleSkipReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ProfilerSkipUnknown => "PROFILER_SKIP_UNKNOWN",
                Self::ProfilerSkipReadStage => "PROFILER_SKIP_READ_STAGE",
                Self::ProfilerSkipUnwindStage => "PROFILER_SKIP_UNWIND_STAGE",
                Self::ProfilerSkipUnwindEnqueue => "PROFILER_SKIP_UNWIND_ENQUEUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROFILER_SKIP_UNKNOWN" => Some(Self::ProfilerSkipUnknown),
                "PROFILER_SKIP_READ_STAGE" => Some(Self::ProfilerSkipReadStage),
                "PROFILER_SKIP_UNWIND_STAGE" => Some(Self::ProfilerSkipUnwindStage),
                "PROFILER_SKIP_UNWIND_ENQUEUE" => Some(Self::ProfilerSkipUnwindEnqueue),
                _ => None,
            }
        }
    }
    /// If set, stack unwinding was incomplete due to an error.
    /// Unset values should be treated as UNWIND_ERROR_NONE.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OptionalUnwindError {
        #[prost(enumeration = "super::profiling::StackUnwindError", tag = "16")]
        UnwindError(i32),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OptionalSampleSkippedReason {
        #[prost(enumeration = "SampleSkipReason", tag = "18")]
        SampleSkippedReason(i32),
    }
}
/// Submessage for TracePacketDefaults.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerfSampleDefaults {
    /// The sampling timebase. Might not be identical to the data source config if
    /// the implementation decided to default/override some parameters.
    #[prost(message, optional, tag = "1")]
    pub timebase: ::core::option::Option<perf_events::Timebase>,
    /// If the config requested process sharding, report back the count and which
    /// of those bins was selected. Never changes for the duration of a trace.
    #[prost(uint32, optional, tag = "2")]
    pub process_shard_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub chosen_process_shard: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmapsEntry {
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub size_kb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub private_dirty_kb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub swap_kb: ::core::option::Option<u64>,
    /// for field upload (instead of path).
    #[prost(string, optional, tag = "5")]
    pub file_name: ::core::option::Option<::prost::alloc::string::String>,
    /// TODO(crbug.com/1098746): Consider encoding this as incremental values.
    #[prost(uint64, optional, tag = "6")]
    pub start_address: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub module_timestamp: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "8")]
    pub module_debugid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub module_debug_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "10")]
    pub protection_flags: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "11")]
    pub private_clean_resident_kb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub shared_dirty_resident_kb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "13")]
    pub shared_clean_resident_kb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "14")]
    pub locked_kb: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "15")]
    pub proportional_resident_kb: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmapsPacket {
    #[prost(uint32, optional, tag = "1")]
    pub pid: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<SmapsEntry>,
}
/// Per-process periodically sampled stats. These samples are wrapped in a
/// dedicated message (as opposite to be fields in process_tree.proto) because
/// they are dumped at a different rate than cmdline and thread list.
/// Note: not all of these stats will be present in every ProcessStats message
/// and sometimes processes may be missing. This is because counters are
/// cached to reduce emission of counters which do not change.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessStats {
    #[prost(message, repeated, tag = "1")]
    pub processes: ::prost::alloc::vec::Vec<process_stats::Process>,
    /// The time at which we finish collecting this batch of samples;
    /// the top-level packet timestamp is the time at which
    /// we begin collection.
    #[prost(uint64, optional, tag = "2")]
    pub collection_end_timestamp: ::core::option::Option<u64>,
}
/// Nested message and enum types in `ProcessStats`.
pub mod process_stats {
    /// Per-thread periodically sampled stats.
    /// Note: not all of these stats will be present in every message. See the note
    /// for ProcessStats.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Thread {
        #[prost(int32, optional, tag = "1")]
        pub tid: ::core::option::Option<i32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FdInfo {
        #[prost(uint64, optional, tag = "1")]
        pub fd: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub path: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Process {
        #[prost(int32, optional, tag = "1")]
        pub pid: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "11")]
        pub threads: ::prost::alloc::vec::Vec<Thread>,
        /// See /proc/\[pid\]/status in `man 5 proc` for a description of these fields.
        #[prost(uint64, optional, tag = "2")]
        pub vm_size_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "3")]
        pub vm_rss_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "4")]
        pub rss_anon_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "5")]
        pub rss_file_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "6")]
        pub rss_shmem_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "7")]
        pub vm_swap_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "8")]
        pub vm_locked_kb: ::core::option::Option<u64>,
        /// When adding a new field remember to update kProcMemCounterSize in
        /// the trace processor.
        #[prost(uint64, optional, tag = "9")]
        pub vm_hwm_kb: ::core::option::Option<u64>,
        #[prost(int64, optional, tag = "10")]
        pub oom_score_adj: ::core::option::Option<i64>,
        /// The peak resident set size is resettable in newer Posix kernels.
        /// This field specifies if reset is supported and if the writer had reset
        /// the peaks after each process stats recording.
        #[prost(bool, optional, tag = "12")]
        pub is_peak_rss_resettable: ::core::option::Option<bool>,
        /// Private, shared and swap footprint of the process as measured by
        /// Chrome. To know more about these metrics refer to:
        /// <https://docs.google.com/document/d/1_WmgE1F5WUrhwkPqJis3dWyOiUmQKvpXp5cd4w86TvA>
        #[prost(uint32, optional, tag = "13")]
        pub chrome_private_footprint_kb: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "14")]
        pub chrome_peak_resident_set_kb: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "15")]
        pub fds: ::prost::alloc::vec::Vec<FdInfo>,
        /// These fields are set only when scan_smaps_rollup=true
        #[prost(uint64, optional, tag = "16")]
        pub smr_rss_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "17")]
        pub smr_pss_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "18")]
        pub smr_pss_anon_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "19")]
        pub smr_pss_file_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "20")]
        pub smr_pss_shmem_kb: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "23")]
        pub smr_swap_pss_kb: ::core::option::Option<u64>,
        /// Time spent scheduled in user mode in nanoseconds. Parsed from utime in
        /// /proc/pid/stat. Recorded if record_process_runtime config option is set.
        /// Resolution of "clock ticks", usually 10ms.
        #[prost(uint64, optional, tag = "21")]
        pub runtime_user_mode: ::core::option::Option<u64>,
        /// Time spent scheduled in kernel mode in nanoseconds. Parsed from stime in
        /// /proc/pid/stat. Recorded if record_process_runtime config option is set.
        /// Resolution of "clock ticks", usually 10ms.
        #[prost(uint64, optional, tag = "22")]
        pub runtime_kernel_mode: ::core::option::Option<u64>,
    }
}
/// Metadata about the processes and threads in the trace.
/// Note: this proto was designed to be filled in by traced_probes and should
/// only be populated with accurate information coming from the system. Other
/// trace writers should prefer to fill ThreadDescriptor and ProcessDescriptor
/// in TrackDescriptor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessTree {
    /// List of processes and threads in the client. These lists are incremental
    /// and not exhaustive. A process and its threads might show up separately in
    /// different ProcessTree messages. A thread might event not show up at all, if
    /// no sched_switch activity was detected, for instance:
    /// #0 { processes: \[{pid: 10, ...}\], threads: \[{pid: 11, tgid: 10}\] }
    /// #1 { threads: \[{pid: 12, tgid: 10}\] }
    /// #2 { processes: \[{pid: 20, ...}\], threads: \[{pid: 13, tgid: 10}\] }
    #[prost(message, repeated, tag = "1")]
    pub processes: ::prost::alloc::vec::Vec<process_tree::Process>,
    #[prost(message, repeated, tag = "2")]
    pub threads: ::prost::alloc::vec::Vec<process_tree::Thread>,
    /// The time at which we finish collecting this process tree;
    /// the top-level packet timestamp is the time at which
    /// we begin collection.
    #[prost(uint64, optional, tag = "3")]
    pub collection_end_timestamp: ::core::option::Option<u64>,
}
/// Nested message and enum types in `ProcessTree`.
pub mod process_tree {
    /// Representation of a thread.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Thread {
        /// The thread ID (as per gettid()) in the root PID namespace.
        #[prost(int32, optional, tag = "1")]
        pub tid: ::core::option::Option<i32>,
        /// Thread group id (i.e. the PID of the process, == TID of the main thread)
        #[prost(int32, optional, tag = "3")]
        pub tgid: ::core::option::Option<i32>,
        /// The name of the thread.
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// The non-root-level thread IDs if the thread runs in a PID namespace. Read
        /// from the NSpid entry of /proc/<tid>/status, with the first element (root-
        /// level thread ID) omitted.
        #[prost(int32, repeated, packed = "false", tag = "4")]
        pub nstid: ::prost::alloc::vec::Vec<i32>,
    }
    /// Representation of a process.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Process {
        /// The UNIX process ID, aka thread group ID (as per getpid()) in the root
        /// PID namespace.
        #[prost(int32, optional, tag = "1")]
        pub pid: ::core::option::Option<i32>,
        /// The parent process ID, as per getppid().
        #[prost(int32, optional, tag = "2")]
        pub ppid: ::core::option::Option<i32>,
        /// The command line for the process, as per /proc/pid/cmdline.
        /// If it is a kernel thread there will only be one cmdline field
        /// and it will contain /proc/pid/comm.
        #[prost(string, repeated, tag = "3")]
        pub cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The uid for the process, as per /proc/pid/status.
        #[prost(int32, optional, tag = "5")]
        pub uid: ::core::option::Option<i32>,
        /// The non-root-level process IDs if the process runs in a PID namespace.
        /// Read from the NSpid entry of /proc/<pid>/status, with the first element
        /// (root-level process ID) omitted.
        #[prost(int32, repeated, packed = "false", tag = "6")]
        pub nspid: ::prost::alloc::vec::Vec<i32>,
        /// Timestamp of when the process was created, in nanoseconds
        /// from boot. Parsed from starttime in /proc/pid/stat.
        /// Recorded if record_process_age config option is set.
        /// Resolution of "clock ticks", usually 10ms.
        #[prost(uint64, optional, tag = "7")]
        pub process_start_from_boot: ::core::option::Option<u64>,
    }
}
/// Records the parameters for aligning clock readings between machines.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteClockSync {
    #[prost(message, repeated, tag = "1")]
    pub synced_clocks: ::prost::alloc::vec::Vec<remote_clock_sync::SyncedClocks>,
}
/// Nested message and enum types in `RemoteClockSync`.
pub mod remote_clock_sync {
    /// Synchronized clock snapshots taken on both sides of the relay port (the
    /// tracing service and the relay service). A round of clock synchronization
    /// IPC takes emits 2 SyncedClocks messages, i.e., client snapshot -> host
    /// snapshot -> client snapshot -> host snapshot.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SyncedClocks {
        #[prost(message, optional, tag = "2")]
        pub client_clocks: ::core::option::Option<super::ClockSnapshot>,
        #[prost(message, optional, tag = "3")]
        pub host_clocks: ::core::option::Option<super::ClockSnapshot>,
    }
}
/// Various Linux system stat counters from /proc.
/// The fields in this message can be reported at different rates and with
/// different granularity. See sys_stats_config.proto.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SysStats {
    #[prost(message, repeated, tag = "1")]
    pub meminfo: ::prost::alloc::vec::Vec<sys_stats::MeminfoValue>,
    #[prost(message, repeated, tag = "2")]
    pub vmstat: ::prost::alloc::vec::Vec<sys_stats::VmstatValue>,
    /// One entry per cpu.
    #[prost(message, repeated, tag = "3")]
    pub cpu_stat: ::prost::alloc::vec::Vec<sys_stats::CpuTimes>,
    /// Num processes forked since boot.
    /// Populated only if FORK_COUNT in config.stat_counters.
    #[prost(uint64, optional, tag = "4")]
    pub num_forks: ::core::option::Option<u64>,
    /// Total num of irqs serviced since boot.
    #[prost(uint64, optional, tag = "5")]
    pub num_irq_total: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "6")]
    pub num_irq: ::prost::alloc::vec::Vec<sys_stats::InterruptCount>,
    /// Total num of softirqs since boot.
    #[prost(uint64, optional, tag = "7")]
    pub num_softirq_total: ::core::option::Option<u64>,
    /// Per-softirq count.
    #[prost(message, repeated, tag = "8")]
    pub num_softirq: ::prost::alloc::vec::Vec<sys_stats::InterruptCount>,
    /// The time at which we finish collecting this set of samples;
    /// the top-level packet timestamp is the time at which
    /// we begin collection.
    #[prost(uint64, optional, tag = "9")]
    pub collection_end_timestamp: ::core::option::Option<u64>,
    /// One entry per device.
    #[prost(message, repeated, tag = "10")]
    pub devfreq: ::prost::alloc::vec::Vec<sys_stats::DevfreqValue>,
    /// Cpu current frequency from
    /// /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq in kHz.
    /// One entry per cpu. Report 0 for offline cpu
    #[prost(uint32, repeated, packed = "false", tag = "11")]
    pub cpufreq_khz: ::prost::alloc::vec::Vec<u32>,
    /// One entry per each node's zones.
    #[prost(message, repeated, tag = "12")]
    pub buddy_info: ::prost::alloc::vec::Vec<sys_stats::BuddyInfo>,
    /// One entry per disk device.
    #[prost(message, repeated, tag = "13")]
    pub disk_stat: ::prost::alloc::vec::Vec<sys_stats::DiskStat>,
    /// One entry per PsiResource type.
    #[prost(message, repeated, tag = "14")]
    pub psi: ::prost::alloc::vec::Vec<sys_stats::PsiSample>,
}
/// Nested message and enum types in `SysStats`.
pub mod sys_stats {
    /// Counters from /proc/meminfo. Values are in KB.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MeminfoValue {
        #[prost(enumeration = "super::MeminfoCounters", optional, tag = "1")]
        pub key: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "2")]
        pub value: ::core::option::Option<u64>,
    }
    /// Counter from /proc/vmstat. Units are often pages, not KB.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct VmstatValue {
        #[prost(enumeration = "super::VmstatCounters", optional, tag = "1")]
        pub key: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "2")]
        pub value: ::core::option::Option<u64>,
    }
    /// Times in each mode, since boot. Unit: nanoseconds.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CpuTimes {
        #[prost(uint32, optional, tag = "1")]
        pub cpu_id: ::core::option::Option<u32>,
        /// Time spent in user mode.
        #[prost(uint64, optional, tag = "2")]
        pub user_ns: ::core::option::Option<u64>,
        /// Time spent in user mode (low prio).
        #[prost(uint64, optional, tag = "3")]
        pub user_nice_ns: ::core::option::Option<u64>,
        /// Time spent in system mode.
        #[prost(uint64, optional, tag = "4")]
        pub system_mode_ns: ::core::option::Option<u64>,
        /// Time spent in the idle task.
        #[prost(uint64, optional, tag = "5")]
        pub idle_ns: ::core::option::Option<u64>,
        /// Time spent waiting for I/O.
        #[prost(uint64, optional, tag = "6")]
        pub io_wait_ns: ::core::option::Option<u64>,
        /// Time spent servicing interrupts.
        #[prost(uint64, optional, tag = "7")]
        pub irq_ns: ::core::option::Option<u64>,
        /// Time spent servicing softirqs.
        #[prost(uint64, optional, tag = "8")]
        pub softirq_ns: ::core::option::Option<u64>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InterruptCount {
        #[prost(int32, optional, tag = "1")]
        pub irq: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "2")]
        pub count: ::core::option::Option<u64>,
    }
    /// Frequencies for /sys/class/devfreq/ entries in kHz.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DevfreqValue {
        #[prost(string, optional, tag = "1")]
        pub key: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag = "2")]
        pub value: ::core::option::Option<u64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BuddyInfo {
        #[prost(string, optional, tag = "1")]
        pub node: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub zone: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, repeated, packed = "false", tag = "3")]
        pub order_pages: ::prost::alloc::vec::Vec<u32>,
    }
    /// Counters from /proc/diskstats.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiskStat {
        #[prost(string, optional, tag = "1")]
        pub device_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint64, optional, tag = "2")]
        pub read_sectors: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "3")]
        pub read_time_ms: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "4")]
        pub write_sectors: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "5")]
        pub write_time_ms: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "6")]
        pub discard_sectors: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "7")]
        pub discard_time_ms: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "8")]
        pub flush_count: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "9")]
        pub flush_time_ms: ::core::option::Option<u64>,
    }
    /// Reading from /proc/pressure/*.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PsiSample {
        #[prost(enumeration = "psi_sample::PsiResource", optional, tag = "1")]
        pub resource: ::core::option::Option<i32>,
        /// Total absolute stall time (in nanos) for a given resource.
        /// While PSI readings are in micros, we store in nanos for consistency with
        /// most other time-based counters.
        #[prost(uint64, optional, tag = "2")]
        pub total_ns: ::core::option::Option<u64>,
    }
    /// Nested message and enum types in `PsiSample`.
    pub mod psi_sample {
        /// Type of resource that may have exhibited pressure stalls.
        ///     * _SOME indicates some resource tasks stalled.
        ///     * _FULL indicates all non-idle resource tasks stalled simultaneously.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PsiResource {
            Unspecified = 0,
            CpuSome = 1,
            CpuFull = 2,
            IoSome = 3,
            IoFull = 4,
            MemorySome = 5,
            MemoryFull = 6,
        }
        impl PsiResource {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PSI_RESOURCE_UNSPECIFIED",
                    Self::CpuSome => "PSI_RESOURCE_CPU_SOME",
                    Self::CpuFull => "PSI_RESOURCE_CPU_FULL",
                    Self::IoSome => "PSI_RESOURCE_IO_SOME",
                    Self::IoFull => "PSI_RESOURCE_IO_FULL",
                    Self::MemorySome => "PSI_RESOURCE_MEMORY_SOME",
                    Self::MemoryFull => "PSI_RESOURCE_MEMORY_FULL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PSI_RESOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PSI_RESOURCE_CPU_SOME" => Some(Self::CpuSome),
                    "PSI_RESOURCE_CPU_FULL" => Some(Self::CpuFull),
                    "PSI_RESOURCE_IO_SOME" => Some(Self::IoSome),
                    "PSI_RESOURCE_IO_FULL" => Some(Self::IoFull),
                    "PSI_RESOURCE_MEMORY_SOME" => Some(Self::MemorySome),
                    "PSI_RESOURCE_MEMORY_FULL" => Some(Self::MemoryFull),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Utsname {
    #[prost(string, optional, tag = "1")]
    pub sysname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub release: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub machine: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemInfo {
    #[prost(message, optional, tag = "1")]
    pub utsname: ::core::option::Option<Utsname>,
    #[prost(string, optional, tag = "2")]
    pub android_build_fingerprint: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// The SoC model from which trace is collected
    #[prost(string, optional, tag = "9")]
    pub android_soc_model: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of traced (the same returned by `traced --version`).
    /// This is a human readable string with and its format varies depending on
    /// the build system and the repo (standalone vs AOSP).
    /// This is intended for human debugging only.
    #[prost(string, optional, tag = "4")]
    pub tracing_service_version: ::core::option::Option<::prost::alloc::string::String>,
    /// The Android SDK vesion (e.g. 21 for L, 31 for S etc).
    /// Introduced in Android T.
    #[prost(uint64, optional, tag = "5")]
    pub android_sdk_version: ::core::option::Option<u64>,
    /// Kernel page size - sysconf(_SC_PAGESIZE).
    #[prost(uint32, optional, tag = "6")]
    pub page_size: ::core::option::Option<u32>,
    /// Number of cpus - sysconf(_SC_NPROCESSORS_CONF).
    /// Might be different to the number of online cpus.
    /// Introduced in perfetto v44.
    #[prost(uint32, optional, tag = "8")]
    pub num_cpus: ::core::option::Option<u32>,
    /// The timezone offset from UTC, as per strftime("%z"), in minutes.
    /// Introduced in v38 / Android V.
    #[prost(int32, optional, tag = "7")]
    pub timezone_off_mins: ::core::option::Option<i32>,
    /// Ticks per second - sysconf(_SC_CLK_TCK).
    /// Not serialised as of perfetto v44.
    #[prost(int64, optional, tag = "3")]
    pub hz: ::core::option::Option<i64>,
}
/// Information about CPUs from procfs and sysfs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuInfo {
    /// Describes available CPUs, one entry per CPU.
    #[prost(message, repeated, tag = "1")]
    pub cpus: ::prost::alloc::vec::Vec<cpu_info::Cpu>,
}
/// Nested message and enum types in `CpuInfo`.
pub mod cpu_info {
    /// Information about a single CPU.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Cpu {
        /// Value of "Processor" field from /proc/cpuinfo for this CPU.
        /// Example: "AArch64 Processor rev 12 (aarch64)"
        #[prost(string, optional, tag = "1")]
        pub processor: ::core::option::Option<::prost::alloc::string::String>,
        /// Frequencies from
        /// /sys/devices/system/cpu/cpuX/cpufreq/scaling_available_frequencies
        /// where X is the index of this CPU.
        #[prost(uint32, repeated, packed = "false", tag = "2")]
        pub frequencies: ::prost::alloc::vec::Vec<u32>,
    }
}
/// Default values for TracePacket fields that hold for a particular TraceWriter
/// packet sequence. This message contains a subset of the TracePacket fields
/// with matching IDs. When provided, these fields define the default values
/// that should be applied, at import time, to all TracePacket(s) with the same
/// |trusted_packet_sequence_id|, unless otherwise specified in each packet.
///
/// Should be reemitted whenever incremental state is cleared on the sequence.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracePacketDefaults {
    #[prost(uint32, optional, tag = "58")]
    pub timestamp_clock_id: ::core::option::Option<u32>,
    /// Default values for TrackEvents (e.g. default track).
    #[prost(message, optional, tag = "11")]
    pub track_event_defaults: ::core::option::Option<TrackEventDefaults>,
    /// Defaults for perf profiler packets (PerfSample).
    #[prost(message, optional, tag = "12")]
    pub perf_sample_defaults: ::core::option::Option<PerfSampleDefaults>,
    /// Defaults for V8 code packets (V8JsCode, V8InternalCode, V8WasmCode,
    /// V8RegexpCode)
    #[prost(message, optional, tag = "99")]
    pub v8_code_defaults: ::core::option::Option<V8CodeDefaults>,
}
/// Describes a process's attributes. Emitted as part of a TrackDescriptor,
/// usually by the process's main thread.
///
/// Next id: 9.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessDescriptor {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub process_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub process_priority: ::core::option::Option<i32>,
    /// Process start time in nanoseconds.
    /// The timestamp refers to the trace clock by default. Other clock IDs
    /// provided in TracePacket are not supported.
    #[prost(int64, optional, tag = "7")]
    pub start_timestamp_ns: ::core::option::Option<i64>,
    #[prost(enumeration = "process_descriptor::ChromeProcessType", optional, tag = "4")]
    pub chrome_process_type: ::core::option::Option<i32>,
    /// To support old UI. New UI should determine default sorting by process_type.
    #[prost(int32, optional, tag = "3")]
    pub legacy_sort_index: ::core::option::Option<i32>,
    /// Labels can be used to further describe properties of the work performed by
    /// the process. For example, these can be used by Chrome renderer process to
    /// provide titles of frames being rendered.
    #[prost(string, repeated, tag = "8")]
    pub process_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ProcessDescriptor`.
pub mod process_descriptor {
    /// See chromium's content::ProcessType.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChromeProcessType {
        ProcessUnspecified = 0,
        ProcessBrowser = 1,
        ProcessRenderer = 2,
        ProcessUtility = 3,
        ProcessZygote = 4,
        ProcessSandboxHelper = 5,
        ProcessGpu = 6,
        ProcessPpapiPlugin = 7,
        ProcessPpapiBroker = 8,
    }
    impl ChromeProcessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ProcessUnspecified => "PROCESS_UNSPECIFIED",
                Self::ProcessBrowser => "PROCESS_BROWSER",
                Self::ProcessRenderer => "PROCESS_RENDERER",
                Self::ProcessUtility => "PROCESS_UTILITY",
                Self::ProcessZygote => "PROCESS_ZYGOTE",
                Self::ProcessSandboxHelper => "PROCESS_SANDBOX_HELPER",
                Self::ProcessGpu => "PROCESS_GPU",
                Self::ProcessPpapiPlugin => "PROCESS_PPAPI_PLUGIN",
                Self::ProcessPpapiBroker => "PROCESS_PPAPI_BROKER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESS_UNSPECIFIED" => Some(Self::ProcessUnspecified),
                "PROCESS_BROWSER" => Some(Self::ProcessBrowser),
                "PROCESS_RENDERER" => Some(Self::ProcessRenderer),
                "PROCESS_UTILITY" => Some(Self::ProcessUtility),
                "PROCESS_ZYGOTE" => Some(Self::ProcessZygote),
                "PROCESS_SANDBOX_HELPER" => Some(Self::ProcessSandboxHelper),
                "PROCESS_GPU" => Some(Self::ProcessGpu),
                "PROCESS_PPAPI_PLUGIN" => Some(Self::ProcessPpapiPlugin),
                "PROCESS_PPAPI_BROKER" => Some(Self::ProcessPpapiBroker),
                _ => None,
            }
        }
    }
}
/// This message specifies the "range of interest" for track events. With the
/// `drop_track_event_data_before` option set to `kTrackEventRangeOfInterest`,
/// Trace Processor drops track events outside of this range.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackEventRangeOfInterest {
    #[prost(int64, optional, tag = "1")]
    pub start_us: ::core::option::Option<i64>,
}
/// Describes a thread's attributes. Emitted as part of a TrackDescriptor,
/// usually by the thread's trace writer.
///
/// Next id: 9.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreadDescriptor {
    #[prost(int32, optional, tag = "1")]
    pub pid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub tid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub thread_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "thread_descriptor::ChromeThreadType", optional, tag = "4")]
    pub chrome_thread_type: ::core::option::Option<i32>,
    /// Deprecated. Use ClockSnapshot in combination with TracePacket's timestamp
    /// and timestamp_clock_id fields instead.
    #[prost(int64, optional, tag = "6")]
    pub reference_timestamp_us: ::core::option::Option<i64>,
    /// Absolute reference values. Clock values in subsequent TrackEvents can be
    /// encoded accumulatively and relative to these. This reduces their var-int
    /// encoding size.
    /// TODO(eseckler): Deprecated. Replace these with ClockSnapshot encoding.
    #[prost(int64, optional, tag = "7")]
    pub reference_thread_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub reference_thread_instruction_count: ::core::option::Option<i64>,
    /// To support old UI. New UI should determine default sorting by thread_type.
    #[prost(int32, optional, tag = "3")]
    pub legacy_sort_index: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ThreadDescriptor`.
pub mod thread_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChromeThreadType {
        ChromeThreadUnspecified = 0,
        ChromeThreadMain = 1,
        ChromeThreadIo = 2,
        /// Scheduler:
        ChromeThreadPoolBgWorker = 3,
        ChromeThreadPoolFgWorker = 4,
        ChromeThreadPoolFbBlocking = 5,
        ChromeThreadPoolBgBlocking = 6,
        ChromeThreadPoolService = 7,
        /// Compositor:
        ChromeThreadCompositor = 8,
        ChromeThreadVizCompositor = 9,
        ChromeThreadCompositorWorker = 10,
        /// Renderer:
        ChromeThreadServiceWorker = 11,
        /// Tracing related threads:
        ChromeThreadMemoryInfra = 50,
        ChromeThreadSamplingProfiler = 51,
    }
    impl ChromeThreadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ChromeThreadUnspecified => "CHROME_THREAD_UNSPECIFIED",
                Self::ChromeThreadMain => "CHROME_THREAD_MAIN",
                Self::ChromeThreadIo => "CHROME_THREAD_IO",
                Self::ChromeThreadPoolBgWorker => "CHROME_THREAD_POOL_BG_WORKER",
                Self::ChromeThreadPoolFgWorker => "CHROME_THREAD_POOL_FG_WORKER",
                Self::ChromeThreadPoolFbBlocking => "CHROME_THREAD_POOL_FB_BLOCKING",
                Self::ChromeThreadPoolBgBlocking => "CHROME_THREAD_POOL_BG_BLOCKING",
                Self::ChromeThreadPoolService => "CHROME_THREAD_POOL_SERVICE",
                Self::ChromeThreadCompositor => "CHROME_THREAD_COMPOSITOR",
                Self::ChromeThreadVizCompositor => "CHROME_THREAD_VIZ_COMPOSITOR",
                Self::ChromeThreadCompositorWorker => "CHROME_THREAD_COMPOSITOR_WORKER",
                Self::ChromeThreadServiceWorker => "CHROME_THREAD_SERVICE_WORKER",
                Self::ChromeThreadMemoryInfra => "CHROME_THREAD_MEMORY_INFRA",
                Self::ChromeThreadSamplingProfiler => "CHROME_THREAD_SAMPLING_PROFILER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHROME_THREAD_UNSPECIFIED" => Some(Self::ChromeThreadUnspecified),
                "CHROME_THREAD_MAIN" => Some(Self::ChromeThreadMain),
                "CHROME_THREAD_IO" => Some(Self::ChromeThreadIo),
                "CHROME_THREAD_POOL_BG_WORKER" => Some(Self::ChromeThreadPoolBgWorker),
                "CHROME_THREAD_POOL_FG_WORKER" => Some(Self::ChromeThreadPoolFgWorker),
                "CHROME_THREAD_POOL_FB_BLOCKING" => {
                    Some(Self::ChromeThreadPoolFbBlocking)
                }
                "CHROME_THREAD_POOL_BG_BLOCKING" => {
                    Some(Self::ChromeThreadPoolBgBlocking)
                }
                "CHROME_THREAD_POOL_SERVICE" => Some(Self::ChromeThreadPoolService),
                "CHROME_THREAD_COMPOSITOR" => Some(Self::ChromeThreadCompositor),
                "CHROME_THREAD_VIZ_COMPOSITOR" => Some(Self::ChromeThreadVizCompositor),
                "CHROME_THREAD_COMPOSITOR_WORKER" => {
                    Some(Self::ChromeThreadCompositorWorker)
                }
                "CHROME_THREAD_SERVICE_WORKER" => Some(Self::ChromeThreadServiceWorker),
                "CHROME_THREAD_MEMORY_INFRA" => Some(Self::ChromeThreadMemoryInfra),
                "CHROME_THREAD_SAMPLING_PROFILER" => {
                    Some(Self::ChromeThreadSamplingProfiler)
                }
                _ => None,
            }
        }
    }
}
/// Describes the attributes for a Chrome process. Must be paired with a
/// ProcessDescriptor in the same TrackDescriptor.
///
/// Next id: 6.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeProcessDescriptor {
    #[prost(enumeration = "chrome_process_descriptor::ProcessType", optional, tag = "1")]
    pub process_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub process_priority: ::core::option::Option<i32>,
    /// To support old UI. New UI should determine default sorting by process_type.
    #[prost(int32, optional, tag = "3")]
    pub legacy_sort_index: ::core::option::Option<i32>,
    /// Name of the hosting app for WebView. Used to match renderer processes to
    /// their hosting apps.
    #[prost(string, optional, tag = "4")]
    pub host_app_package_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The ID to link crashes to trace.
    /// Notes:
    /// * The ID is per process. So, each trace may contain many IDs, and you need
    ///    to look for the ID from crashed process to find the crash report.
    /// * Having a "chrome-trace-id" in crash doesn't necessarily mean we can
    ///    get an uploaded trace, since uploads could have failed.
    /// * On the other hand, if there was a crash during the session and trace was
    ///    uploaded, it is very likely to find a crash report with the trace ID.
    /// * This is not crash ID or trace ID. It is just a random 64-bit number
    ///    recorded in both traces and crashes. It is possible to have collisions,
    ///    though very rare.
    #[prost(uint64, optional, tag = "5")]
    pub crash_trace_id: ::core::option::Option<u64>,
}
/// Nested message and enum types in `ChromeProcessDescriptor`.
pub mod chrome_process_descriptor {
    /// See chromium's content::ProcessType.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessType {
        ProcessUnspecified = 0,
        ProcessBrowser = 1,
        ProcessRenderer = 2,
        ProcessUtility = 3,
        ProcessZygote = 4,
        ProcessSandboxHelper = 5,
        ProcessGpu = 6,
        ProcessPpapiPlugin = 7,
        ProcessPpapiBroker = 8,
        ProcessServiceNetwork = 9,
        ProcessServiceTracing = 10,
        ProcessServiceStorage = 11,
        ProcessServiceAudio = 12,
        ProcessServiceDataDecoder = 13,
        ProcessServiceUtilWin = 14,
        ProcessServiceProxyResolver = 15,
        ProcessServiceCdm = 16,
        ProcessServiceVideoCapture = 17,
        ProcessServiceUnzipper = 18,
        ProcessServiceMirroring = 19,
        ProcessServiceFilepatcher = 20,
        ProcessServiceTts = 21,
        ProcessServicePrinting = 22,
        ProcessServiceQuarantine = 23,
        ProcessServiceCrosLocalsearch = 24,
        ProcessServiceCrosAssistantAudioDecoder = 25,
        ProcessServiceFileutil = 26,
        ProcessServicePrintcompositor = 27,
        ProcessServicePaintpreview = 28,
        ProcessServiceSpeechrecognition = 29,
        ProcessServiceXrdevice = 30,
        ProcessServiceReadicon = 31,
        ProcessServiceLanguagedetection = 32,
        ProcessServiceSharing = 33,
        ProcessServiceMediaparser = 34,
        ProcessServiceQrcodegenerator = 35,
        ProcessServiceProfileimport = 36,
        ProcessServiceIme = 37,
        ProcessServiceRecording = 38,
        ProcessServiceShapedetection = 39,
        ProcessRendererExtension = 40,
        ProcessServiceMediaFoundation = 41,
    }
    impl ProcessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ProcessUnspecified => "PROCESS_UNSPECIFIED",
                Self::ProcessBrowser => "PROCESS_BROWSER",
                Self::ProcessRenderer => "PROCESS_RENDERER",
                Self::ProcessUtility => "PROCESS_UTILITY",
                Self::ProcessZygote => "PROCESS_ZYGOTE",
                Self::ProcessSandboxHelper => "PROCESS_SANDBOX_HELPER",
                Self::ProcessGpu => "PROCESS_GPU",
                Self::ProcessPpapiPlugin => "PROCESS_PPAPI_PLUGIN",
                Self::ProcessPpapiBroker => "PROCESS_PPAPI_BROKER",
                Self::ProcessServiceNetwork => "PROCESS_SERVICE_NETWORK",
                Self::ProcessServiceTracing => "PROCESS_SERVICE_TRACING",
                Self::ProcessServiceStorage => "PROCESS_SERVICE_STORAGE",
                Self::ProcessServiceAudio => "PROCESS_SERVICE_AUDIO",
                Self::ProcessServiceDataDecoder => "PROCESS_SERVICE_DATA_DECODER",
                Self::ProcessServiceUtilWin => "PROCESS_SERVICE_UTIL_WIN",
                Self::ProcessServiceProxyResolver => "PROCESS_SERVICE_PROXY_RESOLVER",
                Self::ProcessServiceCdm => "PROCESS_SERVICE_CDM",
                Self::ProcessServiceVideoCapture => "PROCESS_SERVICE_VIDEO_CAPTURE",
                Self::ProcessServiceUnzipper => "PROCESS_SERVICE_UNZIPPER",
                Self::ProcessServiceMirroring => "PROCESS_SERVICE_MIRRORING",
                Self::ProcessServiceFilepatcher => "PROCESS_SERVICE_FILEPATCHER",
                Self::ProcessServiceTts => "PROCESS_SERVICE_TTS",
                Self::ProcessServicePrinting => "PROCESS_SERVICE_PRINTING",
                Self::ProcessServiceQuarantine => "PROCESS_SERVICE_QUARANTINE",
                Self::ProcessServiceCrosLocalsearch => "PROCESS_SERVICE_CROS_LOCALSEARCH",
                Self::ProcessServiceCrosAssistantAudioDecoder => {
                    "PROCESS_SERVICE_CROS_ASSISTANT_AUDIO_DECODER"
                }
                Self::ProcessServiceFileutil => "PROCESS_SERVICE_FILEUTIL",
                Self::ProcessServicePrintcompositor => "PROCESS_SERVICE_PRINTCOMPOSITOR",
                Self::ProcessServicePaintpreview => "PROCESS_SERVICE_PAINTPREVIEW",
                Self::ProcessServiceSpeechrecognition => {
                    "PROCESS_SERVICE_SPEECHRECOGNITION"
                }
                Self::ProcessServiceXrdevice => "PROCESS_SERVICE_XRDEVICE",
                Self::ProcessServiceReadicon => "PROCESS_SERVICE_READICON",
                Self::ProcessServiceLanguagedetection => {
                    "PROCESS_SERVICE_LANGUAGEDETECTION"
                }
                Self::ProcessServiceSharing => "PROCESS_SERVICE_SHARING",
                Self::ProcessServiceMediaparser => "PROCESS_SERVICE_MEDIAPARSER",
                Self::ProcessServiceQrcodegenerator => "PROCESS_SERVICE_QRCODEGENERATOR",
                Self::ProcessServiceProfileimport => "PROCESS_SERVICE_PROFILEIMPORT",
                Self::ProcessServiceIme => "PROCESS_SERVICE_IME",
                Self::ProcessServiceRecording => "PROCESS_SERVICE_RECORDING",
                Self::ProcessServiceShapedetection => "PROCESS_SERVICE_SHAPEDETECTION",
                Self::ProcessRendererExtension => "PROCESS_RENDERER_EXTENSION",
                Self::ProcessServiceMediaFoundation => "PROCESS_SERVICE_MEDIA_FOUNDATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESS_UNSPECIFIED" => Some(Self::ProcessUnspecified),
                "PROCESS_BROWSER" => Some(Self::ProcessBrowser),
                "PROCESS_RENDERER" => Some(Self::ProcessRenderer),
                "PROCESS_UTILITY" => Some(Self::ProcessUtility),
                "PROCESS_ZYGOTE" => Some(Self::ProcessZygote),
                "PROCESS_SANDBOX_HELPER" => Some(Self::ProcessSandboxHelper),
                "PROCESS_GPU" => Some(Self::ProcessGpu),
                "PROCESS_PPAPI_PLUGIN" => Some(Self::ProcessPpapiPlugin),
                "PROCESS_PPAPI_BROKER" => Some(Self::ProcessPpapiBroker),
                "PROCESS_SERVICE_NETWORK" => Some(Self::ProcessServiceNetwork),
                "PROCESS_SERVICE_TRACING" => Some(Self::ProcessServiceTracing),
                "PROCESS_SERVICE_STORAGE" => Some(Self::ProcessServiceStorage),
                "PROCESS_SERVICE_AUDIO" => Some(Self::ProcessServiceAudio),
                "PROCESS_SERVICE_DATA_DECODER" => Some(Self::ProcessServiceDataDecoder),
                "PROCESS_SERVICE_UTIL_WIN" => Some(Self::ProcessServiceUtilWin),
                "PROCESS_SERVICE_PROXY_RESOLVER" => {
                    Some(Self::ProcessServiceProxyResolver)
                }
                "PROCESS_SERVICE_CDM" => Some(Self::ProcessServiceCdm),
                "PROCESS_SERVICE_VIDEO_CAPTURE" => Some(Self::ProcessServiceVideoCapture),
                "PROCESS_SERVICE_UNZIPPER" => Some(Self::ProcessServiceUnzipper),
                "PROCESS_SERVICE_MIRRORING" => Some(Self::ProcessServiceMirroring),
                "PROCESS_SERVICE_FILEPATCHER" => Some(Self::ProcessServiceFilepatcher),
                "PROCESS_SERVICE_TTS" => Some(Self::ProcessServiceTts),
                "PROCESS_SERVICE_PRINTING" => Some(Self::ProcessServicePrinting),
                "PROCESS_SERVICE_QUARANTINE" => Some(Self::ProcessServiceQuarantine),
                "PROCESS_SERVICE_CROS_LOCALSEARCH" => {
                    Some(Self::ProcessServiceCrosLocalsearch)
                }
                "PROCESS_SERVICE_CROS_ASSISTANT_AUDIO_DECODER" => {
                    Some(Self::ProcessServiceCrosAssistantAudioDecoder)
                }
                "PROCESS_SERVICE_FILEUTIL" => Some(Self::ProcessServiceFileutil),
                "PROCESS_SERVICE_PRINTCOMPOSITOR" => {
                    Some(Self::ProcessServicePrintcompositor)
                }
                "PROCESS_SERVICE_PAINTPREVIEW" => Some(Self::ProcessServicePaintpreview),
                "PROCESS_SERVICE_SPEECHRECOGNITION" => {
                    Some(Self::ProcessServiceSpeechrecognition)
                }
                "PROCESS_SERVICE_XRDEVICE" => Some(Self::ProcessServiceXrdevice),
                "PROCESS_SERVICE_READICON" => Some(Self::ProcessServiceReadicon),
                "PROCESS_SERVICE_LANGUAGEDETECTION" => {
                    Some(Self::ProcessServiceLanguagedetection)
                }
                "PROCESS_SERVICE_SHARING" => Some(Self::ProcessServiceSharing),
                "PROCESS_SERVICE_MEDIAPARSER" => Some(Self::ProcessServiceMediaparser),
                "PROCESS_SERVICE_QRCODEGENERATOR" => {
                    Some(Self::ProcessServiceQrcodegenerator)
                }
                "PROCESS_SERVICE_PROFILEIMPORT" => {
                    Some(Self::ProcessServiceProfileimport)
                }
                "PROCESS_SERVICE_IME" => Some(Self::ProcessServiceIme),
                "PROCESS_SERVICE_RECORDING" => Some(Self::ProcessServiceRecording),
                "PROCESS_SERVICE_SHAPEDETECTION" => {
                    Some(Self::ProcessServiceShapedetection)
                }
                "PROCESS_RENDERER_EXTENSION" => Some(Self::ProcessRendererExtension),
                "PROCESS_SERVICE_MEDIA_FOUNDATION" => {
                    Some(Self::ProcessServiceMediaFoundation)
                }
                _ => None,
            }
        }
    }
}
/// Describes a Chrome thread's attributes. Emitted as part of a TrackDescriptor,
/// usually by the thread's trace writer. Must be paired with a ThreadDescriptor
/// in the same TrackDescriptor.
///
/// Next id: 3.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChromeThreadDescriptor {
    #[prost(enumeration = "chrome_thread_descriptor::ThreadType", optional, tag = "1")]
    pub thread_type: ::core::option::Option<i32>,
    /// To support old UI. New UI should determine default sorting by thread_type.
    #[prost(int32, optional, tag = "2")]
    pub legacy_sort_index: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ChromeThreadDescriptor`.
pub mod chrome_thread_descriptor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThreadType {
        ThreadUnspecified = 0,
        ThreadMain = 1,
        ThreadIo = 2,
        ThreadPoolBgWorker = 3,
        ThreadPoolFgWorker = 4,
        ThreadPoolFgBlocking = 5,
        ThreadPoolBgBlocking = 6,
        ThreadPoolService = 7,
        ThreadCompositor = 8,
        ThreadVizCompositor = 9,
        ThreadCompositorWorker = 10,
        ThreadServiceWorker = 11,
        ThreadNetworkService = 12,
        ThreadChildIo = 13,
        ThreadBrowserIo = 14,
        ThreadBrowserMain = 15,
        ThreadRendererMain = 16,
        ThreadUtilityMain = 17,
        ThreadGpuMain = 18,
        ThreadCacheBlockfile = 19,
        ThreadMedia = 20,
        ThreadAudioOutputdevice = 21,
        ThreadAudioInputdevice = 22,
        ThreadGpuMemory = 23,
        ThreadGpuVsync = 24,
        ThreadDxaVideodecoder = 25,
        ThreadBrowserWatchdog = 26,
        ThreadWebrtcNetwork = 27,
        ThreadWindowOwner = 28,
        ThreadWebrtcSignaling = 29,
        ThreadWebrtcWorker = 30,
        ThreadPpapiMain = 31,
        ThreadGpuWatchdog = 32,
        ThreadSwapper = 33,
        ThreadGamepadPolling = 34,
        ThreadWebcrypto = 35,
        ThreadDatabase = 36,
        ThreadProxyresolver = 37,
        ThreadDevtoolsadb = 38,
        ThreadNetworkconfigwatcher = 39,
        ThreadWasapiRender = 40,
        ThreadLoaderLockSampler = 41,
        ThreadMemoryInfra = 50,
        ThreadSamplingProfiler = 51,
    }
    impl ThreadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ThreadUnspecified => "THREAD_UNSPECIFIED",
                Self::ThreadMain => "THREAD_MAIN",
                Self::ThreadIo => "THREAD_IO",
                Self::ThreadPoolBgWorker => "THREAD_POOL_BG_WORKER",
                Self::ThreadPoolFgWorker => "THREAD_POOL_FG_WORKER",
                Self::ThreadPoolFgBlocking => "THREAD_POOL_FG_BLOCKING",
                Self::ThreadPoolBgBlocking => "THREAD_POOL_BG_BLOCKING",
                Self::ThreadPoolService => "THREAD_POOL_SERVICE",
                Self::ThreadCompositor => "THREAD_COMPOSITOR",
                Self::ThreadVizCompositor => "THREAD_VIZ_COMPOSITOR",
                Self::ThreadCompositorWorker => "THREAD_COMPOSITOR_WORKER",
                Self::ThreadServiceWorker => "THREAD_SERVICE_WORKER",
                Self::ThreadNetworkService => "THREAD_NETWORK_SERVICE",
                Self::ThreadChildIo => "THREAD_CHILD_IO",
                Self::ThreadBrowserIo => "THREAD_BROWSER_IO",
                Self::ThreadBrowserMain => "THREAD_BROWSER_MAIN",
                Self::ThreadRendererMain => "THREAD_RENDERER_MAIN",
                Self::ThreadUtilityMain => "THREAD_UTILITY_MAIN",
                Self::ThreadGpuMain => "THREAD_GPU_MAIN",
                Self::ThreadCacheBlockfile => "THREAD_CACHE_BLOCKFILE",
                Self::ThreadMedia => "THREAD_MEDIA",
                Self::ThreadAudioOutputdevice => "THREAD_AUDIO_OUTPUTDEVICE",
                Self::ThreadAudioInputdevice => "THREAD_AUDIO_INPUTDEVICE",
                Self::ThreadGpuMemory => "THREAD_GPU_MEMORY",
                Self::ThreadGpuVsync => "THREAD_GPU_VSYNC",
                Self::ThreadDxaVideodecoder => "THREAD_DXA_VIDEODECODER",
                Self::ThreadBrowserWatchdog => "THREAD_BROWSER_WATCHDOG",
                Self::ThreadWebrtcNetwork => "THREAD_WEBRTC_NETWORK",
                Self::ThreadWindowOwner => "THREAD_WINDOW_OWNER",
                Self::ThreadWebrtcSignaling => "THREAD_WEBRTC_SIGNALING",
                Self::ThreadWebrtcWorker => "THREAD_WEBRTC_WORKER",
                Self::ThreadPpapiMain => "THREAD_PPAPI_MAIN",
                Self::ThreadGpuWatchdog => "THREAD_GPU_WATCHDOG",
                Self::ThreadSwapper => "THREAD_SWAPPER",
                Self::ThreadGamepadPolling => "THREAD_GAMEPAD_POLLING",
                Self::ThreadWebcrypto => "THREAD_WEBCRYPTO",
                Self::ThreadDatabase => "THREAD_DATABASE",
                Self::ThreadProxyresolver => "THREAD_PROXYRESOLVER",
                Self::ThreadDevtoolsadb => "THREAD_DEVTOOLSADB",
                Self::ThreadNetworkconfigwatcher => "THREAD_NETWORKCONFIGWATCHER",
                Self::ThreadWasapiRender => "THREAD_WASAPI_RENDER",
                Self::ThreadLoaderLockSampler => "THREAD_LOADER_LOCK_SAMPLER",
                Self::ThreadMemoryInfra => "THREAD_MEMORY_INFRA",
                Self::ThreadSamplingProfiler => "THREAD_SAMPLING_PROFILER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "THREAD_UNSPECIFIED" => Some(Self::ThreadUnspecified),
                "THREAD_MAIN" => Some(Self::ThreadMain),
                "THREAD_IO" => Some(Self::ThreadIo),
                "THREAD_POOL_BG_WORKER" => Some(Self::ThreadPoolBgWorker),
                "THREAD_POOL_FG_WORKER" => Some(Self::ThreadPoolFgWorker),
                "THREAD_POOL_FG_BLOCKING" => Some(Self::ThreadPoolFgBlocking),
                "THREAD_POOL_BG_BLOCKING" => Some(Self::ThreadPoolBgBlocking),
                "THREAD_POOL_SERVICE" => Some(Self::ThreadPoolService),
                "THREAD_COMPOSITOR" => Some(Self::ThreadCompositor),
                "THREAD_VIZ_COMPOSITOR" => Some(Self::ThreadVizCompositor),
                "THREAD_COMPOSITOR_WORKER" => Some(Self::ThreadCompositorWorker),
                "THREAD_SERVICE_WORKER" => Some(Self::ThreadServiceWorker),
                "THREAD_NETWORK_SERVICE" => Some(Self::ThreadNetworkService),
                "THREAD_CHILD_IO" => Some(Self::ThreadChildIo),
                "THREAD_BROWSER_IO" => Some(Self::ThreadBrowserIo),
                "THREAD_BROWSER_MAIN" => Some(Self::ThreadBrowserMain),
                "THREAD_RENDERER_MAIN" => Some(Self::ThreadRendererMain),
                "THREAD_UTILITY_MAIN" => Some(Self::ThreadUtilityMain),
                "THREAD_GPU_MAIN" => Some(Self::ThreadGpuMain),
                "THREAD_CACHE_BLOCKFILE" => Some(Self::ThreadCacheBlockfile),
                "THREAD_MEDIA" => Some(Self::ThreadMedia),
                "THREAD_AUDIO_OUTPUTDEVICE" => Some(Self::ThreadAudioOutputdevice),
                "THREAD_AUDIO_INPUTDEVICE" => Some(Self::ThreadAudioInputdevice),
                "THREAD_GPU_MEMORY" => Some(Self::ThreadGpuMemory),
                "THREAD_GPU_VSYNC" => Some(Self::ThreadGpuVsync),
                "THREAD_DXA_VIDEODECODER" => Some(Self::ThreadDxaVideodecoder),
                "THREAD_BROWSER_WATCHDOG" => Some(Self::ThreadBrowserWatchdog),
                "THREAD_WEBRTC_NETWORK" => Some(Self::ThreadWebrtcNetwork),
                "THREAD_WINDOW_OWNER" => Some(Self::ThreadWindowOwner),
                "THREAD_WEBRTC_SIGNALING" => Some(Self::ThreadWebrtcSignaling),
                "THREAD_WEBRTC_WORKER" => Some(Self::ThreadWebrtcWorker),
                "THREAD_PPAPI_MAIN" => Some(Self::ThreadPpapiMain),
                "THREAD_GPU_WATCHDOG" => Some(Self::ThreadGpuWatchdog),
                "THREAD_SWAPPER" => Some(Self::ThreadSwapper),
                "THREAD_GAMEPAD_POLLING" => Some(Self::ThreadGamepadPolling),
                "THREAD_WEBCRYPTO" => Some(Self::ThreadWebcrypto),
                "THREAD_DATABASE" => Some(Self::ThreadDatabase),
                "THREAD_PROXYRESOLVER" => Some(Self::ThreadProxyresolver),
                "THREAD_DEVTOOLSADB" => Some(Self::ThreadDevtoolsadb),
                "THREAD_NETWORKCONFIGWATCHER" => Some(Self::ThreadNetworkconfigwatcher),
                "THREAD_WASAPI_RENDER" => Some(Self::ThreadWasapiRender),
                "THREAD_LOADER_LOCK_SAMPLER" => Some(Self::ThreadLoaderLockSampler),
                "THREAD_MEMORY_INFRA" => Some(Self::ThreadMemoryInfra),
                "THREAD_SAMPLING_PROFILER" => Some(Self::ThreadSamplingProfiler),
                _ => None,
            }
        }
    }
}
/// Defines properties of a counter track, e.g. for built-in counters (thread
/// time, instruction count, ..) or user-specified counters (e.g. memory usage of
/// a specific app component).
///
/// Counter tracks only support TYPE_COUNTER track events, which specify new
/// values for the counter. For counters that require per-slice values, counter
/// values can instead be provided in a more efficient encoding via TrackEvent's
/// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
/// slice-type events cannot be emitted onto a counter track.
///
/// Values for counters that are only emitted on a single packet sequence can
/// optionally be delta-encoded, see |is_incremental|.
///
/// Next id: 7.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CounterDescriptor {
    /// For built-in counters (e.g. thread time). Custom user-specified counters
    /// (e.g. those emitted by TRACE_COUNTER macros of the client library)
    /// shouldn't set this, and instead provide a counter name via TrackDescriptor.
    #[prost(enumeration = "counter_descriptor::BuiltinCounterType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Names of categories of the counter (usually for user-specified counters).
    /// In the client library, categories are a way to turn groups of individual
    /// counters (or events) on or off.
    #[prost(string, repeated, tag = "2")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Type of the counter's values. Built-in counters imply a value for this
    /// field.
    #[prost(enumeration = "counter_descriptor::Unit", optional, tag = "3")]
    pub unit: ::core::option::Option<i32>,
    /// In order to use a unit not defined as a part of |Unit|, a free-form unit
    /// name can be used instead.
    #[prost(string, optional, tag = "6")]
    pub unit_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Multiplication factor of this counter's values, e.g. to supply
    /// COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
    #[prost(int64, optional, tag = "4")]
    pub unit_multiplier: ::core::option::Option<i64>,
    /// Whether values for this counter are provided as delta values. Only
    /// supported for counters that are emitted on a single packet-sequence (e.g.
    /// thread time). Counter values in subsequent packets on the current packet
    /// sequence will be interpreted as delta values from the sequence's most
    /// recent value for the counter. When incremental state is cleared, the
    /// counter value is considered to be reset to 0. Thus, the first value after
    /// incremental state is cleared is effectively an absolute value.
    #[prost(bool, optional, tag = "5")]
    pub is_incremental: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CounterDescriptor`.
pub mod counter_descriptor {
    /// Built-in counters, usually with special meaning in the client library,
    /// trace processor, legacy JSON format, or UI. Trace processor will infer a
    /// track name from the enum value if none is provided in TrackDescriptor.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BuiltinCounterType {
        CounterUnspecified = 0,
        /// implies UNIT_TIME_NS.
        CounterThreadTimeNs = 1,
        /// implies UNIT_COUNT.
        CounterThreadInstructionCount = 2,
    }
    impl BuiltinCounterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CounterUnspecified => "COUNTER_UNSPECIFIED",
                Self::CounterThreadTimeNs => "COUNTER_THREAD_TIME_NS",
                Self::CounterThreadInstructionCount => "COUNTER_THREAD_INSTRUCTION_COUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COUNTER_UNSPECIFIED" => Some(Self::CounterUnspecified),
                "COUNTER_THREAD_TIME_NS" => Some(Self::CounterThreadTimeNs),
                "COUNTER_THREAD_INSTRUCTION_COUNT" => {
                    Some(Self::CounterThreadInstructionCount)
                }
                _ => None,
            }
        }
    }
    /// Type of the values for the counters - to supply lower granularity units,
    /// see also |unit_multiplier|.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        Unspecified = 0,
        TimeNs = 1,
        Count = 2,
        /// TODO(eseckler): Support more units as necessary.
        SizeBytes = 3,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::TimeNs => "UNIT_TIME_NS",
                Self::Count => "UNIT_COUNT",
                Self::SizeBytes => "UNIT_SIZE_BYTES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "UNIT_TIME_NS" => Some(Self::TimeNs),
                "UNIT_COUNT" => Some(Self::Count),
                "UNIT_SIZE_BYTES" => Some(Self::SizeBytes),
                _ => None,
            }
        }
    }
}
/// Defines a track for TrackEvents. Slices and instant events on the same track
/// will be nested based on their timestamps, see TrackEvent::Type.
///
/// A TrackDescriptor only needs to be emitted by one trace writer / producer and
/// is valid for the entirety of the trace. To ensure the descriptor isn't lost
/// when the ring buffer wraps, it should be reemitted whenever incremental state
/// is cleared.
///
/// As a fallback, TrackEvents emitted without an explicit track association will
/// be associated with an implicit trace-global track (uuid = 0), see also
/// |TrackEvent::track_uuid|. It is possible but not necessary to emit a
/// TrackDescriptor for this implicit track.
///
/// Next id: 11.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackDescriptor {
    /// Unique ID that identifies this track. This ID is global to the whole trace.
    /// Producers should ensure that it is unlikely to clash with IDs emitted by
    /// other producers. A value of 0 denotes the implicit trace-global track.
    ///
    /// For example, legacy TRACE_EVENT macros may use a hash involving the async
    /// event id + id_scope, pid, and/or tid to compute this ID.
    #[prost(uint64, optional, tag = "1")]
    pub uuid: ::core::option::Option<u64>,
    /// A parent track reference can be used to describe relationships between
    /// tracks. For example, to define an asynchronous track which is scoped to a
    /// specific process, specify the uuid for that process's process track here.
    /// Similarly, to associate a COUNTER_THREAD_TIME_NS counter track with a
    /// thread, specify the uuid for that thread's thread track here.
    #[prost(uint64, optional, tag = "5")]
    pub parent_uuid: ::core::option::Option<u64>,
    /// Associate the track with a process, making it the process-global track.
    /// There should only be one such track per process (usually for instant
    /// events; trace processor uses this fact to detect pid reuse). If you need
    /// more (e.g. for asynchronous events), create child tracks using parent_uuid.
    ///
    /// Trace processor will merge events on a process track with slice-type events
    /// from other sources (e.g. ftrace) for the same process into a single
    /// timeline view.
    #[prost(message, optional, tag = "3")]
    pub process: ::core::option::Option<ProcessDescriptor>,
    #[prost(message, optional, tag = "6")]
    pub chrome_process: ::core::option::Option<ChromeProcessDescriptor>,
    /// Associate the track with a thread, indicating that the track's events
    /// describe synchronous code execution on the thread. There should only be one
    /// such track per thread (trace processor uses this fact to detect tid reuse).
    ///
    /// Trace processor will merge events on a thread track with slice-type events
    /// from other sources (e.g. ftrace) for the same thread into a single timeline
    /// view.
    #[prost(message, optional, tag = "4")]
    pub thread: ::core::option::Option<ThreadDescriptor>,
    #[prost(message, optional, tag = "7")]
    pub chrome_thread: ::core::option::Option<ChromeThreadDescriptor>,
    /// Descriptor for a counter track. If set, the track will only support
    /// TYPE_COUNTER TrackEvents (and values provided via TrackEvent's
    /// |extra_counter_values|).
    #[prost(message, optional, tag = "8")]
    pub counter: ::core::option::Option<CounterDescriptor>,
    /// If true, forces Trace Processor to use separate tracks for track events
    /// and system events for the same thread.
    /// Track events timestamps in Chrome have microsecond resolution, while
    /// system events use nanoseconds. It results in broken event nesting when
    /// track events and system events share a track.
    #[prost(bool, optional, tag = "9")]
    pub disallow_merging_with_system_tracks: ::core::option::Option<bool>,
    /// Name of the track. Optional - if unspecified, it may be derived from the
    /// process/thread name (process/thread tracks), the first event's name (async
    /// tracks), or counter name (counter tracks).
    #[prost(oneof = "track_descriptor::StaticOrDynamicName", tags = "2, 10")]
    pub static_or_dynamic_name: ::core::option::Option<
        track_descriptor::StaticOrDynamicName,
    >,
}
/// Nested message and enum types in `TrackDescriptor`.
pub mod track_descriptor {
    /// Name of the track. Optional - if unspecified, it may be derived from the
    /// process/thread name (process/thread tracks), the first event's name (async
    /// tracks), or counter name (counter tracks).
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StaticOrDynamicName {
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        /// This field is only set by the SDK when perfetto::StaticString is
        /// provided.
        #[prost(string, tag = "10")]
        StaticName(::prost::alloc::string::String),
    }
}
/// Translation rules for the trace processor.
/// See the comments for each rule type for specific meaning.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslationTable {
    #[prost(oneof = "translation_table::Table", tags = "1, 2, 3, 4, 5")]
    pub table: ::core::option::Option<translation_table::Table>,
}
/// Nested message and enum types in `TranslationTable`.
pub mod translation_table {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Table {
        #[prost(message, tag = "1")]
        ChromeHistogram(super::ChromeHistorgramTranslationTable),
        #[prost(message, tag = "2")]
        ChromeUserEvent(super::ChromeUserEventTranslationTable),
        #[prost(message, tag = "3")]
        ChromePerformanceMark(super::ChromePerformanceMarkTranslationTable),
        #[prost(message, tag = "4")]
        SliceName(super::SliceNameTranslationTable),
        #[prost(message, tag = "5")]
        ProcessTrackName(super::ProcessTrackNameTranslationTable),
    }
}
/// Chrome histogram sample hash -> name translation rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeHistorgramTranslationTable {
    #[prost(map = "uint64, string", tag = "1")]
    pub hash_to_name: ::std::collections::HashMap<u64, ::prost::alloc::string::String>,
}
/// Chrome user event action hash -> name translation rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromeUserEventTranslationTable {
    #[prost(map = "uint64, string", tag = "1")]
    pub action_hash_to_name: ::std::collections::HashMap<
        u64,
        ::prost::alloc::string::String,
    >,
}
/// Chrome performance mark translation rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromePerformanceMarkTranslationTable {
    #[prost(map = "uint32, string", tag = "1")]
    pub site_hash_to_name: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "uint32, string", tag = "2")]
    pub mark_hash_to_name: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
}
/// Raw -> deobfuscated slice name translation rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SliceNameTranslationTable {
    #[prost(map = "string, string", tag = "1")]
    pub raw_to_deobfuscated_name: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Raw -> deobfuscated process track name translation rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessTrackNameTranslationTable {
    #[prost(map = "string, string", tag = "1")]
    pub raw_to_deobfuscated_name: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// A random unique ID that identifies the trace.
/// This message has been introduced in v32. Prior to that, the UUID was
/// only (optionally) present in the TraceConfig.trace_uuid_msb/lsb fields.
/// This has been moved to a standalone packet to deal with new use-cases for
/// go/gapless-aot, where the same tracing session can be serialized several
/// times, in which case the UUID is changed on each snapshot and does not match
/// the one in the TraceConfig.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TraceUuid {
    #[prost(int64, optional, tag = "1")]
    pub msb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub lsb: ::core::option::Option<i64>,
}
/// When a TracingSession receives a trigger it records the boot time nanoseconds
/// in the TracePacket's timestamp field as well as the name of the producer that
/// triggered it. We emit this data so filtering can be done on triggers received
/// in the trace.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trigger {
    /// Name of the trigger which was received.
    #[prost(string, optional, tag = "1")]
    pub trigger_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The actual producer that activated |trigger|.
    #[prost(string, optional, tag = "2")]
    pub producer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The verified UID of the producer.
    #[prost(int32, optional, tag = "3")]
    pub trusted_producer_uid: ::core::option::Option<i32>,
}
/// Event used by testing code.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestEvent {
    /// Arbitrary string used in tests.
    #[prost(string, optional, tag = "1")]
    pub str: ::core::option::Option<::prost::alloc::string::String>,
    /// The current value of the random number sequence used in tests.
    #[prost(uint32, optional, tag = "2")]
    pub seq_value: ::core::option::Option<u32>,
    /// Monotonically increased on each packet.
    #[prost(uint64, optional, tag = "3")]
    pub counter: ::core::option::Option<u64>,
    /// No more packets should follow (from the current sequence).
    #[prost(bool, optional, tag = "4")]
    pub is_last: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "5")]
    pub payload: ::core::option::Option<test_event::TestPayload>,
}
/// Nested message and enum types in `TestEvent`.
pub mod test_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TestPayload {
        #[prost(string, repeated, tag = "1")]
        pub str: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub nested: ::prost::alloc::vec::Vec<TestPayload>,
        #[prost(string, optional, tag = "4")]
        pub single_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "5")]
        pub single_int: ::core::option::Option<i32>,
        #[prost(int32, repeated, packed = "false", tag = "6")]
        pub repeated_ints: ::prost::alloc::vec::Vec<i32>,
        /// When 0 this is the bottom-most nested message.
        #[prost(uint32, optional, tag = "3")]
        pub remaining_nesting_depth: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "7")]
        pub debug_annotations: ::prost::alloc::vec::Vec<super::DebugAnnotation>,
    }
}
/// Common state for UIs visualizing Perfetto traces.
/// This message can be appended as a TracePacket by UIs to save the
/// visible state (e.g. scroll position/zoom state) for future opening
/// of the trace.
/// Design doc: go/trace-ui-state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UiState {
    /// The start and end bounds of the viewport of the UI in nanoseconds.
    ///
    /// This is the absolute time associated to slices and other events in
    /// trace processor tables (i.e. the |ts| column of most tables)
    #[prost(int64, optional, tag = "1")]
    pub timeline_start_ts: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub timeline_end_ts: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub highlight_process: ::core::option::Option<ui_state::HighlightProcess>,
}
/// Nested message and enum types in `UiState`.
pub mod ui_state {
    /// Indicates that the given process should be highlighted by the UI.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HighlightProcess {
        #[prost(oneof = "highlight_process::Selector", tags = "1, 2")]
        pub selector: ::core::option::Option<highlight_process::Selector>,
    }
    /// Nested message and enum types in `HighlightProcess`.
    pub mod highlight_process {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Selector {
            /// The pid of the process to highlight. This is useful for UIs to focus
            /// on tracks of a particular process in the trace.
            ///
            /// If more than one process in a trace has the same pid, it is UI
            /// implementation specific how the process to be focused will be
            /// chosen.
            #[prost(uint32, tag = "1")]
            Pid(u32),
            /// The command line of the process to highlight; for most Android apps,
            /// this is the package name of the app. This is useful for UIs to focus
            /// on a particular app in the trace.
            ///
            /// If more than one process hasthe same cmdline, it is UI implementation
            /// specific how the process to be focused will be chosen.
            #[prost(string, tag = "2")]
            Cmdline(::prost::alloc::string::String),
        }
    }
}
/// TracePacket is the root object of a Perfetto trace.
/// A Perfetto trace is a linear sequence of TracePacket(s).
///
/// The tracing service guarantees that all TracePacket(s) written by a given
/// TraceWriter are seen in-order, without gaps or duplicates. If, for any
/// reason, a TraceWriter sequence becomes invalid, no more packets are returned
/// to the Consumer (or written into the trace file).
/// TracePacket(s) written by different TraceWriter(s), hence even different
/// data sources, can be seen in arbitrary order.
/// The consumer can re-establish a total order, if interested, using the packet
/// timestamps, after having synchronized the different clocks onto a global
/// clock.
///
/// The tracing service is agnostic of the content of TracePacket, with the
/// exception of few fields (e.g.. trusted_*, trace_config) that are written by
/// the service itself.
///
/// See the [Buffers and Dataflow](/docs/concepts/buffers.md) doc for details.
///
/// Next reserved id: 14 (up to 15).
/// Next id: 113.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracePacket {
    /// The timestamp of the TracePacket.
    /// By default this timestamps refers to the trace clock (CLOCK_BOOTTIME on
    /// Android). It can be overridden using a different timestamp_clock_id.
    /// The clock domain definition in ClockSnapshot can also override:
    /// - The unit (default: 1ns).
    /// - The absolute vs delta encoding (default: absolute timestamp).
    #[prost(uint64, optional, tag = "8")]
    pub timestamp: ::core::option::Option<u64>,
    /// Specifies the ID of the clock used for the TracePacket |timestamp|. Can be
    /// one of the built-in types from ClockSnapshot::BuiltinClocks, or a
    /// producer-defined clock id.
    /// If unspecified and if no default per-sequence value has been provided via
    /// TracePacketDefaults, it defaults to BuiltinClocks::BOOTTIME.
    #[prost(uint32, optional, tag = "58")]
    pub timestamp_clock_id: ::core::option::Option<u32>,
    /// Trusted process id of the producer which generated this packet, written by
    /// the service.
    #[prost(int32, optional, tag = "79")]
    pub trusted_pid: ::core::option::Option<i32>,
    /// Incrementally emitted interned data, valid only on the packet's sequence
    /// (packets with the same |trusted_packet_sequence_id|). The writer will
    /// usually emit new interned data in the same TracePacket that first refers to
    /// it (since the last reset of interning state). It may also be emitted
    /// proactively in advance of referring to them in later packets.
    #[prost(message, optional, tag = "12")]
    pub interned_data: ::core::option::Option<InternedData>,
    #[prost(uint32, optional, tag = "13")]
    pub sequence_flags: ::core::option::Option<u32>,
    /// DEPRECATED. Moved to SequenceFlags::SEQ_INCREMENTAL_STATE_CLEARED.
    #[prost(bool, optional, tag = "41")]
    pub incremental_state_cleared: ::core::option::Option<bool>,
    /// Default values for fields of later TracePackets emitted on this packet's
    /// sequence (TracePackets with the same |trusted_packet_sequence_id|).
    /// It must be reemitted when incremental state is cleared (see
    /// |incremental_state_cleared|).
    /// Requires that any future packet emitted on the same sequence specifies
    /// the SEQ_NEEDS_INCREMENTAL_STATE flag.
    /// TracePacketDefaults always override the global defaults for any future
    /// packet on this sequence (regardless of SEQ_NEEDS_INCREMENTAL_STATE).
    #[prost(message, optional, tag = "59")]
    pub trace_packet_defaults: ::core::option::Option<TracePacketDefaults>,
    /// Flag set by the service if, for the current packet sequence (see
    /// |trusted_packet_sequence_id|), either:
    /// * this is the first packet, or
    /// * one or multiple packets were dropped since the last packet that the
    ///    consumer read from the sequence. This can happen if chunks in the trace
    ///    buffer are overridden before the consumer could read them when the trace
    ///    is configured in ring buffer mode.
    ///
    /// When packet loss occurs, incrementally emitted data (including interned
    /// data) on the sequence should be considered invalid up until the next packet
    /// with SEQ_INCREMENTAL_STATE_CLEARED set.
    #[prost(bool, optional, tag = "42")]
    pub previous_packet_dropped: ::core::option::Option<bool>,
    /// Flag set by a producer (starting from SDK v29) if, for the current packet
    /// sequence (see |trusted_packet_sequence_id|), this is the first packet.
    ///
    /// This flag can be used for distinguishing the two situations when
    /// processing the trace:
    /// 1. There are no prior events for the sequence because of data loss, e.g.
    ///     due to ring buffer wrapping.
    /// 2. There are no prior events for the sequence because it didn't start
    ///     before this packet (= there's definitely no preceding data loss).
    ///
    /// Given that older SDK versions do not support this flag, this flag not
    /// being present for a particular sequence does not necessarily imply data
    /// loss.
    #[prost(bool, optional, tag = "87")]
    pub first_packet_on_sequence: ::core::option::Option<bool>,
    /// The machine ID for identifying trace packets in a multi-machine tracing
    /// session. Is emitted by the tracing service for producers running on a
    /// remote host (e.g. a VM guest). For more context: go/crosetto-vm-tracing.
    #[prost(uint32, optional, tag = "98")]
    pub machine_id: ::core::option::Option<u32>,
    #[prost(
        oneof = "trace_packet::Data",
        tags = "2, 9, 4, 5, 6, 7, 11, 89, 33, 34, 35, 37, 74, 75, 38, 40, 39, 45, 46, 109, 47, 48, 49, 51, 52, 53, 54, 56, 57, 62, 63, 65, 66, 67, 68, 69, 70, 71, 73, 76, 77, 78, 80, 81, 82, 83, 84, 86, 91, 55, 61, 64, 60, 43, 44, 1, 36, 50, 72, 88, 92, 90, 93, 94, 96, 97, 104, 105, 112, 95, 99, 100, 101, 102, 103, 107, 110, 111, 900"
    )]
    pub data: ::core::option::Option<trace_packet::Data>,
    /// Trusted user id of the producer which generated this packet. Keep in sync
    /// with TrustedPacket.trusted_uid.
    ///
    /// TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
    /// instead.
    #[prost(oneof = "trace_packet::OptionalTrustedUid", tags = "3")]
    pub optional_trusted_uid: ::core::option::Option<trace_packet::OptionalTrustedUid>,
    /// Service-assigned identifier of the packet sequence this packet belongs to.
    /// Uniquely identifies a producer + writer pair within the tracing session. A
    /// value of zero denotes an invalid ID. Keep in sync with
    /// TrustedPacket.trusted_packet_sequence_id.
    #[prost(oneof = "trace_packet::OptionalTrustedPacketSequenceId", tags = "10")]
    pub optional_trusted_packet_sequence_id: ::core::option::Option<
        trace_packet::OptionalTrustedPacketSequenceId,
    >,
}
/// Nested message and enum types in `TracePacket`.
pub mod trace_packet {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SequenceFlags {
        SeqUnspecified = 0,
        /// Set by the writer to indicate that it will re-emit any incremental data
        /// for the packet's sequence before referring to it again. This includes
        /// interned data as well as periodically emitted data like
        /// Process/ThreadDescriptors. This flag only affects the current packet
        /// sequence (see |trusted_packet_sequence_id|).
        ///
        /// When set, this TracePacket and subsequent TracePackets on the same
        /// sequence will not refer to any incremental data emitted before this
        /// TracePacket. For example, previously emitted interned data will be
        /// re-emitted if it is referred to again.
        ///
        /// When the reader detects packet loss (|previous_packet_dropped|), it needs
        /// to skip packets in the sequence until the next one with this flag set, to
        /// ensure intact incremental data.
        SeqIncrementalStateCleared = 1,
        /// This packet requires incremental state, such as TracePacketDefaults or
        /// InternedData, to be parsed correctly. The trace reader should skip this
        /// packet if incremental state is not valid on this sequence, i.e. if no
        /// packet with the SEQ_INCREMENTAL_STATE_CLEARED flag has been seen on the
        /// current |trusted_packet_sequence_id|.
        SeqNeedsIncrementalState = 2,
    }
    impl SequenceFlags {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SeqUnspecified => "SEQ_UNSPECIFIED",
                Self::SeqIncrementalStateCleared => "SEQ_INCREMENTAL_STATE_CLEARED",
                Self::SeqNeedsIncrementalState => "SEQ_NEEDS_INCREMENTAL_STATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEQ_UNSPECIFIED" => Some(Self::SeqUnspecified),
                "SEQ_INCREMENTAL_STATE_CLEARED" => Some(Self::SeqIncrementalStateCleared),
                "SEQ_NEEDS_INCREMENTAL_STATE" => Some(Self::SeqNeedsIncrementalState),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "2")]
        ProcessTree(super::ProcessTree),
        #[prost(message, tag = "9")]
        ProcessStats(super::ProcessStats),
        #[prost(message, tag = "4")]
        InodeFileMap(super::InodeFileMap),
        #[prost(message, tag = "5")]
        ChromeEvents(super::ChromeEventBundle),
        #[prost(message, tag = "6")]
        ClockSnapshot(super::ClockSnapshot),
        #[prost(message, tag = "7")]
        SysStats(super::SysStats),
        #[prost(message, tag = "11")]
        TrackEvent(super::TrackEvent),
        #[prost(message, tag = "89")]
        TraceUuid(super::TraceUuid),
        #[prost(message, tag = "33")]
        TraceConfig(super::TraceConfig),
        #[prost(message, tag = "34")]
        FtraceStats(super::FtraceStats),
        #[prost(message, tag = "35")]
        TraceStats(super::TraceStats),
        #[prost(message, tag = "37")]
        ProfilePacket(super::ProfilePacket),
        #[prost(message, tag = "74")]
        StreamingAllocation(super::StreamingAllocation),
        #[prost(message, tag = "75")]
        StreamingFree(super::StreamingFree),
        #[prost(message, tag = "38")]
        Battery(super::BatteryCounters),
        #[prost(message, tag = "40")]
        PowerRails(super::PowerRails),
        #[prost(message, tag = "39")]
        AndroidLog(super::AndroidLogPacket),
        #[prost(message, tag = "45")]
        SystemInfo(super::SystemInfo),
        #[prost(message, tag = "46")]
        Trigger(super::Trigger),
        #[prost(message, tag = "109")]
        ChromeTrigger(super::ChromeTrigger),
        #[prost(message, tag = "47")]
        PackagesList(super::PackagesList),
        #[prost(message, tag = "48")]
        ChromeBenchmarkMetadata(super::ChromeBenchmarkMetadata),
        #[prost(message, tag = "49")]
        PerfettoMetatrace(super::PerfettoMetatrace),
        #[prost(message, tag = "51")]
        ChromeMetadata(super::ChromeMetadataPacket),
        #[prost(message, tag = "52")]
        GpuCounterEvent(super::GpuCounterEvent),
        #[prost(message, tag = "53")]
        GpuRenderStageEvent(super::GpuRenderStageEvent),
        #[prost(message, tag = "54")]
        StreamingProfilePacket(super::StreamingProfilePacket),
        #[prost(message, tag = "56")]
        HeapGraph(super::HeapGraph),
        #[prost(message, tag = "57")]
        GraphicsFrameEvent(super::GraphicsFrameEvent),
        #[prost(message, tag = "62")]
        VulkanMemoryEvent(super::VulkanMemoryEvent),
        #[prost(message, tag = "63")]
        GpuLog(super::GpuLog),
        #[prost(message, tag = "65")]
        VulkanApiEvent(super::VulkanApiEvent),
        #[prost(message, tag = "66")]
        PerfSample(super::PerfSample),
        #[prost(message, tag = "67")]
        CpuInfo(super::CpuInfo),
        #[prost(message, tag = "68")]
        SmapsPacket(super::SmapsPacket),
        #[prost(message, tag = "69")]
        ServiceEvent(super::TracingServiceEvent),
        #[prost(message, tag = "70")]
        InitialDisplayState(super::InitialDisplayState),
        #[prost(message, tag = "71")]
        GpuMemTotalEvent(super::GpuMemTotalEvent),
        #[prost(message, tag = "73")]
        MemoryTrackerSnapshot(super::MemoryTrackerSnapshot),
        #[prost(message, tag = "76")]
        FrameTimelineEvent(super::FrameTimelineEvent),
        #[prost(message, tag = "77")]
        AndroidEnergyEstimationBreakdown(super::AndroidEnergyEstimationBreakdown),
        #[prost(message, tag = "78")]
        UiState(super::UiState),
        #[prost(message, tag = "80")]
        AndroidCameraFrameEvent(super::AndroidCameraFrameEvent),
        #[prost(message, tag = "81")]
        AndroidCameraSessionStats(super::AndroidCameraSessionStats),
        #[prost(message, tag = "82")]
        TranslationTable(super::TranslationTable),
        #[prost(message, tag = "83")]
        AndroidGameInterventionList(super::AndroidGameInterventionList),
        #[prost(message, tag = "84")]
        StatsdAtom(super::StatsdAtom),
        #[prost(message, tag = "86")]
        AndroidSystemProperty(super::AndroidSystemProperty),
        #[prost(message, tag = "91")]
        EntityStateResidency(super::EntityStateResidency),
        /// Only used in profile packets.
        #[prost(message, tag = "55")]
        ProfiledFrameSymbols(super::ProfiledFrameSymbols),
        #[prost(message, tag = "61")]
        ModuleSymbols(super::ModuleSymbols),
        #[prost(message, tag = "64")]
        DeobfuscationMapping(super::DeobfuscationMapping),
        /// Only used by TrackEvent.
        #[prost(message, tag = "60")]
        TrackDescriptor(super::TrackDescriptor),
        /// Deprecated, use TrackDescriptor instead.
        #[prost(message, tag = "43")]
        ProcessDescriptor(super::ProcessDescriptor),
        /// Deprecated, use TrackDescriptor instead.
        #[prost(message, tag = "44")]
        ThreadDescriptor(super::ThreadDescriptor),
        /// Events from the Linux kernel ftrace infrastructure.
        #[prost(message, tag = "1")]
        FtraceEvents(super::FtraceEventBundle),
        /// This field is emitted at periodic intervals (~10s) and
        /// contains always the binary representation of the UUID
        /// {82477a76-b28d-42ba-81dc-33326d57a079}. This is used to be able to
        /// efficiently partition long traces without having to fully parse them.
        #[prost(bytes, tag = "36")]
        SynchronizationMarker(::prost::alloc::vec::Vec<u8>),
        /// Zero or more proto encoded trace packets compressed using deflate.
        /// Each compressed_packets TracePacket (including the two field ids and
        /// sizes) should be less than 512KB.
        #[prost(bytes, tag = "50")]
        CompressedPackets(::prost::alloc::vec::Vec<u8>),
        /// Data sources can extend the trace proto with custom extension protos (see
        /// docs/design-docs/extensions.md). When they do that, the descriptor of
        /// their extension proto descriptor is serialized in this packet. This
        /// allows trace_processor to deserialize extended messages using reflection
        /// even if the extension proto is not checked in the Perfetto repo.
        #[prost(message, tag = "72")]
        ExtensionDescriptor(super::ExtensionDescriptor),
        /// Represents a single packet sent or received by the network.
        #[prost(message, tag = "88")]
        NetworkPacket(super::NetworkPacketEvent),
        /// Represents one or more packets sent or received by the network.
        #[prost(message, tag = "92")]
        NetworkPacketBundle(super::NetworkPacketBundle),
        /// The "range of interest" for track events. See the message definition
        /// comments for more details.
        #[prost(message, tag = "90")]
        TrackEventRangeOfInterest(super::TrackEventRangeOfInterest),
        /// Winscope traces
        #[prost(message, tag = "93")]
        SurfaceflingerLayersSnapshot(super::LayersSnapshotProto),
        #[prost(message, tag = "94")]
        SurfaceflingerTransactions(super::TransactionTraceEntry),
        #[prost(message, tag = "96")]
        ShellTransition(super::ShellTransition),
        #[prost(message, tag = "97")]
        ShellHandlerMappings(super::ShellHandlerMappings),
        #[prost(message, tag = "104")]
        ProtologMessage(super::ProtoLogMessage),
        #[prost(message, tag = "105")]
        ProtologViewerConfig(super::ProtoLogViewerConfig),
        #[prost(message, tag = "112")]
        WinscopeExtensions(super::WinscopeExtensions),
        /// Events from the Windows etw infrastructure.
        #[prost(message, tag = "95")]
        EtwEvents(super::EtwTraceEventBundle),
        #[prost(message, tag = "99")]
        V8JsCode(super::V8JsCode),
        #[prost(message, tag = "100")]
        V8InternalCode(super::V8InternalCode),
        #[prost(message, tag = "101")]
        V8WasmCode(super::V8WasmCode),
        #[prost(message, tag = "102")]
        V8RegExpCode(super::V8RegExpCode),
        #[prost(message, tag = "103")]
        V8CodeMove(super::V8CodeMove),
        /// Clock synchronization with remote machines.
        #[prost(message, tag = "107")]
        RemoteClockSync(super::RemoteClockSync),
        #[prost(message, tag = "110")]
        PixelModemEvents(super::PixelModemEvents),
        #[prost(message, tag = "111")]
        PixelModemTokenDatabase(super::PixelModemTokenDatabase),
        /// This field is only used for testing.
        /// In previous versions of this proto this field had the id 268435455
        /// This caused many problems:
        /// - protozero decoder does not handle field ids larger than 999.
        /// - old versions of protoc produce Java bindings with syntax errors when
        ///    the field id is large enough.
        #[prost(message, tag = "900")]
        ForTesting(super::TestEvent),
    }
    /// Trusted user id of the producer which generated this packet. Keep in sync
    /// with TrustedPacket.trusted_uid.
    ///
    /// TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
    /// instead.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OptionalTrustedUid {
        #[prost(int32, tag = "3")]
        TrustedUid(i32),
    }
    /// Service-assigned identifier of the packet sequence this packet belongs to.
    /// Uniquely identifies a producer + writer pair within the tracing session. A
    /// value of zero denotes an invalid ID. Keep in sync with
    /// TrustedPacket.trusted_packet_sequence_id.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OptionalTrustedPacketSequenceId {
        #[prost(uint32, tag = "10")]
        TrustedPacketSequenceId(u32),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    #[prost(message, repeated, tag = "1")]
    pub packet: ::prost::alloc::vec::Vec<TracePacket>,
}
