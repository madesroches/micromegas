# automatically generated by the FlatBuffers compiler, do not modify

# namespace: flatbuf

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class MetadataVersion(object):
    # 0.1.0 (October 2016).
    V1 = 0
    # 0.2.0 (February 2017). Non-backwards compatible with V1.
    V2 = 1
    # 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
    V3 = 2
    # >= 0.8.0 (December 2017). Non-backwards compatible with V3.
    V4 = 3
    # >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can read V4
    # metadata and IPC messages). Implementations are recommended to provide a
    # V4 compatibility mode with V5 format changes disabled.
    #
    # Incompatible changes between V4 and V5:
    # - Union buffer layout has changed. In V5, Unions don't have a validity
    #   bitmap buffer.
    V5 = 4


# Represents Arrow Features that might not have full support
# within implementations. This is intended to be used in
# two scenarios:
#  1.  A mechanism for readers of Arrow Streams
#      and files to understand that the stream or file makes
#      use of a feature that isn't supported or unknown to
#      the implementation (and therefore can meet the Arrow
#      forward compatibility guarantees).
#  2.  A means of negotiating between a client and server
#      what features a stream is allowed to use. The enums
#      values here are intented to represent higher level
#      features, additional details maybe negotiated
#      with key-value pairs specific to the protocol.
#
# Enums added to this list should be assigned power-of-two values
# to facilitate exchanging and comparing bitmaps for supported
# features.
class Feature(object):
    # Needed to make flatbuffers happy.
    UNUSED = 0
    # The stream makes use of multiple full dictionaries with the
    # same ID and assumes clients implement dictionary replacement
    # correctly.
    DICTIONARY_REPLACEMENT = 1
    # The stream makes use of compressed bodies as described
    # in Message.fbs.
    COMPRESSED_BODY = 2


class UnionMode(object):
    Sparse = 0
    Dense = 1


class Precision(object):
    HALF = 0
    SINGLE = 1
    DOUBLE = 2


class DateUnit(object):
    DAY = 0
    MILLISECOND = 1


class TimeUnit(object):
    SECOND = 0
    MILLISECOND = 1
    MICROSECOND = 2
    NANOSECOND = 3


class IntervalUnit(object):
    YEAR_MONTH = 0
    DAY_TIME = 1
    MONTH_DAY_NANO = 2


# ----------------------------------------------------------------------
# Top-level Type value, enabling extensible type-specific metadata. We can
# add new logical types to Type without breaking backwards compatibility
class Type(object):
    NONE = 0
    Null = 1
    Int = 2
    FloatingPoint = 3
    Binary = 4
    Utf8 = 5
    Bool = 6
    Decimal = 7
    Date = 8
    Time = 9
    Timestamp = 10
    Interval = 11
    List = 12
    Struct_ = 13
    Union = 14
    FixedSizeBinary = 15
    FixedSizeList = 16
    Map = 17
    Duration = 18
    LargeBinary = 19
    LargeUtf8 = 20
    LargeList = 21
    RunEndEncoded = 22
    BinaryView = 23
    Utf8View = 24
    ListView = 25
    LargeListView = 26


# ----------------------------------------------------------------------
# Dictionary encoding metadata
# Maintained for forwards compatibility, in the future
# Dictionaries might be explicit maps between integers and values
# allowing for non-contiguous index values
class DictionaryKind(object):
    DenseArray = 0


# ----------------------------------------------------------------------
# Endianness of the platform producing the data
class Endianness(object):
    Little = 0
    Big = 1


class SparseMatrixCompressedAxis(object):
    Row = 0
    Column = 1


class SparseTensorIndex(object):
    NONE = 0
    SparseTensorIndexCOO = 1
    SparseMatrixIndexCSX = 2
    SparseTensorIndexCSF = 3


class CompressionType(object):
    LZ4_FRAME = 0
    ZSTD = 1


# Provided for forward compatibility in case we need to support different
# strategies for compressing the IPC message body (like whole-body
# compression rather than buffer-level) in the future
class BodyCompressionMethod(object):
    # Each constituent buffer is first compressed with the indicated
    # compressor, and then written with the uncompressed length in the first 8
    # bytes as a 64-bit little-endian signed integer followed by the compressed
    # buffer bytes (and then padding as required by the protocol). The
    # uncompressed length may be set to -1 to indicate that the data that
    # follows is not compressed, which can be useful for cases where
    # compression does not yield appreciable savings.
    BUFFER = 0


# ----------------------------------------------------------------------
# The root Message type
# This union enables us to easily send different message types without
# redundant storage, and in the future we can easily add new message types.
#
# Arrow implementations do not need to implement all of the message types,
# which may include experimental metadata types. For maximum compatibility,
# it is best to send data using RecordBatch
class MessageHeader(object):
    NONE = 0
    Schema = 1
    DictionaryBatch = 2
    RecordBatch = 3
    Tensor = 4
    SparseTensor = 5


# These are stored in the flatbuffer in the Type union below
class Null(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Null()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNull(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Null
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def NullStart(builder):
    builder.StartObject(0)

def NullEnd(builder):
    return builder.EndObject()



# A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
# (according to the physical memory layout). We used Struct_ here as
# Struct is a reserved word in Flatbuffers
class Struct_(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Struct_()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsStruct_(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Struct_
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def Struct_Start(builder):
    builder.StartObject(0)

def Struct_End(builder):
    return builder.EndObject()



class List(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = List()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # List
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def ListStart(builder):
    builder.StartObject(0)

def ListEnd(builder):
    return builder.EndObject()



# Same as List, but with 64-bit offsets, allowing to represent
# extremely large data values.
class LargeList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LargeList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLargeList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # LargeList
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def LargeListStart(builder):
    builder.StartObject(0)

def LargeListEnd(builder):
    return builder.EndObject()



# Represents the same logical types that List can, but contains offsets and
# sizes allowing for writes in any order and sharing of child values among
# list values.
class ListView(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ListView()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsListView(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # ListView
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def ListViewStart(builder):
    builder.StartObject(0)

def ListViewEnd(builder):
    return builder.EndObject()



# Same as ListView, but with 64-bit offsets and sizes, allowing to represent
# extremely large data values.
class LargeListView(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LargeListView()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLargeListView(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # LargeListView
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def LargeListViewStart(builder):
    builder.StartObject(0)

def LargeListViewEnd(builder):
    return builder.EndObject()



class FixedSizeList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FixedSizeList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFixedSizeList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # FixedSizeList
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Number of list items per value
    # FixedSizeList
    def ListSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def FixedSizeListStart(builder):
    builder.StartObject(1)

def FixedSizeListAddListSize(builder, listSize):
    builder.PrependInt32Slot(0, listSize, 0)

def FixedSizeListEnd(builder):
    return builder.EndObject()



# A Map is a logical nested type that is represented as
#
# List<entries: Struct<key: K, value: V>>
#
# In this layout, the keys and values are each respectively contiguous. We do
# not constrain the key and value types, so the application is responsible
# for ensuring that the keys are hashable and unique. Whether the keys are sorted
# may be set in the metadata for this field.
#
# In a field with Map type, the field has a child Struct field, which then
# has two children: key type and the second the value type. The names of the
# child fields may be respectively "entries", "key", and "value", but this is
# not enforced.
#
# Map
# ```text
#   - child[0] entries: Struct
#     - child[0] key: K
#     - child[1] value: V
# ```
# Neither the "entries" field nor the "key" field may be nullable.
#
# The metadata is structured so that Arrow systems without special handling
# for Map can make Map an alias for List. The "layout" attribute for the Map
# field must have the same contents as a List.
class Map(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Map()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMap(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Map
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Set to true if the keys within each value are sorted
    # Map
    def KeysSorted(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def MapStart(builder):
    builder.StartObject(1)

def MapAddKeysSorted(builder, keysSorted):
    builder.PrependBoolSlot(0, keysSorted, 0)

def MapEnd(builder):
    return builder.EndObject()



# A union is a complex type with children in Field
# By default ids in the type vector refer to the offsets in the children
# optionally typeIds provides an indirection between the child offset and the type id
# for each child `typeIds[offset]` is the id used in the type vector
class Union(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Union()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUnion(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Union
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Union
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # Union
    def TypeIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Union
    def TypeIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Union
    def TypeIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Union
    def TypeIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def UnionStart(builder):
    builder.StartObject(2)

def UnionAddMode(builder, mode):
    builder.PrependInt16Slot(0, mode, 0)

def UnionAddTypeIds(builder, typeIds):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(typeIds), 0)

def UnionStartTypeIdsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def UnionEnd(builder):
    return builder.EndObject()



class Int(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Int
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int
    def BitWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Int
    def IsSigned(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def IntStart(builder):
    builder.StartObject(2)

def IntAddBitWidth(builder, bitWidth):
    builder.PrependInt32Slot(0, bitWidth, 0)

def IntAddIsSigned(builder, isSigned):
    builder.PrependBoolSlot(1, isSigned, 0)

def IntEnd(builder):
    return builder.EndObject()



class FloatingPoint(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FloatingPoint()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloatingPoint(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # FloatingPoint
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FloatingPoint
    def Precision(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

def FloatingPointStart(builder):
    builder.StartObject(1)

def FloatingPointAddPrecision(builder, precision):
    builder.PrependInt16Slot(0, precision, 0)

def FloatingPointEnd(builder):
    return builder.EndObject()



# Unicode with UTF-8 encoding
class Utf8(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Utf8()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUtf8(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Utf8
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def Utf8Start(builder):
    builder.StartObject(0)

def Utf8End(builder):
    return builder.EndObject()



# Opaque binary data
class Binary(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Binary()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBinary(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Binary
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def BinaryStart(builder):
    builder.StartObject(0)

def BinaryEnd(builder):
    return builder.EndObject()



# Same as Utf8, but with 64-bit offsets, allowing to represent
# extremely large data values.
class LargeUtf8(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LargeUtf8()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLargeUtf8(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # LargeUtf8
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def LargeUtf8Start(builder):
    builder.StartObject(0)

def LargeUtf8End(builder):
    return builder.EndObject()



# Same as Binary, but with 64-bit offsets, allowing to represent
# extremely large data values.
class LargeBinary(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LargeBinary()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLargeBinary(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # LargeBinary
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def LargeBinaryStart(builder):
    builder.StartObject(0)

def LargeBinaryEnd(builder):
    return builder.EndObject()



# Logically the same as Utf8, but the internal representation uses a view
# struct that contains the string length and either the string's entire data
# inline (for small strings) or an inlined prefix, an index of another buffer,
# and an offset pointing to a slice in that buffer (for non-small strings).
#
# Since it uses a variable number of data buffers, each Field with this type
# must have a corresponding entry in `variadicBufferCounts`.
class Utf8View(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Utf8View()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUtf8View(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Utf8View
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def Utf8ViewStart(builder):
    builder.StartObject(0)

def Utf8ViewEnd(builder):
    return builder.EndObject()



# Logically the same as Binary, but the internal representation uses a view
# struct that contains the string length and either the string's entire data
# inline (for small strings) or an inlined prefix, an index of another buffer,
# and an offset pointing to a slice in that buffer (for non-small strings).
#
# Since it uses a variable number of data buffers, each Field with this type
# must have a corresponding entry in `variadicBufferCounts`.
class BinaryView(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BinaryView()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBinaryView(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # BinaryView
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def BinaryViewStart(builder):
    builder.StartObject(0)

def BinaryViewEnd(builder):
    return builder.EndObject()



class FixedSizeBinary(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FixedSizeBinary()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFixedSizeBinary(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # FixedSizeBinary
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Number of bytes per value
    # FixedSizeBinary
    def ByteWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def FixedSizeBinaryStart(builder):
    builder.StartObject(1)

def FixedSizeBinaryAddByteWidth(builder, byteWidth):
    builder.PrependInt32Slot(0, byteWidth, 0)

def FixedSizeBinaryEnd(builder):
    return builder.EndObject()



class Bool(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Bool()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBool(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Bool
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def BoolStart(builder):
    builder.StartObject(0)

def BoolEnd(builder):
    return builder.EndObject()



# Contains two child arrays, run_ends and values.
# The run_ends child array must be a 16/32/64-bit integer array
# which encodes the indices at which the run with the value in 
# each corresponding index in the values child array ends.
# Like list/struct types, the value array can be of any type.
class RunEndEncoded(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = RunEndEncoded()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsRunEndEncoded(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # RunEndEncoded
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def RunEndEncodedStart(builder):
    builder.StartObject(0)

def RunEndEncodedEnd(builder):
    return builder.EndObject()



# Exact decimal value represented as an integer value in two's
# complement. Currently 32-bit (4-byte), 64-bit (8-byte), 
# 128-bit (16-byte) and 256-bit (32-byte) integers are used.
# The representation uses the endianness indicated in the Schema.
class Decimal(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Decimal()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDecimal(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Decimal
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Total number of decimal digits
    # Decimal
    def Precision(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Number of digits after the decimal point "."
    # Decimal
    def Scale(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Number of bits per value. The accepted widths are 32, 64, 128 and 256.
    # We use bitWidth for consistency with Int::bitWidth.
    # Decimal
    def BitWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 128

def DecimalStart(builder):
    builder.StartObject(3)

def DecimalAddPrecision(builder, precision):
    builder.PrependInt32Slot(0, precision, 0)

def DecimalAddScale(builder, scale):
    builder.PrependInt32Slot(1, scale, 0)

def DecimalAddBitWidth(builder, bitWidth):
    builder.PrependInt32Slot(2, bitWidth, 128)

def DecimalEnd(builder):
    return builder.EndObject()



# Date is either a 32-bit or 64-bit signed integer type representing an
# elapsed time since UNIX epoch (1970-01-01), stored in either of two units:
#
# * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
#   leap seconds), where the values are evenly divisible by 86400000
# * Days (32 bits) since the UNIX epoch
class Date(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Date()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDate(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Date
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Date
    def Unit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 1

def DateStart(builder):
    builder.StartObject(1)

def DateAddUnit(builder, unit):
    builder.PrependInt16Slot(0, unit, 1)

def DateEnd(builder):
    return builder.EndObject()



# Time is either a 32-bit or 64-bit signed integer type representing an
# elapsed time since midnight, stored in either of four units: seconds,
# milliseconds, microseconds or nanoseconds.
#
# The integer `bitWidth` depends on the `unit` and must be one of the following:
# * SECOND and MILLISECOND: 32 bits
# * MICROSECOND and NANOSECOND: 64 bits
#
# The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
# (exclusive), adjusted for the time unit (for example, up to 86400000
# exclusive for the MILLISECOND unit).
# This definition doesn't allow for leap seconds. Time values from
# measurements with leap seconds will need to be corrected when ingesting
# into Arrow (for example by replacing the value 86400 with 86399).
class Time(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Time()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTime(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Time
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Time
    def Unit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 1

    # Time
    def BitWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 32

def TimeStart(builder):
    builder.StartObject(2)

def TimeAddUnit(builder, unit):
    builder.PrependInt16Slot(0, unit, 1)

def TimeAddBitWidth(builder, bitWidth):
    builder.PrependInt32Slot(1, bitWidth, 32)

def TimeEnd(builder):
    return builder.EndObject()



# Timestamp is a 64-bit signed integer representing an elapsed time since a
# fixed epoch, stored in either of four units: seconds, milliseconds,
# microseconds or nanoseconds, and is optionally annotated with a timezone.
#
# Timestamp values do not include any leap seconds (in other words, all
# days are considered 86400 seconds long).
#
# Timestamps with a non-empty timezone
# ------------------------------------
#
# If a Timestamp column has a non-empty timezone value, its epoch is
# 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone
# (the Unix epoch), regardless of the Timestamp's own timezone.
#
# Therefore, timestamp values with a non-empty timezone correspond to
# physical points in time together with some additional information about
# how the data was obtained and/or how to display it (the timezone).
#
#   For example, the timestamp value 0 with the timezone string "Europe/Paris"
#   corresponds to "January 1st 1970, 00h00" in the UTC timezone, but the
#   application may prefer to display it as "January 1st 1970, 01h00" in
#   the Europe/Paris timezone (which is the same physical point in time).
#
# One consequence is that timestamp values with a non-empty timezone
# can be compared and ordered directly, since they all share the same
# well-known point of reference (the Unix epoch).
#
# Timestamps with an unset / empty timezone
# -----------------------------------------
#
# If a Timestamp column has no timezone value, its epoch is
# 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.
#
# Therefore, timestamp values without a timezone cannot be meaningfully
# interpreted as physical points in time, but only as calendar / clock
# indications ("wall clock time") in an unspecified timezone.
#
#   For example, the timestamp value 0 with an empty timezone string
#   corresponds to "January 1st 1970, 00h00" in an unknown timezone: there
#   is not enough information to interpret it as a well-defined physical
#   point in time.
#
# One consequence is that timestamp values without a timezone cannot
# be reliably compared or ordered, since they may have different points of
# reference.  In particular, it is *not* possible to interpret an unset
# or empty timezone as the same as "UTC".
#
# Conversion between timezones
# ----------------------------
#
# If a Timestamp column has a non-empty timezone, changing the timezone
# to a different non-empty value is a metadata-only operation:
# the timestamp values need not change as their point of reference remains
# the same (the Unix epoch).
#
# However, if a Timestamp column has no timezone value, changing it to a
# non-empty value requires to think about the desired semantics.
# One possibility is to assume that the original timestamp values are
# relative to the epoch of the timezone being set; timestamp values should
# then adjusted to the Unix epoch (for example, changing the timezone from
# empty to "Europe/Paris" would require converting the timestamp values
# from "Europe/Paris" to "UTC", which seems counter-intuitive but is
# nevertheless correct).
#
# Guidelines for encoding data from external libraries
# ----------------------------------------------------
#
# Date & time libraries often have multiple different data types for temporal
# data. In order to ease interoperability between different implementations the
# Arrow project has some recommendations for encoding these types into a Timestamp
# column.
#
# An "instant" represents a physical point in time that has no relevant timezone
# (for example, astronomical data). To encode an instant, use a Timestamp with
# the timezone string set to "UTC", and make sure the Timestamp values
# are relative to the UTC epoch (January 1st 1970, midnight).
#
# A "zoned date-time" represents a physical point in time annotated with an
# informative timezone (for example, the timezone in which the data was
# recorded).  To encode a zoned date-time, use a Timestamp with the timezone
# string set to the name of the timezone, and make sure the Timestamp values
# are relative to the UTC epoch (January 1st 1970, midnight).
#
#  (There is some ambiguity between an instant and a zoned date-time with the
#   UTC timezone.  Both of these are stored the same in Arrow.  Typically,
#   this distinction does not matter.  If it does, then an application should
#   use custom metadata or an extension type to distinguish between the two cases.)
#
# An "offset date-time" represents a physical point in time combined with an
# explicit offset from UTC.  To encode an offset date-time, use a Timestamp
# with the timezone string set to the numeric timezone offset string
# (e.g. "+03:00"), and make sure the Timestamp values are relative to
# the UTC epoch (January 1st 1970, midnight).
#
# A "naive date-time" (also called "local date-time" in some libraries)
# represents a wall clock time combined with a calendar date, but with
# no indication of how to map this information to a physical point in time.
# Naive date-times must be handled with care because of this missing
# information, and also because daylight saving time (DST) may make
# some values ambiguous or nonexistent. A naive date-time may be
# stored as a struct with Date and Time fields. However, it may also be
# encoded into a Timestamp column with an empty timezone. The timestamp
# values should be computed "as if" the timezone of the date-time values
# was UTC; for example, the naive date-time "January 1st 1970, 00h00" would
# be encoded as timestamp value 0.
class Timestamp(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Timestamp()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTimestamp(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Timestamp
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Timestamp
    def Unit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # The timezone is an optional string indicating the name of a timezone,
    # one of:
    #
    # * As used in the Olson timezone database (the "tz database" or
    #   "tzdata"), such as "America/New_York".
    # * An absolute timezone offset of the form "+XX:XX" or "-XX:XX",
    #   such as "+07:30".
    #
    # Whether a timezone string is present indicates different semantics about
    # the data (see above).
    # Timestamp
    def Timezone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def TimestampStart(builder):
    builder.StartObject(2)

def TimestampAddUnit(builder, unit):
    builder.PrependInt16Slot(0, unit, 0)

def TimestampAddTimezone(builder, timezone):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(timezone), 0)

def TimestampEnd(builder):
    return builder.EndObject()



class Interval(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Interval()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInterval(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Interval
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Interval
    def Unit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

def IntervalStart(builder):
    builder.StartObject(1)

def IntervalAddUnit(builder, unit):
    builder.PrependInt16Slot(0, unit, 0)

def IntervalEnd(builder):
    return builder.EndObject()



class Duration(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Duration()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDuration(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Duration
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Duration
    def Unit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 1

def DurationStart(builder):
    builder.StartObject(1)

def DurationAddUnit(builder, unit):
    builder.PrependInt16Slot(0, unit, 1)

def DurationEnd(builder):
    return builder.EndObject()



# ----------------------------------------------------------------------
# user defined key value pairs to add custom metadata to arrow
# key namespacing is the responsibility of the user
class KeyValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = KeyValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsKeyValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # KeyValue
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # KeyValue
    def Key(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # KeyValue
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def KeyValueStart(builder):
    builder.StartObject(2)

def KeyValueAddKey(builder, key):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0)

def KeyValueAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def KeyValueEnd(builder):
    return builder.EndObject()



class DictionaryEncoding(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DictionaryEncoding()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDictionaryEncoding(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # DictionaryEncoding
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The known dictionary id in the application where this data is used. In
    # the file or streaming formats, the dictionary ids are found in the
    # DictionaryBatch messages
    # DictionaryEncoding
    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # The dictionary indices are constrained to be non-negative integers. If
    # this field is null, the indices must be signed int32. To maximize
    # cross-language compatibility and performance, implementations are
    # recommended to prefer signed integer types over unsigned integer types
    # and to avoid uint64 indices unless they are required by an application.
    # DictionaryEncoding
    def IndexType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # By default, dictionaries are not ordered, or the order does not have
    # semantic meaning. In some statistical, applications, dictionary-encoding
    # is used to represent ordered categorical data, and we provide a way to
    # preserve that metadata here
    # DictionaryEncoding
    def IsOrdered(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # DictionaryEncoding
    def DictionaryKind(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

def DictionaryEncodingStart(builder):
    builder.StartObject(4)

def DictionaryEncodingAddId(builder, id):
    builder.PrependInt64Slot(0, id, 0)

def DictionaryEncodingAddIndexType(builder, indexType):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indexType), 0)

def DictionaryEncodingAddIsOrdered(builder, isOrdered):
    builder.PrependBoolSlot(2, isOrdered, 0)

def DictionaryEncodingAddDictionaryKind(builder, dictionaryKind):
    builder.PrependInt16Slot(3, dictionaryKind, 0)

def DictionaryEncodingEnd(builder):
    return builder.EndObject()



# ----------------------------------------------------------------------
# A field represents a named column in a record / row batch or child of a
# nested type.
class Field(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Field()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsField(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Field
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Name is not required, in i.e. a List
    # Field
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Whether or not this field can contain nulls. Should be true in general.
    # Field
    def Nullable(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Field
    def TypeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # This is the type of the decoded value if the field is dictionary encoded.
    # Field
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # Present only if the field is dictionary encoded.
    # Field
    def Dictionary(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = DictionaryEncoding()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # children apply only to nested data types like Struct, List and Union. For
    # primitive types children will have length 0.
    # Field
    def Children(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Field()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Field
    def ChildrenLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Field
    def ChildrenIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # User-defined metadata
    # Field
    def CustomMetadata(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = KeyValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Field
    def CustomMetadataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Field
    def CustomMetadataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

def FieldStart(builder):
    builder.StartObject(7)

def FieldAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def FieldAddNullable(builder, nullable):
    builder.PrependBoolSlot(1, nullable, 0)

def FieldAddTypeType(builder, typeType):
    builder.PrependUint8Slot(2, typeType, 0)

def FieldAddType(builder, type):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)

def FieldAddDictionary(builder, dictionary):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(dictionary), 0)

def FieldAddChildren(builder, children):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(children), 0)

def FieldStartChildrenVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def FieldAddCustomMetadata(builder, customMetadata):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(customMetadata), 0)

def FieldStartCustomMetadataVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def FieldEnd(builder):
    return builder.EndObject()



# ----------------------------------------------------------------------
# A Buffer represents a single contiguous memory segment
class Buffer(object):
    __slots__ = ['_tab']

    @classmethod
    def SizeOf(cls):
        return 16

    # Buffer
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The relative offset into the shared memory page where the bytes for this
    # buffer starts
    # Buffer
    def Offset(self): return self._tab.Get(flatbuffers.number_types.Int64Flags, self._tab.Pos + flatbuffers.number_types.UOffsetTFlags.py_type(0))
    # The absolute length (in bytes) of the memory buffer. The memory is found
    # from offset (inclusive) to offset + length (non-inclusive). When building
    # messages using the encapsulated IPC message, padding bytes may be written
    # after a buffer, but such padding bytes do not need to be accounted for in
    # the size here.
    # Buffer
    def Length(self): return self._tab.Get(flatbuffers.number_types.Int64Flags, self._tab.Pos + flatbuffers.number_types.UOffsetTFlags.py_type(8))

def CreateBuffer(builder, offset, length):
    builder.Prep(8, 16)
    builder.PrependInt64(length)
    builder.PrependInt64(offset)
    return builder.Offset()


# ----------------------------------------------------------------------
# A Schema describes the columns in a row batch
class Schema(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Schema()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSchema(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Schema
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # endianness of the buffer
    # it is Little Endian by default
    # if endianness doesn't match the underlying system then the vectors need to be converted
    # Schema
    def Endianness(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # Schema
    def Fields(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Field()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Schema
    def FieldsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Schema
    def FieldsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Schema
    def CustomMetadata(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = KeyValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Schema
    def CustomMetadataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Schema
    def CustomMetadataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Features used in the stream/file.
    # Schema
    def Features(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # Schema
    def FeaturesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # Schema
    def FeaturesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Schema
    def FeaturesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def SchemaStart(builder):
    builder.StartObject(4)

def SchemaAddEndianness(builder, endianness):
    builder.PrependInt16Slot(0, endianness, 0)

def SchemaAddFields(builder, fields):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(fields), 0)

def SchemaStartFieldsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SchemaAddCustomMetadata(builder, customMetadata):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(customMetadata), 0)

def SchemaStartCustomMetadataVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SchemaAddFeatures(builder, features):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(features), 0)

def SchemaStartFeaturesVector(builder, numElems):
    return builder.StartVector(8, numElems, 8)

def SchemaEnd(builder):
    return builder.EndObject()



# ----------------------------------------------------------------------
# Data structures for dense tensors
# Shape data for a single axis in a tensor
class TensorDim(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TensorDim()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensorDim(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TensorDim
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Length of dimension
    # TensorDim
    def Size(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Name of the dimension, optional
    # TensorDim
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def TensorDimStart(builder):
    builder.StartObject(2)

def TensorDimAddSize(builder, size):
    builder.PrependInt64Slot(0, size, 0)

def TensorDimAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def TensorDimEnd(builder):
    return builder.EndObject()



class Tensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Tensor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Tensor
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Tensor
    def TypeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # The type of data contained in a value cell. Currently only fixed-width
    # value types are supported, no strings or nested types
    # Tensor
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # The dimensions of the tensor, optionally named
    # Tensor
    def Shape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = TensorDim()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Tensor
    def ShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def ShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Non-negative byte offsets to advance one value cell along each dimension
    # If omitted, default to row-major order (C-like).
    # Tensor
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # Tensor
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # Tensor
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # The location and size of the tensor's data
    # Tensor
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = o + self._tab.Pos
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def TensorStart(builder):
    builder.StartObject(5)

def TensorAddTypeType(builder, typeType):
    builder.PrependUint8Slot(0, typeType, 0)

def TensorAddType(builder, type):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)

def TensorAddShape(builder, shape):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

def TensorStartShapeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def TensorAddStrides(builder, strides):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)

def TensorStartStridesVector(builder, numElems):
    return builder.StartVector(8, numElems, 8)

def TensorAddData(builder, data):
    builder.PrependStructSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def TensorEnd(builder):
    return builder.EndObject()



# ----------------------------------------------------------------------
# EXPERIMENTAL: Data structures for sparse tensors
# Coordinate (COO) format of sparse tensor index.
#
# COO's index list are represented as a NxM matrix,
# where N is the number of non-zero values,
# and M is the number of dimensions of a sparse tensor.
#
# indicesBuffer stores the location and size of the data of this indices
# matrix.  The value type and the stride of the indices matrix is
# specified in indicesType and indicesStrides fields.
#
# For example, let X be a 2x3x4x5 tensor, and it has the following
# 6 non-zero values:
# ```text
#   X[0, 1, 2, 0] := 1
#   X[1, 1, 2, 3] := 2
#   X[0, 2, 1, 0] := 3
#   X[0, 1, 3, 0] := 4
#   X[0, 1, 2, 1] := 5
#   X[1, 2, 0, 4] := 6
# ```
# In COO format, the index matrix of X is the following 4x6 matrix:
# ```text
#   [[0, 0, 0, 0, 1, 1],
#    [1, 1, 1, 2, 1, 2],
#    [2, 2, 3, 1, 2, 0],
#    [0, 1, 0, 0, 3, 4]]
# ```
# When isCanonical is true, the indices is sorted in lexicographical order
# (row-major order), and it does not have duplicated entries.  Otherwise,
# the indices may not be sorted, or may have duplicated entries.
class SparseTensorIndexCOO(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseTensorIndexCOO()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSparseTensorIndexCOO(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SparseTensorIndexCOO
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The type of values in indicesBuffer
    # SparseTensorIndexCOO
    def IndicesType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Non-negative byte offsets to advance one value cell along each dimension
    # If omitted, default to row-major order (C-like).
    # SparseTensorIndexCOO
    def IndicesStrides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # SparseTensorIndexCOO
    def IndicesStridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # SparseTensorIndexCOO
    def IndicesStridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SparseTensorIndexCOO
    def IndicesStridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # The location and size of the indices matrix's data
    # SparseTensorIndexCOO
    def IndicesBuffer(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = o + self._tab.Pos
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # This flag is true if and only if the indices matrix is sorted in
    # row-major order, and does not have duplicated entries.
    # This sort order is the same as of Tensorflow's SparseTensor,
    # but it is inverse order of SciPy's canonical coo_matrix
    # (SciPy employs column-major order for its coo_matrix).
    # SparseTensorIndexCOO
    def IsCanonical(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def SparseTensorIndexCOOStart(builder):
    builder.StartObject(4)

def SparseTensorIndexCOOAddIndicesType(builder, indicesType):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(indicesType), 0)

def SparseTensorIndexCOOAddIndicesStrides(builder, indicesStrides):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indicesStrides), 0)

def SparseTensorIndexCOOStartIndicesStridesVector(builder, numElems):
    return builder.StartVector(8, numElems, 8)

def SparseTensorIndexCOOAddIndicesBuffer(builder, indicesBuffer):
    builder.PrependStructSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(indicesBuffer), 0)

def SparseTensorIndexCOOAddIsCanonical(builder, isCanonical):
    builder.PrependBoolSlot(3, isCanonical, 0)

def SparseTensorIndexCOOEnd(builder):
    return builder.EndObject()



# Compressed Sparse format, that is matrix-specific.
class SparseMatrixIndexCSX(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseMatrixIndexCSX()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSparseMatrixIndexCSX(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SparseMatrixIndexCSX
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Which axis, row or column, is compressed
    # SparseMatrixIndexCSX
    def CompressedAxis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # The type of values in indptrBuffer
    # SparseMatrixIndexCSX
    def IndptrType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # indptrBuffer stores the location and size of indptr array that
    # represents the range of the rows.
    # The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
    # The length of this array is 1 + (the number of rows), and the type
    # of index value is long.
    #
    # For example, let X be the following 6x4 matrix:
    # ```text
    #   X := [[0, 1, 2, 0],
    #         [0, 0, 3, 0],
    #         [0, 4, 0, 5],
    #         [0, 0, 0, 0],
    #         [6, 0, 7, 8],
    #         [0, 9, 0, 0]].
    # ```
    # The array of non-zero values in X is:
    # ```text
    #   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
    # ```
    # And the indptr of X is:
    # ```text
    #   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
    # ```
    # SparseMatrixIndexCSX
    def IndptrBuffer(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = o + self._tab.Pos
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The type of values in indicesBuffer
    # SparseMatrixIndexCSX
    def IndicesType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # indicesBuffer stores the location and size of the array that
    # contains the column indices of the corresponding non-zero values.
    # The type of index value is long.
    #
    # For example, the indices of the above X is:
    # ```text
    #   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
    # ```
    # Note that the indices are sorted in lexicographical order for each row.
    # SparseMatrixIndexCSX
    def IndicesBuffer(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = o + self._tab.Pos
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def SparseMatrixIndexCSXStart(builder):
    builder.StartObject(5)

def SparseMatrixIndexCSXAddCompressedAxis(builder, compressedAxis):
    builder.PrependInt16Slot(0, compressedAxis, 0)

def SparseMatrixIndexCSXAddIndptrType(builder, indptrType):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indptrType), 0)

def SparseMatrixIndexCSXAddIndptrBuffer(builder, indptrBuffer):
    builder.PrependStructSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(indptrBuffer), 0)

def SparseMatrixIndexCSXAddIndicesType(builder, indicesType):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(indicesType), 0)

def SparseMatrixIndexCSXAddIndicesBuffer(builder, indicesBuffer):
    builder.PrependStructSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(indicesBuffer), 0)

def SparseMatrixIndexCSXEnd(builder):
    return builder.EndObject()



# Compressed Sparse Fiber (CSF) sparse tensor index.
class SparseTensorIndexCSF(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseTensorIndexCSF()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSparseTensorIndexCSF(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SparseTensorIndexCSF
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # CSF is a generalization of compressed sparse row (CSR) index.
    # See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
    #
    # CSF index recursively compresses each dimension of a tensor into a set
    # of prefix trees. Each path from a root to leaf forms one tensor
    # non-zero index. CSF is implemented with two arrays of buffers and one
    # arrays of integers.
    #
    # For example, let X be a 2x3x4x5 tensor and let it have the following
    # 8 non-zero values:
    # ```text
    #   X[0, 0, 0, 1] := 1
    #   X[0, 0, 0, 2] := 2
    #   X[0, 1, 0, 0] := 3
    #   X[0, 1, 0, 2] := 4
    #   X[0, 1, 1, 0] := 5
    #   X[1, 1, 1, 0] := 6
    #   X[1, 1, 1, 1] := 7
    #   X[1, 1, 1, 2] := 8
    # ```
    # As a prefix tree this would be represented as:
    # ```text
    #         0          1
    #        / \         |
    #       0   1        1
    #      /   / \       |
    #     0   0   1      1
    #    /|  /|   |    /| |
    #   1 2 0 2   0   0 1 2
    # ```
    # The type of values in indptrBuffers
    # SparseTensorIndexCSF
    def IndptrType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # indptrBuffers stores the sparsity structure.
    # Each two consecutive dimensions in a tensor correspond to a buffer in
    # indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
    # and `indptrBuffers[dim][i + 1]` signify a range of nodes in
    # `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
    #
    # For example, the indptrBuffers for the above X is:
    # ```text
    #   indptrBuffer(X) = [
    #                       [0, 2, 3],
    #                       [0, 1, 3, 4],
    #                       [0, 2, 4, 5, 8]
    #                     ].
    # ```
    # SparseTensorIndexCSF
    def IndptrBuffers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensorIndexCSF
    def IndptrBuffersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SparseTensorIndexCSF
    def IndptrBuffersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # The type of values in indicesBuffers
    # SparseTensorIndexCSF
    def IndicesType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # indicesBuffers stores values of nodes.
    # Each tensor dimension corresponds to a buffer in indicesBuffers.
    # For example, the indicesBuffers for the above X is:
    # ```text
    #   indicesBuffer(X) = [
    #                        [0, 1],
    #                        [0, 1, 1],
    #                        [0, 0, 1, 1],
    #                        [1, 2, 0, 2, 0, 0, 1, 2]
    #                      ].
    # ```
    # SparseTensorIndexCSF
    def IndicesBuffers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensorIndexCSF
    def IndicesBuffersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SparseTensorIndexCSF
    def IndicesBuffersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # axisOrder stores the sequence in which dimensions were traversed to
    # produce the prefix tree.
    # For example, the axisOrder for the above X is:
    # ```text
    #   axisOrder(X) = [0, 1, 2, 3].
    # ```
    # SparseTensorIndexCSF
    def AxisOrder(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # SparseTensorIndexCSF
    def AxisOrderAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # SparseTensorIndexCSF
    def AxisOrderLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SparseTensorIndexCSF
    def AxisOrderIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def SparseTensorIndexCSFStart(builder):
    builder.StartObject(5)

def SparseTensorIndexCSFAddIndptrType(builder, indptrType):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(indptrType), 0)

def SparseTensorIndexCSFAddIndptrBuffers(builder, indptrBuffers):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indptrBuffers), 0)

def SparseTensorIndexCSFStartIndptrBuffersVector(builder, numElems):
    return builder.StartVector(16, numElems, 8)

def SparseTensorIndexCSFAddIndicesType(builder, indicesType):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(indicesType), 0)

def SparseTensorIndexCSFAddIndicesBuffers(builder, indicesBuffers):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(indicesBuffers), 0)

def SparseTensorIndexCSFStartIndicesBuffersVector(builder, numElems):
    return builder.StartVector(16, numElems, 8)

def SparseTensorIndexCSFAddAxisOrder(builder, axisOrder):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(axisOrder), 0)

def SparseTensorIndexCSFStartAxisOrderVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SparseTensorIndexCSFEnd(builder):
    return builder.EndObject()



class SparseTensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseTensor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSparseTensor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SparseTensor
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SparseTensor
    def TypeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # The type of data contained in a value cell.
    # Currently only fixed-width value types are supported,
    # no strings or nested types.
    # SparseTensor
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # The dimensions of the tensor, optionally named.
    # SparseTensor
    def Shape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = TensorDim()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensor
    def ShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SparseTensor
    def ShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # The number of non-zero values in a sparse tensor.
    # SparseTensor
    def NonZeroLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # SparseTensor
    def SparseIndexType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Sparse tensor index
    # SparseTensor
    def SparseIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # The location and size of the tensor's data
    # SparseTensor
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = o + self._tab.Pos
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def SparseTensorStart(builder):
    builder.StartObject(7)

def SparseTensorAddTypeType(builder, typeType):
    builder.PrependUint8Slot(0, typeType, 0)

def SparseTensorAddType(builder, type):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)

def SparseTensorAddShape(builder, shape):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

def SparseTensorStartShapeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SparseTensorAddNonZeroLength(builder, nonZeroLength):
    builder.PrependInt64Slot(3, nonZeroLength, 0)

def SparseTensorAddSparseIndexType(builder, sparseIndexType):
    builder.PrependUint8Slot(4, sparseIndexType, 0)

def SparseTensorAddSparseIndex(builder, sparseIndex):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(sparseIndex), 0)

def SparseTensorAddData(builder, data):
    builder.PrependStructSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def SparseTensorEnd(builder):
    return builder.EndObject()



# ----------------------------------------------------------------------
# Data structures for describing a table row batch (a collection of
# equal-length Arrow arrays)
# Metadata about a field at some level of a nested type tree (but not
# its children).
#
# For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`
# would have {length: 5, null_count: 2} for its List node, and {length: 6,
# null_count: 0} for its Int16 node, as separate FieldNode structs
class FieldNode(object):
    __slots__ = ['_tab']

    @classmethod
    def SizeOf(cls):
        return 16

    # FieldNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The number of value slots in the Arrow array at this level of a nested
    # tree
    # FieldNode
    def Length(self): return self._tab.Get(flatbuffers.number_types.Int64Flags, self._tab.Pos + flatbuffers.number_types.UOffsetTFlags.py_type(0))
    # The number of observed nulls. Fields with null_count == 0 may choose not
    # to write their physical validity bitmap out as a materialized buffer,
    # instead setting the length of the bitmap buffer to 0.
    # FieldNode
    def NullCount(self): return self._tab.Get(flatbuffers.number_types.Int64Flags, self._tab.Pos + flatbuffers.number_types.UOffsetTFlags.py_type(8))

def CreateFieldNode(builder, length, nullCount):
    builder.Prep(8, 16)
    builder.PrependInt64(nullCount)
    builder.PrependInt64(length)
    return builder.Offset()


# Optional compression for the memory buffers constituting IPC message
# bodies. Intended for use with RecordBatch but could be used for other
# message types
class BodyCompression(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BodyCompression()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBodyCompression(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # BodyCompression
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Compressor library.
    # For LZ4_FRAME, each compressed buffer must consist of a single frame.
    # BodyCompression
    def Codec(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Indicates the way the record batch body was compressed
    # BodyCompression
    def Method(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def BodyCompressionStart(builder):
    builder.StartObject(2)

def BodyCompressionAddCodec(builder, codec):
    builder.PrependInt8Slot(0, codec, 0)

def BodyCompressionAddMethod(builder, method):
    builder.PrependInt8Slot(1, method, 0)

def BodyCompressionEnd(builder):
    return builder.EndObject()



# A data header describing the shared memory layout of a "record" or "row"
# batch. Some systems call this a "row batch" internally and others a "record
# batch".
class RecordBatch(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = RecordBatch()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsRecordBatch(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # RecordBatch
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # number of records / rows. The arrays in the batch should all have this
    # length
    # RecordBatch
    def Length(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Nodes correspond to the pre-ordered flattened logical schema
    # RecordBatch
    def Nodes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            obj = FieldNode()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # RecordBatch
    def NodesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # RecordBatch
    def NodesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Buffers correspond to the pre-ordered flattened buffer tree
    #
    # The number of buffers appended to this list depends on the schema. For
    # example, most primitive arrays will have 2 buffers, 1 for the validity
    # bitmap and 1 for the values. For struct arrays, there will only be a
    # single buffer for the validity (nulls) bitmap
    # RecordBatch
    def Buffers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # RecordBatch
    def BuffersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # RecordBatch
    def BuffersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Optional compression of the message body
    # RecordBatch
    def Compression(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = BodyCompression()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Some types such as Utf8View are represented using a variable number of buffers.
    # For each such Field in the pre-ordered flattened logical schema, there will be
    # an entry in variadicBufferCounts to indicate the number of number of variadic
    # buffers which belong to that Field in the current RecordBatch.
    #
    # For example, the schema
    #     col1: Struct<alpha: Int32, beta: BinaryView, gamma: Float64>
    #     col2: Utf8View
    # contains two Fields with variadic buffers so variadicBufferCounts will have
    # two entries, the first counting the variadic buffers of `col1.beta` and the
    # second counting `col2`'s.
    #
    # This field may be omitted if and only if the schema contains no Fields with
    # a variable number of buffers, such as BinaryView and Utf8View.
    # RecordBatch
    def VariadicBufferCounts(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # RecordBatch
    def VariadicBufferCountsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # RecordBatch
    def VariadicBufferCountsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # RecordBatch
    def VariadicBufferCountsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def RecordBatchStart(builder):
    builder.StartObject(5)

def RecordBatchAddLength(builder, length):
    builder.PrependInt64Slot(0, length, 0)

def RecordBatchAddNodes(builder, nodes):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(nodes), 0)

def RecordBatchStartNodesVector(builder, numElems):
    return builder.StartVector(16, numElems, 8)

def RecordBatchAddBuffers(builder, buffers):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(buffers), 0)

def RecordBatchStartBuffersVector(builder, numElems):
    return builder.StartVector(16, numElems, 8)

def RecordBatchAddCompression(builder, compression):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(compression), 0)

def RecordBatchAddVariadicBufferCounts(builder, variadicBufferCounts):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(variadicBufferCounts), 0)

def RecordBatchStartVariadicBufferCountsVector(builder, numElems):
    return builder.StartVector(8, numElems, 8)

def RecordBatchEnd(builder):
    return builder.EndObject()



# For sending dictionary encoding information. Any Field can be
# dictionary-encoded, but in this case none of its children may be
# dictionary-encoded.
# There is one vector / column per dictionary, but that vector / column
# may be spread across multiple dictionary batches by using the isDelta
# flag
class DictionaryBatch(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DictionaryBatch()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDictionaryBatch(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # DictionaryBatch
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DictionaryBatch
    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # DictionaryBatch
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = RecordBatch()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # If isDelta is true the values in the dictionary are to be appended to a
    # dictionary with the indicated id. If isDelta is false this dictionary
    # should replace the existing dictionary.
    # DictionaryBatch
    def IsDelta(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def DictionaryBatchStart(builder):
    builder.StartObject(3)

def DictionaryBatchAddId(builder, id):
    builder.PrependInt64Slot(0, id, 0)

def DictionaryBatchAddData(builder, data):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def DictionaryBatchAddIsDelta(builder, isDelta):
    builder.PrependBoolSlot(2, isDelta, 0)

def DictionaryBatchEnd(builder):
    return builder.EndObject()



class Message(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Message()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMessage(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Message
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Message
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # Message
    def HeaderType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Message
    def Header(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # Message
    def BodyLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Message
    def CustomMetadata(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = KeyValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Message
    def CustomMetadataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Message
    def CustomMetadataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def MessageStart(builder):
    builder.StartObject(5)

def MessageAddVersion(builder, version):
    builder.PrependInt16Slot(0, version, 0)

def MessageAddHeaderType(builder, headerType):
    builder.PrependUint8Slot(1, headerType, 0)

def MessageAddHeader(builder, header):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(header), 0)

def MessageAddBodyLength(builder, bodyLength):
    builder.PrependInt64Slot(3, bodyLength, 0)

def MessageAddCustomMetadata(builder, customMetadata):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(customMetadata), 0)

def MessageStartCustomMetadataVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MessageEnd(builder):
    return builder.EndObject()



